<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>The Hidden Side of Type Predicates</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: The Hidden Side of Type Predicates">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; The Hidden Side of Type Predicates">
    <meta name="twitter:description" content="Type guards are a powerful tool for improving TypeScript&#39;s built-in control flow analysis. This post looks at when it&#39;s appropriate to use a type predicate, and in particular what it means when a type predicate returns false.
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; The Hidden Side of Type Predicates">
    <meta property="og:description" content="Type guards are a powerful tool for improving TypeScript&#39;s built-in control flow analysis. This post looks at when it&#39;s appropriate to use a type predicate, and in particular what it means when a type predicate returns false.
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>The Hidden Side of Type Predicates</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2024-02-27T15:45:00.000Z" itemprop="datePublished">
              Tue 27 February 2024
            </time>
          </div>
          <div class="entry-content">
            <p>For the past two months I&#39;ve been participating in a batch at the <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://www.recurse.com/', event);">Recurse Center</a> in Brooklyn, a &quot;writer&#39;s retreat for programmers.&quot; I&#39;ve been having lots of fun learning about <a target="_blank" rel="noopener" href="https://github.com/danvk/gravlax" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/danvk/gravlax', event);">Interpreters</a>, <a target="_blank" rel="noopener" href="https://github.com/danvk/Stanford-CS-242-Programming-Languages" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/danvk/Stanford-CS-242-Programming-Languages', event);">Programming Languages</a> and <a target="_blank" rel="noopener" href="https://github.com/karpathy/nn-zero-to-hero" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/karpathy/nn-zero-to-hero', event);">Neural Nets</a>, but you apply to RC with a <em>project</em> in mind, and mine was to contribute to the TypeScript open source project. I&#39;ve used TypeScript and written about it for years, but I&#39;ve never contributed code to it. Time to change that!</p>
<p>The result is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/microsoft/TypeScript/pull/57465', event);">PR #57465</a>, which adds a feature I&#39;ve always wanted in TypeScript: inference of <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates', event);">type predicates</a>. I&#39;ll have more to say about that PR in a future post. But for now I&#39;d like to share some of what I&#39;ve learned about type predicates while implementing it.</p>
<h2 id="What-are-type-predicates"><a href="#What-are-type-predicates" class="headerlink" title="What are type predicates?"></a>What are type predicates?</h2><p>What is a type predicate? Whenever a function in TypeScript returns a <code>boolean</code>, you can change it to return a &quot;type predicate&quot; instead:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Here <code>x is number</code> is the type predicate. Any function that returns a type predicate is a &quot;user-defined type guard.&quot;</p>
<p>Here&#39;s how you use a type guard:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>In this case there&#39;s little advantage over doing the <code>typeof</code> check directly in the <code>if</code> statement. But type guards really shine in two specific circumstances:</p>
<ol>
<li>When TypeScript can&#39;t infer the type you want on its own.</li>
<li>When you pass the type guard as a callback.</li>
</ol>
<p>The former often comes up with input validation:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isProductReview</span>(<span class="hljs-params">input: unknown</span>): <span class="hljs-title">input</span> <span class="hljs-title">is</span> <span class="hljs-title">ProductReview</span> </span>&#123;<br>  <span class="hljs-comment">// ... validate input using JSONSchema, etc.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>But in this post we&#39;re more interested in the latter. Here&#39;s the motivating scenario:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>);<br><span class="hljs-comment">//    ^? const nums: (number | string)[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());<br>  <span class="hljs-comment">//              ~~~~~~~</span><br>  <span class="hljs-comment">//    Property &#x27;toFixed&#x27; does not exist on type &#x27;string | number&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>We&#39;ve filtered the array of strings and numbers down to just the numbers, but TypeScript hasn&#39;t been able to follow along. The result is a spurious type error.</p>
<p>Changing from an arrow function to the type guard fixes the problem:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(isNumber);<br><span class="hljs-comment">//    ^? const nums: number[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());  <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This works because the declaration of <code>Array.prototype.filter</code> <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260" onclick="return trackOutboundLink('what are type predicates', 'https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260', event);">has been overloaded</a> to work with type predicates. Several built-in <code>Array</code> methods work this way, including <code>find</code> and <code>every</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> num = strsAndNums.find(isNumber);<br><span class="hljs-comment">//    ^? const num: number | undefined</span><br><span class="hljs-keyword">if</span> (strsAndNums.every(isNumber)) &#123;<br>  strsAndNums<br>  <span class="hljs-comment">// ^? const strsAndNums: number[]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="What-if-you-return-false"><a href="#What-if-you-return-false" class="headerlink" title="What if you return false?"></a>What if you return false?</h2><p>If a function returns <code>x is T</code>, then it&#39;s clear what it means when it returns <code>true</code>: <code>x</code> is a <code>T</code>! But what does it mean if it returns <code>false</code>?</p>
<p>TypeScript&#39;s expectation is that type guards return <code>true</code> <em>if and only if</em> the predicate is true. To spell it out:</p>
<ul>
<li>If the type guard returns <code>true</code> then <code>x</code> is <code>T</code>.</li>
<li>If the type guard returns <code>false</code> then <code>x</code> is not <code>T</code>.</li>
</ul>
<p>This often works so intuitively that you don&#39;t even think about it. Using our <code>isNumber</code> type guard, for example:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>But it can definitely go wrong! What about this type guard?</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(x) &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If this returns <code>true</code> then <code>x</code> is definitely a <code>number</code>. But if it returns <code>false</code>, then <code>x</code> could be either a <code>string</code> or a large <code>number</code>. This is not an &quot;if and only if&quot; relationship. This sort of incorrect type predicate can lead to <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsoundness</a>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (isSmallNumber(strOrNum)) &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toFixed());<br>  <span class="hljs-comment">//          ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toUpperCase());<br>  <span class="hljs-comment">//          ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This passes the type checker but blows up at runtime:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  console.log(strOrNum.toUpperCase());<br>                       ^<br><br>Cannot read property toUpperCase of 123.<br></code></pre></td></tr></table></figure>

<p>This highlights two important facts about type guards:</p>
<ol>
<li>TypeScript does very little to check that they&#39;re valid.</li>
<li>There are expectations around the <code>false</code> case, and getting it right matters!</li>
</ol>
<p>Generally functions that combine checks with <code>&amp;&amp;</code> should not be type guards because the type will come out incorrectly for the <code>false</code> case.</p>
<p>Many functions only care about the <code>true</code> case. If you&#39;re just passing your type guard to <code>filter</code> or <code>find</code>, then you won&#39;t get into trouble. But if you pass it to a function like lodash&#39;s <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#partition" onclick="return trackOutboundLink('what if you return false', 'https://lodash.com/docs/4.17.15#partition', event);"><code>_.partition</code></a> then you will:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-keyword">const</span> [smallNums, others] = _.partition(strsOrNums, isSmallNumber);<br><span class="hljs-comment">//                ^? const others: string[]</span><br></code></pre></td></tr></table></figure>

<p>This is an unsound type and it will lead to trouble. It&#39;s interesting to compare this with inlining the check into an <code>if</code> statement:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNum === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(strOrNum) &lt; <span class="hljs-number">10</span>) &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number | string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Left to its own devices, TypeScript gets this right. The only reason it went wrong before was because we fed it bad information: <code>isSmallNumber</code> should not have been a type predicate!</p>
<p>Because of the strict rules around what <code>false</code> means, a type guard cannot, in general, replace an <code>if</code> statement. There&#39;s a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/15048" onclick="return trackOutboundLink('what if you return false', 'https://github.com/microsoft/TypeScript/issues/15048', event);">proposal</a> to fix this by adding &quot;one-sided&quot; or &quot;fine-grained&quot; type guards. If it were adopted, you&#39;d be able to declare something like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> <span class="hljs-title">else</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="A-test-for-valid-type-predicates"><a href="#A-test-for-valid-type-predicates" class="headerlink" title="A test for valid type predicates"></a>A test for valid type predicates</h2><p>In the last example, we could tell that the type predicate was invalid because inlining it into an <code>if</code> statement produced different types in the <code>else</code> block than calling the type guard did.</p>
<p>This feels like a good test for type guards! Does it work?</p>
<p>As it turns out, no! There&#39;s a subtlety around subtyping that hadn&#39;t occurred to me until the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe" onclick="return trackOutboundLink('a test for valid type predicates', 'https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe', event);">tests failed</a> on my PR branch. The details and solution are a little too in the weeds for this post. But when I write a post about the making of this PR, we&#39;ll cover it in depth. There <em>is</em> a test. Check out the PR if you&#39;re curious.</p>
<p>In the meantime, though, we can talk about a few heuristics. If a condition fails the &quot;inlining&quot; test, then it&#39;s definitely not a valid type predicate.</p>
<h2 id="Non-Nullishness-not-Truthiness"><a href="#Non-Nullishness-not-Truthiness" class="headerlink" title="Non-Nullishness, not Truthiness"></a>Non-Nullishness, not Truthiness</h2><p>JavaScript and TypeScript make a distinction between &quot;truthiness&quot; and &quot;non-nullishness&quot;:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> isTruthy&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> !!x;<br><span class="hljs-keyword">const</span> isNonNullish&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>

<p>This is important for types like <code>number</code> and <code>string</code>. Here&#39;s why:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> numOrNull: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (numOrNull) &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number | null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The interesting part is the <code>number</code> in the <code>else</code> block. The number <code>0</code> is falsy, so <code>numOrNull</code> can be a <code>number</code> in the false case. (In theory TypeScript could narrow it to <code>0 | null</code>, but the TS team has decided this is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/45329" onclick="return trackOutboundLink('nonnullishness not truthiness', 'https://github.com/microsoft/TypeScript/issues/45329', event);">not worth it</a>.)</p>
<p>This means that if you make <code>isTruthy</code> return a type predicate, functions like <code>partition</code> will produce unsound types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> numsAndNulls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">//    ^? const numsAndNulls: (number | null)[]</span><br><br><span class="hljs-keyword">const</span> isTruthy = (x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>): x is <span class="hljs-built_in">number</span> =&gt; !!x;  <span class="hljs-comment">// don&#x27;t do this!</span><br><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, isTruthy);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure>

<p>TypeScript thinks that <code>nulls</code> is an array of <code>null</code> values, but it could actually contain numbers (specifically zeroes). This is an <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsound type</a>. It&#39;s also likely to be a logic error: do you really mean to filter out the zeroes? If you&#39;re calculating an average, this will give you an incorrect result.</p>
<p>Better to use <code>isNonNullish</code> or the equivalent. This is safe:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, (x): x is <span class="hljs-built_in">number</span> =&gt; x !== <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure>

<p>You can make the generic <code>isNonNullish</code> into a type predicate, too:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNullish</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">T</span> &amp; </span>&#123;&#125; &#123;<br>  <span class="hljs-keyword">return</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This relies on the <code>&#123;&#125;</code> type, which is TypeScript for &quot;all values except <code>null</code> and <code>undefined</code>.&quot; This is one of the few good uses of this very broad type!</p>
<h2 id="Composing-predicates"><a href="#Composing-predicates" class="headerlink" title="Composing predicates"></a>Composing predicates</h2><p>In general you can compose type predicates with &quot;or&quot;:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooOrBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> | <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) || isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Similarly, you can compose predicates with &quot;and&quot; if their types intersect:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooAndBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> &amp; <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) &amp;&amp; isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This could happen if you have a big discriminated union and you have helpers that match different subsets of it.</p>
<p>Be careful about composing conditions that can&#39;t be fully represented in the type system, however. You can&#39;t define a TypeScript type for &quot;numbers less than 10&quot; or &quot;strings less than ten characters long&quot; or &quot;numbers other than zero.&quot; So conditions like these generally don&#39;t belong in a type guard:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// This should not return a type predicate!</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isShortString</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; x.length &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>When you write a user-defined type guard, it&#39;s easy to only think about the <code>true</code> case: if you write <code>x is string</code> and you know that <code>x</code> must be a <code>string</code> when the function returns <code>true</code>, then surely you&#39;re good to go, right?</p>
<p>As this post has explained, that&#39;s only half the battle. In order for a type guard to be completely safe, it&#39;s also important to know what the type of the parameter is when it returns <code>false</code>. This is the hidden side of type predicates. It&#39;s easy to get wrong, and this can lead to unsound types.</p>
<p>Because it might be used in an <code>if</code> / <code>else</code> statement or with functions like <code>_.partition</code>, you want your type guard to be bulletproof! Make sure you provide the &quot;if and only if&quot; semantics that TypeScript expects.</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="ðŸ’¬ blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('buy2e', 'https://amzn.to/3UjPrsK', event);">Buy 2nd Edition</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScriptâ€™s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more Â»</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('conclusions', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
