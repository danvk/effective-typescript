<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>The Hidden Side of Type Predicates</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: The Hidden Side of Type Predicates">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; The Hidden Side of Type Predicates">
    <meta name="twitter:description" content="Type guards are a powerful tool for improving TypeScript&#39;s built-in control flow analysis. This post looks at when it&#39;s appropriate to use a type predicate, and in particular what it means when a type predicate returns false.
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; The Hidden Side of Type Predicates">
    <meta property="og:description" content="Type guards are a powerful tool for improving TypeScript&#39;s built-in control flow analysis. This post looks at when it&#39;s appropriate to use a type predicate, and in particular what it means when a type predicate returns false.
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>The Hidden Side of Type Predicates</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2024-02-27T15:45:00.000Z" itemprop="datePublished">
              Tue 27 February 2024
            </time>
          </div>
          <div class="entry-content">
            <p>For the past two months I&#39;ve been participating in a batch at the <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://www.recurse.com/', event);">Recurse Center</a> in Brooklyn, a &quot;writer&#39;s retreat for programmers.&quot; I&#39;ve been having lots of fun learning about <a target="_blank" rel="noopener" href="https://github.com/danvk/gravlax" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/danvk/gravlax', event);">Interpreters</a>, <a target="_blank" rel="noopener" href="https://github.com/danvk/Stanford-CS-242-Programming-Languages" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/danvk/Stanford-CS-242-Programming-Languages', event);">Programming Languages</a> and <a target="_blank" rel="noopener" href="https://github.com/karpathy/nn-zero-to-hero" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/karpathy/nn-zero-to-hero', event);">Neural Nets</a>, but you apply to RC with a <em>project</em> in mind, and mine was to contribute to the TypeScript open source project. I&#39;ve used TypeScript and written about it for years, but I&#39;ve never contributed code to it. Time to change that!</p>
<p>The result is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://github.com/microsoft/TypeScript/pull/57465', event);">PR #57465</a>, which adds a feature I&#39;ve always wanted in TypeScript: inference of <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" onclick="return trackOutboundLink('the hidden side of type predicates', 'https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates', event);">type predicates</a>. I&#39;ll have more to say about that PR in a future post. But for now I&#39;d like to share some of what I&#39;ve learned about type predicates while implementing it.</p>
<h2 id="What-are-type-predicates"><a href="#What-are-type-predicates" class="headerlink" title="What are type predicates?"></a>What are type predicates?</h2><p>What is a type predicate? Whenever a function in TypeScript returns a <code>boolean</code>, you can change it to return a &quot;type predicate&quot; instead:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Here <code>x is number</code> is the type predicate. Any function that returns a type predicate is a &quot;user-defined type guard.&quot;</p>
<p>Here&#39;s how you use a type guard:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>In this case there&#39;s little advantage over doing the <code>typeof</code> check directly in the <code>if</code> statement. But type guards really shine in two specific circumstances:</p>
<ol>
<li>When TypeScript can&#39;t infer the type you want on its own.</li>
<li>When you pass the type guard as a callback.</li>
</ol>
<p>The former often comes up with input validation:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isProductReview</span>(<span class="hljs-params">input: unknown</span>): <span class="hljs-title">input</span> <span class="hljs-title">is</span> <span class="hljs-title">ProductReview</span> </span>&#123;<br>  <span class="hljs-comment">// ... validate input using JSONSchema, etc.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>But in this post we&#39;re more interested in the latter. Here&#39;s the motivating scenario:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>);<br><span class="hljs-comment">//    ^? const nums: (number | string)[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());<br>  <span class="hljs-comment">//              ~~~~~~~</span><br>  <span class="hljs-comment">//    Property &#x27;toFixed&#x27; does not exist on type &#x27;string | number&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>We&#39;ve filtered the array of strings and numbers down to just the numbers, but TypeScript hasn&#39;t been able to follow along. The result is a spurious type error.</p>
<p>Changing from an arrow function to the type guard fixes the problem:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(isNumber);<br><span class="hljs-comment">//    ^? const nums: number[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());  <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This works because the declaration of <code>Array.prototype.filter</code> <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260" onclick="return trackOutboundLink('what are type predicates', 'https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260', event);">has been overloaded</a> to work with type predicates. Several built-in <code>Array</code> methods work this way, including <code>find</code> and <code>every</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> num = strsAndNums.find(isNumber);<br><span class="hljs-comment">//    ^? const num: number | undefined</span><br><span class="hljs-keyword">if</span> (strsAndNums.every(isNumber)) &#123;<br>  strsAndNums<br>  <span class="hljs-comment">// ^? const strsAndNums: number[]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="What-if-you-return-false"><a href="#What-if-you-return-false" class="headerlink" title="What if you return false?"></a>What if you return false?</h2><p>If a function returns <code>x is T</code>, then it&#39;s clear what it means when it returns <code>true</code>: <code>x</code> is a <code>T</code>! But what does it mean if it returns <code>false</code>?</p>
<p>TypeScript&#39;s expectation is that type guards return <code>true</code> <em>if and only if</em> the predicate is true. To spell it out:</p>
<ul>
<li>If the type guard returns <code>true</code> then <code>x</code> is <code>T</code>.</li>
<li>If the type guard returns <code>false</code> then <code>x</code> is not <code>T</code>.</li>
</ul>
<p>This often works so intuitively that you don&#39;t even think about it. Using our <code>isNumber</code> type guard, for example:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>But it can definitely go wrong! What about this type guard?</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(x) &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If this returns <code>true</code> then <code>x</code> is definitely a <code>number</code>. But if it returns <code>false</code>, then <code>x</code> could be either a <code>string</code> or a large <code>number</code>. This is not an &quot;if and only if&quot; relationship. This sort of incorrect type predicate can lead to <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsoundness</a>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (isSmallNumber(strOrNum)) &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toFixed());<br>  <span class="hljs-comment">//          ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toUpperCase());<br>  <span class="hljs-comment">//          ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This passes the type checker but blows up at runtime:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  console.log(strOrNum.toUpperCase());<br>                       ^<br><br>Cannot read property toUpperCase of 123.<br></code></pre></td></tr></table></figure>

<p>This highlights two important facts about type guards:</p>
<ol>
<li>TypeScript does very little to check that they&#39;re valid.</li>
<li>There are expectations around the <code>false</code> case, and getting it right matters!</li>
</ol>
<p>Generally functions that combine checks with <code>&amp;&amp;</code> should not be type guards because the type will come out incorrectly for the <code>false</code> case.</p>
<p>Many functions only care about the <code>true</code> case. If you&#39;re just passing your type guard to <code>filter</code> or <code>find</code>, then you won&#39;t get into trouble. But if you pass it to a function like lodash&#39;s <a target="_blank" rel="noopener" href="https://lodash.com/docs/4.17.15#partition" onclick="return trackOutboundLink('what if you return false', 'https://lodash.com/docs/4.17.15#partition', event);"><code>_.partition</code></a> then you will:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-keyword">const</span> [smallNums, others] = _.partition(strsOrNums, isSmallNumber);<br><span class="hljs-comment">//                ^? const others: string[]</span><br></code></pre></td></tr></table></figure>

<p>This is an unsound type and it will lead to trouble. It&#39;s interesting to compare this with inlining the check into an <code>if</code> statement:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNum === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(strOrNum) &lt; <span class="hljs-number">10</span>) &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number | string</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Left to its own devices, TypeScript gets this right. The only reason it went wrong before was because we fed it bad information: <code>isSmallNumber</code> should not have been a type predicate!</p>
<p>Because of the strict rules around what <code>false</code> means, a type guard cannot, in general, replace an <code>if</code> statement. There&#39;s a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/15048" onclick="return trackOutboundLink('what if you return false', 'https://github.com/microsoft/TypeScript/issues/15048', event);">proposal</a> to fix this by adding &quot;one-sided&quot; or &quot;fine-grained&quot; type guards. If it were adopted, you&#39;d be able to declare something like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> <span class="hljs-title">else</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>)</span>;<br></code></pre></td></tr></table></figure>

<h2 id="A-test-for-valid-type-predicates"><a href="#A-test-for-valid-type-predicates" class="headerlink" title="A test for valid type predicates"></a>A test for valid type predicates</h2><p>In the last example, we could tell that the type predicate was invalid because inlining it into an <code>if</code> statement produced different types in the <code>else</code> block than calling the type guard did.</p>
<p>This feels like a good test for type guards! Does it work?</p>
<p>As it turns out, no! There&#39;s a subtlety around subtyping that hadn&#39;t occurred to me until the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe" onclick="return trackOutboundLink('a test for valid type predicates', 'https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe', event);">tests failed</a> on my PR branch. The details and solution are a little too in the weeds for this post. But when I write a post about the making of this PR, we&#39;ll cover it in depth. There <em>is</em> a test. Check out the PR if you&#39;re curious.</p>
<p>In the meantime, though, we can talk about a few heuristics. If a condition fails the &quot;inlining&quot; test, then it&#39;s definitely not a valid type predicate.</p>
<h2 id="Non-Nullishness-not-Truthiness"><a href="#Non-Nullishness-not-Truthiness" class="headerlink" title="Non-Nullishness, not Truthiness"></a>Non-Nullishness, not Truthiness</h2><p>JavaScript and TypeScript make a distinction between &quot;truthiness&quot; and &quot;non-nullishness&quot;:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> isTruthy&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> !!x;<br><span class="hljs-keyword">const</span> isNonNullish&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure>

<p>This is important for types like <code>number</code> and <code>string</code>. Here&#39;s why:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> numOrNull: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (numOrNull) &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number | null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The interesting part is the <code>number</code> in the <code>else</code> block. The number <code>0</code> is falsy, so <code>numOrNull</code> can be a <code>number</code> in the false case. (In theory TypeScript could narrow it to <code>0 | null</code>, but the TS team has decided this is <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/45329" onclick="return trackOutboundLink('nonnullishness not truthiness', 'https://github.com/microsoft/TypeScript/issues/45329', event);">not worth it</a>.)</p>
<p>This means that if you make <code>isTruthy</code> return a type predicate, functions like <code>partition</code> will produce unsound types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> numsAndNulls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">//    ^? const numsAndNulls: (number | null)[]</span><br><br><span class="hljs-keyword">const</span> isTruthy = (x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>): x is <span class="hljs-built_in">number</span> =&gt; !!x;  <span class="hljs-comment">// don&#x27;t do this!</span><br><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, isTruthy);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure>

<p>TypeScript thinks that <code>nulls</code> is an array of <code>null</code> values, but it could actually contain numbers (specifically zeroes). This is an <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsound type</a>. It&#39;s also likely to be a logic error: do you really mean to filter out the zeroes? If you&#39;re calculating an average, this will give you an incorrect result.</p>
<p>Better to use <code>isNonNullish</code> or the equivalent. This is safe:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, (x): x is <span class="hljs-built_in">number</span> =&gt; x !== <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure>

<p>You can make the generic <code>isNonNullish</code> into a type predicate, too:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNullish</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">T</span> &amp; </span>&#123;&#125; &#123;<br>  <span class="hljs-keyword">return</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This relies on the <code>&#123;&#125;</code> type, which is TypeScript for &quot;all values except <code>null</code> and <code>undefined</code>.&quot; This is one of the few good uses of this very broad type!</p>
<h2 id="Composing-predicates"><a href="#Composing-predicates" class="headerlink" title="Composing predicates"></a>Composing predicates</h2><p>In general you can compose type predicates with &quot;or&quot;:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooOrBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> | <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) || isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Similarly, you can compose predicates with &quot;and&quot; if their types intersect:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooAndBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> &amp; <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) &amp;&amp; isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This could happen if you have a big discriminated union and you have helpers that match different subsets of it.</p>
<p>Be careful about composing conditions that can&#39;t be fully represented in the type system, however. You can&#39;t define a TypeScript type for &quot;numbers less than 10&quot; or &quot;strings less than ten characters long&quot; or &quot;numbers other than zero.&quot; So conditions like these generally don&#39;t belong in a type guard:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// This should not return a type predicate!</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isShortString</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; x.length &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>When you write a user-defined type guard, it&#39;s easy to only think about the <code>true</code> case: if you write <code>x is string</code> and you know that <code>x</code> must be a <code>string</code> when the function returns <code>true</code>, then surely you&#39;re good to go, right?</p>
<p>As this post has explained, that&#39;s only half the battle. In order for a type guard to be completely safe, it&#39;s also important to know what the type of the parameter is when it returns <code>false</code>. This is the hidden side of type predicates. It&#39;s easy to get wrong, and this can lead to unsound types.</p>
<p>Because it might be used in an <code>if</code> / <code>else</code> statement or with functions like <code>_.partition</code>, you want your type guard to be bulletproof! Make sure you provide the &quot;if and only if&quot; semantics that TypeScript expects.</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="💬 blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('buy2e', 'https://amzn.to/3UjPrsK', event);">Buy 2nd Edition</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript’s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more »</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('conclusions', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
