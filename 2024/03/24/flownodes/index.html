<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Flow Nodes: How Type Inference Is Implemented</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: Flow Nodes: How Type Inference Is Implemented">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; Flow Nodes: How Type Inference Is Implemented">
    <meta name="twitter:description" content="If a variable gets a type but no one looks at it, does it really get a type at all?
This post looks at how type inference is implemented in the TypeScript compiler. It&#39;s of some interest to anyone who uses TypeScript and is curious how it works, but it will be most relevant to developers who want to contribute to TypeScript itself.
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; Flow Nodes: How Type Inference Is Implemented">
    <meta property="og:description" content="If a variable gets a type but no one looks at it, does it really get a type at all?
This post looks at how type inference is implemented in the TypeScript compiler. It&#39;s of some interest to anyone who uses TypeScript and is curious how it works, but it will be most relevant to developers who want to contribute to TypeScript itself.
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>Flow Nodes: How Type Inference Is Implemented</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2024-03-25T03:00:00.000Z" itemprop="datePublished">
              Sun 24 March 2024
            </time>
          </div>
          <div class="entry-content">
            <style>
  .entry-content img {
    max-height: 400px;
    max-width: 100%;
  }
</style>

<p>In most programming languages a variable has a type and that type does not change. But one of the most interesting aspects of TypeScript&#39;s type system is that a symbol has a type <em>at a location</em>. Various control flow constructs can change this type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refine</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-comment">// type of x is string | number here</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type of x is number here.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// type of x is string here.</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<div style="display: inline-block; width: 256px; float:right; margin-left: 10px; margin-top: 10px;"><img src="https://effectivetypescript.com/images/dall-e-control-flow.jpg" width="256" height="256" alt="Dall-E's interpretation of TypeScript's control flow graph and type inference algorithm."> <i>Dall-E's interpretation of TypeScript's control flow graph and type inference algorithm.</i></div>

<p>This is known as &quot;refinement&quot; or &quot;narrowing.&quot; When I look at TypeScript code, I read it from top to bottom and I think about how the type of <code>x</code> changes as execution moves through each conditional. This works well but, as I learned from my recent work <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('flow nodes how type inference is implemented', 'https://github.com/microsoft/TypeScript/pull/57465', event);">adding a new form of type inference</a> in the TypeScript compiler, it&#39;s not at all how type inference is actually implemented!</p>
<p>For users of TypeScript, reading code from top to bottom works just fine. But if you&#39;re working in the TypeScript compiler itself, you&#39;ll need to know how type inference works &quot;under the hood.&quot; The key to this is &quot;Flow Nodes,&quot; which are the nodes in the Control Flow Graph. I had a remarkably hard time finding documentation about FlowNodes online. The official Compiler-Notes repo <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript-Compiler-Notes/blob/main/codebase/src/compiler/binder.md#control-flow" onclick="return trackOutboundLink('flow nodes how type inference is implemented', 'https://github.com/microsoft/TypeScript-Compiler-Notes/blob/main/codebase/src/compiler/binder.md#control-flow', event);">just has a &quot;TODO&quot;</a> to document them. Basarat&#39;s TypeScript guide makes <a target="_blank" rel="noopener" href="https://basarat.gitbook.io/typescript/overview/checker" onclick="return trackOutboundLink('flow nodes how type inference is implemented', 'https://basarat.gitbook.io/typescript/overview/checker', event);">no mention</a> of them in the section on the TypeScript Compiler.</p>
<p>I learned a lot about FlowNodes from implementing <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('flow nodes how type inference is implemented', 'https://github.com/microsoft/TypeScript/pull/57465', event);">#57465</a> and this post is my attempt to write the &quot;missing manual&quot; on them that I wish I&#39;d had a few months back.</p>
<h2 id="Confusion"><a href="#Confusion" class="headerlink" title="Confusion"></a>Confusion</h2><p>My first clue that type inference didn&#39;t work the way I expected came from reading a PR that Anders Hejlsberg wrote in 2021 to <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/44730" onclick="return trackOutboundLink('confusion', 'https://github.com/microsoft/TypeScript/pull/44730', event);">add &quot;aliased conditions&quot; to type inference</a>. This let you write something like:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refine</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> isNum = <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (isNum) &#123;<br>    <span class="hljs-comment">// type of x is number here.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// type of x is string here.</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>In my top-to-bottom way of thinking about type inference, it seemed like there must be some kind of &quot;tag&quot; associated with the <code>isNum</code> variable indicating that it refined the parameter <code>x</code>. But looking at Anders&#39; PR, this wasn&#39;t at all how it worked. He wasn&#39;t storing any information whatsoever! Instead, all I saw was a bunch of references to flow nodes. So clearly these were important.</p>
<p>When TypeScript parses your code, it forms an <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Abstract_syntax_tree" onclick="return trackOutboundLink('confusion', 'https://en.wikipedia.org/wiki/Abstract_syntax_tree', event);">Abstract Syntax Tree</a> (AST). Any node in the TypeScript AST can have an associated &quot;flow node.&quot; The best way to view the TypeScript AST is David Sherret&#39;s <a target="_blank" rel="noopener" href="https://ts-ast-viewer.com/" onclick="return trackOutboundLink('confusion', 'https://ts-ast-viewer.com/', event);">TS AST Viewer</a>. When you click on a node, it shows you its FlowNode. This consisted of some flags, a node, and one or more &quot;antecedents.&quot; Curiously <code>node.flowNode.node</code> was never the same as <code>node</code>. It was always some other node in the AST.</p>
<p><img src="https://effectivetypescript.com/images/flownode-tree-view.png" alt="A Flow Node and its antecedent in the TS AST Viewer. I didn't find this view very illuminating."> <em>A Flow Node and its antecedent in the TS AST Viewer. I didn&#39;t find this view very illuminating.</em></p>
<h2 id="Graph-Visualization-and-an-Insight"><a href="#Graph-Visualization-and-an-Insight" class="headerlink" title="Graph Visualization and an Insight"></a>Graph Visualization and an Insight</h2><p>The antecedents were other FlowNodes. These seemed to form some sort of graph structure, so I thought that visualizing them might help. I&#39;d used GraphViz and the dot language to create graph visualizations on a <a target="_blank" rel="noopener" href="https://www.sidewalklabs.com/products/delve" onclick="return trackOutboundLink('graph visualization and an insight', 'https://www.sidewalklabs.com/products/delve', event);">previous project</a>, and this seemed like a natural addition to the TS AST Viewer. I learned later that there was already a <a target="_blank" rel="noopener" href="https://github.com/orta/playground-code-show-flow" onclick="return trackOutboundLink('graph visualization and an insight', 'https://github.com/orta/playground-code-show-flow', event);">TypeScript playground plugin</a> that did something similar.</p>
<p>Seeing this graph made it much clearer what was going on. This was the control flow graph in reverse! An <code>if</code> statement came out as a <a target="_blank" rel="noopener" href="https://ts-ast-viewer.com/#code/GYVwdgxgLglg9mABAJwKbBmVAKAHgLkQGcplMBzRAH0TBAFsAjVZASkQG8AoRRCBEohhEAcg0QBeRFACeAB1RxgiXJIlSA5HSYsNAbh5Dl2YWPrtuvXvzBE4AG1QA6e3HLYNphvg0AaFawGvAC+iKj2RKichtYCDs6u7p5EAMqkFD7+uIGGwYY2do4ubh6MAIYQANbScIjg8EiyCho5vGhQIMhIXvQGwUA" onclick="return trackOutboundLink('graph visualization and an insight', 'https://ts-ast-viewer.com/#code/GYVwdgxgLglg9mABAJwKbBmVAKAHgLkQGcplMBzRAH0TBAFsAjVZASkQG8AoRRCBEohhEAcg0QBeRFACeAB1RxgiXJIlSA5HSYsNAbh5Dl2YWPrtuvXvzBE4AG1QA6e3HLYNphvg0AaFawGvAC+iKj2RKichtYCDs6u7p5EAMqkFD7+uIGGwYY2do4ubh6MAIYQANbScIjg8EiyCho5vGhQIMhIXvQGwUA', event);">diamond shape</a>:</p>
<p><img src="https://effectivetypescript.com/images/diamond-refine.png" alt="Control flow graph showing a diamond shape">
<em>Full control flow graph showing a diamond shape for branching code.</em></p>
<p>I showed this to a <a target="_blank" rel="noopener" href="https://github.com/sarahmeyer" onclick="return trackOutboundLink('graph visualization and an insight', 'https://github.com/sarahmeyer', event);">batchmate</a> at <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink('graph visualization and an insight', 'https://www.recurse.com/', event);">Recurse Center</a> who had the key insight: a Node&#39;s Flow Node is the previous statement that executed. With branching constructs, there will be more than one possible previous statement.</p>
<p>With loops, the graph <a target="_blank" rel="noopener" href="https://ts-ast-viewer.com/#code/FA1hmCuB2DGAuBLA9tABAG2cgDgCgEo0BvYNTAU3jQA80BeNARgG4y0B3AC0QwrTx0APMwD6ABkkTJRUuXJ0AVIwBMbeWlioAzsj4A6LAHNBBdWgC+7AE5VI19DTYWgA" onclick="return trackOutboundLink('graph visualization and an insight', 'https://ts-ast-viewer.com/#code/FA1hmCuB2DGAuBLA9tABAG2cgDgCgEo0BvYNTAU3jQA80BeNARgG4y0B3AC0QwrTx0APMwD6ABkkTJRUuXJ0AVIwBMbeWlioAzsj4A6LAHNBBdWgC+7AE5VI19DTYWgA', event);">can even have a cyclic</a>:</p>
<p><img src="https://effectivetypescript.com/images/loop-graph.png" alt="Control flow graph showing a loop">
<em>Control flow graph showing a cycle for looping code.</em></p>
<p>I eventually <a target="_blank" rel="noopener" href="https://twitter.com/danvdk/status/1762868150800977996" onclick="return trackOutboundLink('graph visualization and an insight', 'https://twitter.com/danvdk/status/1762868150800977996', event);">added this visualization</a> to the TS AST Viewer. You can play around with it yourself to get a sense for how Flow Nodes work.</p>
<h2 id="Turning-Type-Inference-Upside-Down"><a href="#Turning-Type-Inference-Upside-Down" class="headerlink" title="Turning Type Inference Upside-Down"></a>Turning Type Inference Upside-Down</h2><p>With some intuition about Flow Nodes in place, the code I was seeing in the type checker started to make a lot more sense.</p>
<p>TypeScript greedily constructs the control flow graph in the binder (<code>binder.ts</code>), then lazily evaluates it as it needs to get types in the checker (<code>checker.ts</code>) or for display (<code>tsserver.ts</code>). This is backwards from how we think about narrowing in our heads: rather than narrowing types as you read down your code, TypeScript narrows types by traversing back <em>up</em> the control flow graph from the point where symbols are referenced.</p>
<p>Why does TypeScript do type inference this way? There are two reasons I can think of. The first is performance. In the context of the compiler, a symbol&#39;s type in a location is called its &quot;flow type.&quot; Determining a symbol&#39;s flow type can be an expensive operation. It requires traversing the control flow graph all the way back to the root (usually the start of a function) and potentially computing some relationships between types along the way.</p>
<p>But often the flow type isn&#39;t needed. If you have an <code>if</code> statement like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logNum</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x is a number&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Then the type of <code>x</code> inside the <code>if</code> statement is <code>number</code>. But that&#39;s not relevant to the type safety of this code in any way. There&#39;s no reason for TypeScript to determine the flow type of <code>x</code>. And indeed, it doesn&#39;t. At least not until you write <code>x</code> in the <code>if</code> block.</p>
<p>This leads us to a profound realization: until it becomes relevant, TypeScript has no idea what the type of <code>x</code> is!</p>
<p>If the type of <code>x</code> becomes relevant for type checking, then TypeScript <em>will</em> determine its flow type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logNum</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// x is referenced, so TypeScript needs to know its type.</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;it&#x27;s a number:&quot;</span>, x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>There may be many local variables in scope in your function. By only determining the flow types of the ones that are relevant for type checking, TypeScript potentially saves an enormous amount of work. This results in a more responsive editor and faster compile times. It also reduces TypeScript&#39;s memory usage: only the control flow graph needs to be stored permanently. Flow types can potentially be thrown away after they&#39;re checked.</p>
<p>The other reason that TypeScript does control flow analysis this way is to separate concerns in their code base. The control flow analysis graph is a standalone structure that&#39;s computed once in the binder. (This is the part of the compiler that determines which symbol <code>x</code> refers to in any location.) This graph can be constructed without any knowledge of what sort of analysis you&#39;d like to do on it.</p>
<p>That analysis happens in the checker, <code>checker.ts</code>. One part of the compiler constructs the graph greedily, the other runs algorithms on it lazily.</p>
<p>This is what I was seeing in <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/44730" onclick="return trackOutboundLink('turning type inference upsidedown', 'https://github.com/microsoft/TypeScript/pull/44730', event);">Anders&#39;s PR</a>. He already had all the information he needed in the control flow graph. His PR just made the algorithm that ran over it a little more elaborate. Very few PRs need to change how the control flow is constructed. It&#39;s much more common to change the algorithms that run over it.</p>
<h2 id="getFlowTypeOfReference"><a href="#getFlowTypeOfReference" class="headerlink" title="getFlowTypeOfReference"></a>getFlowTypeOfReference</h2><p>Speaking of algorithms, let&#39;s take a look at <code>getFlowTypeOfReference</code>, the workhorse of type inference. This is the function that determines the type of a symbol at a location. It&#39;s a real beast, clocking in at over 1200 lines of code. I&#39;d link to it in <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts" onclick="return trackOutboundLink('getflowtypeofreference', 'https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts', event);"><code>checker.ts</code></a>, but GitHub won&#39;t even display files this large!</p>
<p><code>getFlowTypeOfReference</code> is so large because it follows the usual TypeScript compiler style of defining helper functions as local functions inside a large, top-level function. It quickly calls <code>getTypeAtFlowNode</code>, which is where the flow node graph traversal happens.</p>
<p>This function consists of a <code>while</code> loop that looks at the current Flow Node and tries to match it against all the different patterns that can trigger a refinement. If it doesn&#39;t find one, it moves up to the node&#39;s antecedent:</p>
<p><img src="https://effectivetypescript.com/images/flow-type-recursion.png" alt="The code for traversing up the antecedent graph"> <em>The code for traversing up the antecedent graph in getTypeAtFlowNode</em></p>
<p>All the different patterns of refinement that TypeScript supports are represented by helper functions. Here&#39;s a sample:</p>
<ul>
<li>narrowTypeByTruthiness</li>
<li>narrowTypeByBinaryExpression</li>
<li>narrowTypeByTypeof</li>
<li>narrowTypeByTypeName</li>
<li>narrowTypeBySwitchOnDiscriminant</li>
<li>narrowTypeByInstanceof</li>
<li>narrowTypeByTypePredicate</li>
<li>narrowTypeByEquality</li>
<li>narrowTypeByOptionalChainContainment</li>
</ul>
<p>It&#39;s interesting to think about what sort of code would trigger each of these. <code>narrowTypeByEquality</code>, for example, is a special case of <code>narrowTypeByBinaryExpression</code>. It would trigger on code like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// x is string in here</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>(There&#39;s an <code>assumeTrue</code> flag that toggles behavior based on <code>===</code> vs. <code>!==</code>.)</p>
<p><code>narrowTypeByEquality</code> is more subtle than you might expect! Take a look at this code:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x === y) &#123;<br>    <span class="hljs-comment">// x is number</span><br>    <span class="hljs-comment">// y is number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If two values are equal to one another, then their type must be the intersection of their declared types. Very clever, TypeScript!</p>
<p>What about branching constructs? TypeScript traverses up through both branches and unions the result. This should give you a sense for why determining flow types can be expensive! (The code for this is in <code>getTypeAtFlowBranchLabel</code>.)</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Hopefully this post has clarified what flow nodes are and how type narrowing is implemented in the TypeScript compiler. While this isn&#39;t important to understand for TypeScript users, I&#39;m still amazed that, after having used TypeScript for eight years, it turned out to work completely backwards from how I thought!</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="💬 blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('buy2e', 'https://amzn.to/3UjPrsK', event);">Buy 2nd Edition</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. Now in its second edition, the book&#39;s 83 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript’s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more »</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('conclusion', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
