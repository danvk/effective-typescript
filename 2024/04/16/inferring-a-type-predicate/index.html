<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>The Making of a TypeScript Feature: Inferring Type Predicates</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: The Making of a TypeScript Feature: Inferring Type Predicates">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; The Making of a TypeScript Feature: Inferring Type Predicates">
    <meta name="twitter:description" content="Over the past few months I became a TypeScript contributor and implemented a new feature, type predicate inference, that should be one of the headliners for TypeScript 5.5. This post tells the story of how that happened: why I wanted to contribute to TypeScript, the journey to implementing the feature and getting the PR merged, and what I&amp;#39;ve learned along the way.
This is not a short read, but it will give you a good sense of what it&amp;#39;s like to become a TypeScript contributor and develop a new feature.">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; The Making of a TypeScript Feature: Inferring Type Predicates">
    <meta property="og:description" content="Over the past few months I became a TypeScript contributor and implemented a new feature, type predicate inference, that should be one of the headliners for TypeScript 5.5. This post tells the story of how that happened: why I wanted to contribute to TypeScript, the journey to implementing the feature and getting the PR merged, and what I&amp;#39;ve learned along the way.
This is not a short read, but it will give you a good sense of what it&amp;#39;s like to become a TypeScript contributor and develop a new feature.">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>The Making of a TypeScript Feature: Inferring Type Predicates</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2024-04-16T17:30:00.000Z" itemprop="datePublished">
              Tue 16 April 2024
            </time>
          </div>
          <div class="entry-content">
            <p>Over the past few months I became a TypeScript contributor and implemented a new feature, <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('the making of a typescript feature inferring type predicates', 'https://github.com/microsoft/TypeScript/pull/57465', event);">type predicate inference</a>, that should be one of the headliners for TypeScript 5.5. This post tells the story of how that happened: why I wanted to contribute to TypeScript, the journey to implementing the feature and getting the PR merged, and what I&#39;ve learned along the way.</p>
<p>This is not a short read, but it will give you a good sense of what it&#39;s like to become a TypeScript contributor and develop a new feature.</p>
<span id="more"></span>

<h2 id="What-is-Type-Predicate-Inference"><a href="#What-is-Type-Predicate-Inference" class="headerlink" title="What is Type Predicate Inference?"></a>What is Type Predicate Inference?</h2><p>Before we dive into the backstory, let&#39;s take a quick look at the feature I added. If you write code like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">data: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;number&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>TypeScript will now infer that the function is a <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates" onclick="return trackOutboundLink('what is type predicate inference', 'https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates', event);">type predicate</a>:</p>
<img style="max-width: 720px" alt="TypeScript inferring a type predicate" src="https://effectivetypescript.com/images/inferred-predicate.png">

<p>Previously, TypeScript would have inferred a <code>boolean</code> return type. This also works for arrow functions, which means code that filters arrays becomes much more ergonomic:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//    ^? const nums: number[]</span><br><span class="hljs-built_in">console</span>.log(nums[<span class="hljs-number">0</span>].toFixed()); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>Previously, this type would have been <code>(number | null)[]</code> and the last line would have been a type error.</p>
<h2 id="Why-contribute-to-TypeScript"><a href="#Why-contribute-to-TypeScript" class="headerlink" title="Why contribute to TypeScript?"></a>Why contribute to TypeScript?</h2><div style="width: 256px; float:right; margin-left: 10px;"><img src="https://effectivetypescript.com/images/soviet-contribute.png" width="256" height="256" alt="Soviet-style propaganda poster encouraging you to contribute to TypeScript"></div>

<p>I&#39;ve been using TypeScript since 2016. I&#39;ve been <a target="_blank" rel="noopener" href="https://danvdk.medium.com/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8" onclick="return trackOutboundLink('why contribute to typescript', 'https://danvdk.medium.com/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8', event);">writing about it</a> <a target="_blank" rel="noopener" href="https://danvdk.medium.com/a-typed-chain-exploring-the-limits-of-typescript-b50153be53d8" onclick="return trackOutboundLink('why contribute to typescript', 'https://danvdk.medium.com/a-typed-chain-exploring-the-limits-of-typescript-b50153be53d8', event);">almost as long</a>. But I&#39;d never contributed code to it. This felt like a gap in my understanding of TypeScript and its ecosystem. Like most TS users, I have a <a href="https://effectivetypescript.com/2022/12/25/christmas/">long list</a> of features I&#39;d like to see added to the language, and I thought learning about compiler internals would help me understand which of those features were feasible and which weren&#39;t.</p>
<p>At the start of this year, I signed up for a 12-week batch at <a target="_blank" rel="noopener" href="https://www.recurse.com/" onclick="return trackOutboundLink('why contribute to typescript', 'https://www.recurse.com/', event);">Recurse Center</a>, a &quot;writer&#39;s retreat for programmers.&quot; You apply with a project in mind, and mine was to contribute to TypeScript. RC provided an encouraging structure and the space for me to make this leap.</p>
<h2 id="Hopes-and-Fears"><a href="#Hopes-and-Fears" class="headerlink" title="Hopes and Fears"></a>Hopes and Fears</h2><p>I hoped that I&#39;d build a stronger intuition for how TypeScript works internally and maybe have some insights along the way. If I was lucky, maybe I&#39;d be able to say I was a TypeScript contributor and make some improvements to the language.</p>
<p>My biggest fear was that I&#39;d put a lot of work into a PR only to see it stall. There are some <a href="ttps://github.com/microsoft/TypeScript/pull/38839#issuecomment-1160929515">notorious examples</a> of this, most famously the <a target="_blank" rel="noopener" href="https://twitter.com/JoshuaKGoldberg/status/1481654056422567944?lang=en" onclick="return trackOutboundLink('hopes and fears', 'https://twitter.com/JoshuaKGoldberg/status/1481654056422567944?lang=en', event);">cake-driven development incident</a>. I knew the real goal was to learn more about TypeScript. But I did hope to get a change accepted.</p>
<h2 id="Finding-a-first-issue"><a href="#Finding-a-first-issue" class="headerlink" title="Finding a first issue"></a>Finding a first issue</h2><!-- 2024-01-12 to 01-26 -->

<p><em>Mid- to Late-January 2024</em></p>
<p>Before trying to implement something substantial, I thought I&#39;d start by fixing a trivial bug. This would help me get familiar with the compiler and the development process. This is exactly how the TypeScript docs suggest you get started as a contributor.</p>
<p>Finding a &quot;good first issue&quot; proved harder than I&#39;d expected. Most of the small, newly-filed issues get fixed quickly by one or two experienced community members. From a community perspective, this is great: if you file a bug and it&#39;s accepted, it&#39;s likely to get fixed. But for a new contributor this isn&#39;t good: I was unlikely to win any races to fix an issue.</p>
<p>There&#39;s a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/labels/Good%20First%20Issue" onclick="return trackOutboundLink('finding a first issue', 'https://github.com/microsoft/TypeScript/labels/Good%20First%20Issue', event);">good first issue</a> label, but this proved to be a bit of a joke. My <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/29707" onclick="return trackOutboundLink('finding a first issue', 'https://github.com/microsoft/TypeScript/issues/29707', event);">favorite issue</a> in this category was discussed by three of the top contributors to TypeScript, who decided it was impossible or not worth doing. But it&#39;s still got that &quot;good first issue&quot; label!</p>
<p>Eventually I found <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/53182" onclick="return trackOutboundLink('finding a first issue', 'https://github.com/microsoft/TypeScript/issues/53182', event);">#53182</a>, which involved numeric separators (<code>1_234</code>) not getting preserved in JS emit. This seemed low stakes and, as an added bonus, I&#39;m a fan of the <a target="_blank" rel="noopener" href="https://macwright.com/" onclick="return trackOutboundLink('finding a first issue', 'https://macwright.com/', event);">developer</a> who filed it.</p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57144" onclick="return trackOutboundLink('finding a first issue', 'https://github.com/microsoft/TypeScript/pull/57144', event);">fix</a> was a one-liner, just like you&#39;d expect, but I learned a lot about how TypeScript works along the way. TypeScript&#39;s code structure defies many best practices. All the code for type checking is in a single file, <code>checker.ts</code>, that&#39;s over 50,000 lines of code. And these are meaty lines since there&#39;s no set line width and relatively few comments. It also makes extensive use of numeric enums, a feature I discourage in <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('finding a first issue', 'https://amzn.to/3HIrQN6', event);">Effective TypeScript</a>.</p>
<p>That being said, there are some impressive parts of the tooling. Visual debugging (F5) works great in VS Code and is an excellent way to learn what the compiler is doing. There are relatively few unit tests, but there&#39;s an enormous collection of &quot;baselines,&quot; a sort of end-to-end test that snapshots the types and errors for a code sample. There are over 18,000 of these, but TypeScript is able to run all of them on my laptop in just a few minutes.</p>
<p>After a few weeks, my PR was merged and released as part of TypeScript 5.4. I was officially a TypeScript contributor!</p>
<h2 id="A-meatier-second-issue"><a href="#A-meatier-second-issue" class="headerlink" title="A meatier second issue"></a>A meatier second issue</h2><!-- Starting ~2024-01-26; first commit on infer-guard is 2024-02-02 -->

<p><em>January 26, 2024</em></p>
<p>Fixing a small bug was a good start, but my bigger goal was to implement a new feature. Of all the issues I&#39;d filed on TypeScript, <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/16069" onclick="return trackOutboundLink('a meatier second issue', 'https://github.com/microsoft/TypeScript/issues/16069', event);">#16069</a> stood out with over 500 üëçs. This issue requested that TypeScript infer <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards" onclick="return trackOutboundLink('a meatier second issue', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards', event);">type predicates</a> for functions like <code>x =&gt; x !== null</code>. Clearly I wasn&#39;t the only one who wanted this!</p>
<p>I also had reason to think that this issue might be solvable. In <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/" onclick="return trackOutboundLink('a meatier second issue', 'https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/', event);">TypeScript 4.4</a> (2021), Anders added support for <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#control-flow-analysis-of-aliased-conditions-and-discriminants" onclick="return trackOutboundLink('a meatier second issue', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#control-flow-analysis-of-aliased-conditions-and-discriminants', event);">aliased conditions and discriminants</a>. This let you write code like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> ok = x !== <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (ok) &#123;<br>    x  <span class="hljs-comment">// type is string</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Surely the <code>ok</code> symbol had to have information stored on it saying that its value was tied to a refinement on <code>x</code>. If I looked at Anders&#39; PR, I&#39;d find where this was stored. This felt at least adjacent to my issue. And it was a good story: the feature only became feasible after another seemingly-unrelated feature was added. There were even <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/16069#issuecomment-893914922" onclick="return trackOutboundLink('a meatier second issue', 'https://github.com/microsoft/TypeScript/issues/16069#issuecomment-893914922', event);">some comments</a> suggesting as much.</p>
<p>As it turned out, this was totally wrong! Nothing was stored on the <code>ok</code> symbol and I totally misunderstood how type inference worked. This was a big insight for me, and I wrote about it in my last blog post, <a href="https://effectivetypescript.com/2024/03/24/flownodes/">Flow Nodes: How Type Inference Is Implemented</a>. Head over there to learn all about this epiphany.</p>
<p>As part of my efforts to understand how control-flow analysis worked, I wrote some code to visualize TypeScript&#39;s control flow graph. I <a target="_blank" rel="noopener" href="https://twitter.com/danvdk/status/1762868150800977996" onclick="return trackOutboundLink('a meatier second issue', 'https://twitter.com/danvdk/status/1762868150800977996', event);">contributed this</a> as a new feature to the <a target="_blank" rel="noopener" href="https://ts-ast-viewer.com/" onclick="return trackOutboundLink('a meatier second issue', 'https://ts-ast-viewer.com/', event);">TS AST Viewer</a>. This was a nice, concrete win: even if my work on type predicate inference went nowhere, at least I&#39;d contributed something of value to the ecosystem.</p>
<h2 id="quot-OK-maybe-this-isn‚Äôt-hopeless‚Ä¶-quot"><a href="#quot-OK-maybe-this-isn‚Äôt-hopeless‚Ä¶-quot" class="headerlink" title="&quot;OK, maybe this isn‚Äôt hopeless‚Ä¶&quot;"></a>&quot;OK, maybe this isn‚Äôt hopeless‚Ä¶&quot;</h2><p><em>Week of February 2, 2024</em></p>
<p>Having built a stronger understanding of how type inference worked, I came back to the original problem. Did this make implementing my feature easier or harder?</p>
<p>Whenever I explained this feature, I&#39;d demo how you could put the return expression in an <code>if</code> statement to see the narrowed type of the parameter:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNull</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x !== <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// -&gt;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNullRewrite</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span>) &#123;<br>    x  <span class="hljs-comment">// type is number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The key insight was to realize that I could do the exact same thing with the control flow graph. I&#39;d just have to synthesize a <code>FlowCondition</code> node, plug it into wherever the <code>return</code> statement was, and check the type of the parameter in that branch if the condition was <code>true</code>. If it was different than the declared type, then I had a type predicate!</p>
<p>I could check the type of a parameter at a location using the <code>getFlowTypeOfReference</code> function. But where to put this check? This was also a challenge, but eventually I found a place in <code>getTypePredicateOfSignature</code> to slot it in. I added a new function, <code>getTypePredicateFromBody</code>, that this would call for boolean-returning functions.</p>
<p>This was all a bit of a struggle since it was my first time really working with the type checker. Even simple things felt quite hard. What&#39;s the difference between a <code>Declaration</code>, a <code>Symbol</code> and an <code>Identifier</code>? How should I go from one to the other? Often I found a <a target="_blank" rel="noopener" href="https://github.com/danvk/TypeScript/commit/a6a34c1523f3e70cda676cd75879ce53b6bcff51" onclick="return trackOutboundLink('quotok maybe this isnt hopelessquot', 'https://github.com/danvk/TypeScript/commit/a6a34c1523f3e70cda676cd75879ce53b6bcff51', event);">very roundabout way</a> that let me keep making progress before I later found a more canonical path. For example, if <code>param</code> is a <code>ParameterDeclaration</code>, then you can use <code>param.name</code> to get a <code>BindingName</code>, and <code>isIdentifier(param.name)</code> to make sure it&#39;s an <code>Identifier</code>.</p>
<p>Running the tests was easy, but it took me a bit longer to realize how to test them in an interactive setting. So far as I can tell, building your own version of the TypeScript Playground isn&#39;t possible. But if you run <code>hereby local</code>, it will build <code>tsc.js</code>, and you can point any VS Code workspace at that version of TypeScript. You can even do this for the TypeScript repo itself.</p>
<p>While learning my way around the codebase, I found it incredibly helpful to take notes. Which function did what? What questions did I have? What was I struggling with? What did I have left to do? This helped to keep me oriented and also gave me a sense of progress. In particular, it was satisfying to read questions I&#39;d had weeks earlier that I now knew the answer to. Clearly I was learning! By the time my PR was merged, my Notion doc ran to 70+ pages of notes.</p>
<p>Eventually I was able to fit all the pieces together, though, and this let me infer type predicates for the first time, which was hugely encouraging!</p>
<h2 id="43-failures"><a href="#43-failures" class="headerlink" title="43 failures"></a>43 failures</h2><p><em>Week of February 9, 2024</em></p>
<p>This let me run the 18,000+ TypeScript &quot;baselines.&quot; This was an exciting moment: the first time I&#39;d see how my inference algorithm behaved on unfamiliar code! My initial implementation produced 43 test failures. I went through and categorized these:</p>
<ul>
<li>32 were &quot;Maximum call stack size exceeded&quot; errors</li>
<li>5 were the identify function on booleans</li>
<li>1 involved my mishandling a function with multiple returns</li>
<li>The other 5 were wins!</li>
</ul>
<p>This change was pretty funny:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// function identity(b: boolean): b is true</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">b: <span class="hljs-built_in">boolean</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The identity function on booleans <em>is</em> a type predicate! But that didn&#39;t seem very useful. I added a special case to skip boolean parameters.</p>
<p>The maximum call stack errors turned out to be an infinite loop. I added some code to block this. Then I changed my code to only run on functions with a single <code>return</code> statement. This left me with just the wins.</p>
<p>One of these wins got me particularly excited:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guard1</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guard2</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> guard1(x);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>I was inferring that <code>guard2</code> was a type guard because <code>guard1</code> was. This meant that type predicates could flow! There was another <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/10734" onclick="return trackOutboundLink('failures', 'https://github.com/microsoft/TypeScript/issues/10734', event);">long-standing issue</a> requesting just this behavior. Anders has said that you never want to fix just a single issue, you always want to fix a whole category of problems. This was an encouraging sign that I was doing just that. I hadn&#39;t set out to make type predicates flow, it just followed naturally from my change and TypeScript&#39;s control flow analysis.</p>
<h2 id="More-Predicates-in-More-Places"><a href="#More-Predicates-in-More-Places" class="headerlink" title="More Predicates in More Places"></a>More Predicates in More Places</h2><p><em>Week of February 16, 2024</em></p>
<p>To keep things simple, I&#39;d only been considering function statements, not function expressions or arrow functions. Now that I&#39;d validated the basic approach, I wanted to support these, too.</p>
<p>Standalone function expressions and arrow functions weren&#39;t difficult to add, but I had a lot of trouble with functions whose parameter types are determined by context. For example:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">null</span>];<br><span class="hljs-keyword">const</span> nums = xs.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>The type of <code>x</code> is <code>number | null</code>, but TypeScript only determines this from a complex sequence of type inferences. I kept getting <code>any</code> types.</p>
<p>This problem didn&#39;t turn out to be deep. It just required finding the right function to call. <code>getTypeForVariableLikeDeclaration</code> did not work, but eventually I discovered <code>getNarrowedTypeOfSymbol</code>, which did. For the final PR I switched over to <code>getSymbolLinks</code>.</p>
<p>This was another really exciting moment! My commit message nicely captures my feelings:</p>
<img style="max-width: 100%" src="https://effectivetypescript.com/images/omg-it-works.png" alt="commit message reading OMG IT WORKS">

<p>Nearly seven years after I&#39;d filed the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/16069" onclick="return trackOutboundLink('more predicates in more places', 'https://github.com/microsoft/TypeScript/issues/16069', event);">original issue</a>, I was able to make it pass the type checker:</p>
<img style="max-width: 100%" src="https://effectivetypescript.com/images/even-squares.png" alt="code sample passing type checker.">

<p>Success would be fleeting for this code sample, though, as I was about to find out.</p>
<h2 id="Pathological-Cases-and-an-Insight"><a href="#Pathological-Cases-and-an-Insight" class="headerlink" title="Pathological Cases and an Insight"></a>Pathological Cases and an Insight</h2><p>As I was developing the feature, I started collecting a set of &quot;pathological&quot; functions, ones that I thought might trip up my algorithm. The goal here is to think of everything that could possibly go wrong. That&#39;s impossible, of course, but the more bugs you work out on your own, the better.</p>
<p>This one turned out to be particularly interesting:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsString</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Should this be a type predicate? If it returns <code>true</code>, then you know that <code>x</code> is a <code>string</code>. But what if it returns <code>false</code>? In that case, <code>x</code> could be either <code>string</code> or <code>null</code>.</p>
<p>TypeScript infers correct types on both sides if we rewrite this as an <code>if</code> statement:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringRewrite</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x; <span class="hljs-comment">// type is string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x; <span class="hljs-comment">// type is string | null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>But if you make this a type predicate, that nuance is lost:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsString</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> sOrN: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (flakyIsString(sOrN)) &#123;<br>  sOrN  <span class="hljs-comment">// type is string</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  sOrN  <span class="hljs-comment">// type is null üò±</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>In other words, <code>flakyIsString</code> should <em>not</em> be a type predicate. This forced me to reformulate my criterion for inferring type predicates to consider the <code>false</code> case. If you rewrite a function that returns <code>expr</code> like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: InitType</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (expr) &#123;<br>    x  <span class="hljs-comment">// TrueType</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Then I required that <code>FalseType = Exclude&lt;InitType, TrueType&gt;</code>. This was the criterion I used when I first posted the PR, but it turned out to be subtly incorrect.</p>
<p>I hadn&#39;t realized that type predicates had these &quot;if and only if&quot; semantics before working on this PR. This was a genuine insight, and I wrote about in another post on this blog: <a href="https://effectivetypescript.com/2024/02/27/type-guards/">The Hidden Side of Type Predicates</a>.</p>
<h2 id="Plot-Twist-Truthiness-and-Nullishness"><a href="#Plot-Twist-Truthiness-and-Nullishness" class="headerlink" title="Plot Twist: Truthiness and Nullishness"></a>Plot Twist: Truthiness and Nullishness</h2><p>Here&#39;s the example code from the original feature request in 2017:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> evenSquares: <span class="hljs-built_in">number</span>[] =<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>        .map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? x * x : <span class="hljs-literal">null</span>)<br>        .filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !!x);  <span class="hljs-comment">// errors, but should not</span><br></code></pre></td></tr></table></figure>

<p>With my new criterion came a real <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1959570195" onclick="return trackOutboundLink('plot twist truthiness and nullishness', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1959570195', event);">plot twist</a>: I stopped inferring a type guard in this case! The reason is that &quot;truthiness&quot; doesn&#39;t cleanly separate <code>number|null</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (!!x) &#123;<br>  x;  <span class="hljs-comment">// number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  x;  <span class="hljs-comment">// number | null</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>number</code> is possible in the <code>else</code> case because <code>0</code> is falsy. (A type of <code>0|null</code> <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/45329" onclick="return trackOutboundLink('plot twist truthiness and nullishness', 'https://github.com/microsoft/TypeScript/issues/45329', event);">would be more precise</a>).</p>
<p>I saw this as a mixed bag. While it meant that I didn&#39;t truly &quot;fix&quot; the original issue, I also think it&#39;s a good behavior. Checking for &quot;truthiness&quot; is usually a bad idea with primitive types. You typically want to exclude just <code>null</code> or <code>undefined</code>, not <code>0</code> or <code>&quot;&quot;</code>. Filtering out <code>0</code> when you mean to filter out <code>null</code> is a common source of bugs.</p>
<p>To infer a type predicate for <code>x =&gt; !!x</code>, TypeScript would either need <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/4196" onclick="return trackOutboundLink('plot twist truthiness and nullishness', 'https://github.com/microsoft/TypeScript/issues/4196', event);">negated types</a> (so that you could represent &quot;numbers other than 0&quot;) or <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/15048" onclick="return trackOutboundLink('plot twist truthiness and nullishness', 'https://github.com/microsoft/TypeScript/issues/15048', event);">one-sided type predicates</a>. Both are beyond the scope of my PR.</p>
<p>My change <em>will</em> infer a type predicate from <code>x =&gt; !!x</code> for object types, where there&#39;s no ambiguity.</p>
<h2 id="Putting-up-the-PR"><a href="#Putting-up-the-PR" class="headerlink" title="Putting up the PR"></a>Putting up the PR</h2><p><em>February 20‚Äì21, 2024</em></p>
<p>I showed my PR to <a target="_blank" rel="noopener" href="https://www.joshuakgoldberg.com/" onclick="return trackOutboundLink('putting up the pr', 'https://www.joshuakgoldberg.com/', event);">Josh Goldberg</a> around this time. I was a bit nervous to post the PR‚ÄîI&#39;d put a lot of work into it at this point!‚Äîbut he was excited and gave me the pep talk that I needed. So I wrote up a detailed PR description and <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465" onclick="return trackOutboundLink('putting up the pr', 'https://github.com/microsoft/TypeScript/pull/57465', event);">posted</a> my code the next day.</p>
<p>There was a <em>lot</em> of excitement! It was fun and encouraging to see all the positive feedback on Twitter. In particular Brad Zacher <a target="_blank" rel="noopener" href="https://twitter.com/bradzacher/status/1760414631548653729" onclick="return trackOutboundLink('putting up the pr', 'https://twitter.com/bradzacher/status/1760414631548653729', event);">introduced</a> me to <a target="_blank" rel="noopener" href="https://flow.org/en/docs/types/functions/#predicate-functions" onclick="return trackOutboundLink('putting up the pr', 'https://flow.org/en/docs/types/functions/#predicate-functions', event);"><code>%checks</code></a>, which was a similar feature in Flow. His experience using this <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57552#issuecomment-1965983413" onclick="return trackOutboundLink('putting up the pr', 'https://github.com/microsoft/TypeScript/pull/57552#issuecomment-1965983413', event);">proved helpful later</a> in keeping the scope of my PR large.</p>
<p>I&#39;d run all the TypeScript unit tests on my laptop, so I knew that those passed. But there was a new test that failed in a really interesting way‚Ä¶</p>
<h2 id="A-Scary-Self-Check-Error"><a href="#A-Scary-Self-Check-Error" class="headerlink" title="A Scary Self-Check Error"></a>A Scary Self-Check Error</h2><p><em>February 21, 2024</em></p>
<p>TypeScript is written in‚Ä¶ TypeScript! This is a bit of a headscratcher at first, but it&#39;s actually a common practice in programming languages known as <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1254542/what-is-bootstrapping" onclick="return trackOutboundLink('a scary selfcheck error', 'https://stackoverflow.com/questions/1254542/what-is-bootstrapping', event);">bootstrapping</a>. As such, it&#39;s important that TypeScript be able to compile itself with every change.</p>
<p>My PR was unable to compile TypeScript, and for a very interesting reason. It boiled down to whether this function should be a type predicate:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This is the same as <code>flakyIsString</code>, but with a broader parameter type. We can convert this to an <code>if</code> statement as usual:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType: unknown</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Since <code>Exclude&lt;unknown, string&gt; = unknown</code>, my PR inferred a type predicate for this function. And that <em>is</em> valid if you call it with a symbol whose type is <code>unknown</code>. But there&#39;s no reason you have to do that! As with any function in TypeScript, you can call it with a subtype of the declared type. And if we infer a type predicate, that&#39;s trouble:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> sOrN: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">if</span> (flakyIsStringUnknown(sOrN)) &#123;<br>  sOrN  <span class="hljs-comment">// type is string</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  sOrN  <span class="hljs-comment">// type is number üò±</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The type in the <code>else</code> case is wrong. It could still be a <code>string</code>. So something was wrong with my criterion. I <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1957751656" onclick="return trackOutboundLink('a scary selfcheck error', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1957751656', event);">feared</a> that this might be a fundamental problem with my approach.</p>
<p>I decided to step away from the problem and go for a walk.</p>
<h2 id="Saving-the-PR-A-New-Criterion"><a href="#Saving-the-PR-A-New-Criterion" class="headerlink" title="Saving the PR: A New Criterion"></a>Saving the PR: A New Criterion</h2><p>Recall that this was the criterion I was using:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseType = Exclude&lt;InitType, TrueType&gt;<br></code></pre></td></tr></table></figure>

<p><code>InitType</code> is the declared parameter type. Really I needed that relationship to hold not just for <code>InitType</code> but <em>for all subtypes</em> of <code>InitType</code>. But how on earth to test that?</p>
<p>Intuitively, it seemed to me like there was just one subtype of <code>InitType</code> that was worth testing: <code>TrueType</code>. If I set <code>InitType=TrueType</code>, I could run the same inference algorithm again to get <code>TrueSubType</code> and <code>FalseSubType</code>. Then I could check a secondary criterion:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseSubType = Exclude&lt;TrueType, TrueSubtype&gt;<br></code></pre></td></tr></table></figure>

<p>Here&#39;s what this would look like for <code>flakyIsStringUnknown</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;  <span class="hljs-comment">// InitType: unknown</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType: unknown</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// ‚úÖ unknown = Exclude&lt;unknown, string&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknownSub</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-comment">// TrueType: string</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueSubType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseSubType: string</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// ‚ùå string != Exclude&lt;string, string&gt;</span><br></code></pre></td></tr></table></figure>

<p>This seemed to work, at the expense of making four calls to <code>getFlowTypeOfReference</code> rather than two. But correctness first, performance second. The PR was working again!</p>
<h2 id="A-Surprising-Circularity-Error"><a href="#A-Surprising-Circularity-Error" class="headerlink" title="A Surprising Circularity Error"></a>A Surprising Circularity Error</h2><p><em>February 23, 2024</em></p>
<!-- 2024-02-23: fixed the circularity error (https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1961723998) -->

<p>With the tests passing, I got my first glimpse of the performance impact of my changes, as well as the new errors on TypeScript&#39;s broader test suite of popular repos.</p>
<p>The performance wasn&#39;t great: +5% on one of their standard benchmarks.</p>
<p>There were <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960271216" onclick="return trackOutboundLink('a surprising circularity error', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960271216', event);">six failures</a>. Four were sensible consequences of my change. <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960328566" onclick="return trackOutboundLink('a surprising circularity error', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960328566', event);">This one</a> from VS Code was particularly interesting:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> responseItems = items.filter(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> isResponseVM(i));<br></code></pre></td></tr></table></figure>

<p><code>isResponseVM</code> is a type guard. The author of this code wrapped it in an arrow function to avoid applying it as a refinement to the <code>items</code> array. But with my PR TypeScript wasn&#39;t so easily fooled! The type guard flowed through and the type of <code>responseItems</code> changed.</p>
<p>The only really problematic failure came from <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1961723998" onclick="return trackOutboundLink('a surprising circularity error', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1961723998', event);">Prisma</a>. This was a new &quot;circular reference&quot; error. I spent quite a while setting up a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/main/tests/cases/compiler/circularConstructorWithReturn.ts" onclick="return trackOutboundLink('a surprising circularity error', 'https://github.com/microsoft/TypeScript/blob/main/tests/cases/compiler/circularConstructorWithReturn.ts', event);">minimal reproduction</a> of this before I realized what was going on: my code was running on constructor functions!</p>
<p>But not just any constructor function. Only constructor functions with exactly one <code>return</code> statement. Did you know that a constructor function in JS could have a <code>return</code> statement? I didn&#39;t. <a target="_blank" rel="noopener" href="https://www.mgaudet.ca/technical/2020/7/24/investigating-the-return-behaviour-of-js-constructors" onclick="return trackOutboundLink('a surprising circularity error', 'https://www.mgaudet.ca/technical/2020/7/24/investigating-the-return-behaviour-of-js-constructors', event);">It&#39;s allowed</a>, but exceedingly rare. Regardless, constructors can&#39;t be type predicates, so I excluded them and this fixed the test.</p>
<p>One insight here is that lots of valid TypeScript code is teetering on the edge of triggering a circularity error. Just by checking a type in a different sequence in <code>checker.ts</code>, you might cause enough of a change to tip some over.</p>
<h2 id="Performance-and-the-Final-Criterion"><a href="#Performance-and-the-Final-Criterion" class="headerlink" title="Performance and the Final Criterion"></a>Performance and the Final Criterion</h2><p><em>February 25, 2024</em></p>
<!-- 2024-02-25: new criterion in place, posted on 26th https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842 -->

<p>With the changes in the test suite well-characterized, I started to think about performance. Were those four calls to <code>getFlowTypeOfReference</code> all necessary? The <code>TrueSubtype</code> was irrelevant. It should just be the same as <code>TrueType</code>. Maybe I could also ditch <code>FalseType</code> and go directly to the <code>FalseSubtype</code> test.</p>
<p>Moreover, if <code>TrueType == TrueSubtype</code>, and</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseSubType = Exclude&lt;TrueType, TrueSubtype&gt;<br></code></pre></td></tr></table></figure>

<p>then really what I need to test is <code>FalseSubtype == never</code>. This was a nice win because it got me back to two calls to <code>getFlowTypeOfReference</code> <em>and</em> let me drop potentially-expensive <code>Exclude</code> calculations.</p>
<p>This wound up being the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842" onclick="return trackOutboundLink('performance and the final criterion', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842', event);">final version of the criterion</a>. Let&#39;s walk through how it works for this function:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>First we rewrite this to an <code>if</code> statement to get the <code>TrueType</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType = string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Next we pass this through as the parameter type and look at the <code>else</code> case:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// type is never</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If this type is <code>never</code> then we have a bulletproof type predicate. Otherwise we don&#39;t. This makes good intuitive sense: if the function returns true for every value in a type, then there should be nothing left in the <code>else</code> case, where it returns false.</p>
<p>With fewer calls to <code>getFlowTypeOfReference</code> and a simple <code>never</code> check, the performance hit dropped from 5% down to 1-2%.</p>
<h2 id="More-performance"><a href="#More-performance" class="headerlink" title="More performance"></a>More performance</h2><p><em>February 27‚ÄìMarch 6, 2024</em></p>
<!--
Anders review 2024-02-29
Ill-fated optimization on 2024-03-02
Second ill-fated opti on 2024-03-06
-->

<p>At this point my PR started to get <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/57568" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/issues/57568', event);">discussed</a> at the <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/57599" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/issues/57599', event);">weekly design meetings</a>. They were generally supportive but wanted to track down that performance hit.</p>
<p>This set off a flurry of optimizations. Ryan <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57552" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/pull/57552', event);">experimented</a> with narrowing the scope of the PR. Anders <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57612" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/pull/57612', event);">reordered</a> some of the checks. I profiled my change and <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842', event);">thought I found a big win</a> that didn&#39;t hold up.</p>
<p>An insight from profiling was that <code>getTypePredicateFromBody</code> was usually quite fast, but there were a few pathological cases where it could be very slow. This was the worst of the worst:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBindableName</span>(<span class="hljs-params">node: Declaration</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> !hasDynamicName(node) || hasLateBindableName(node);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Both <code>hasDynamicName</code> and <code>hasLateBindableName</code> are explicit type predicates. So should this be a type predicate? Here&#39;s how the types come out:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">InitType &#x3D; Declaration<br>TrueType &#x3D; NumericLiteral | StringLiteral | NoSubstitutionTemplateLiteral | Identifier | TypeParameterDeclaration | ... 106 more ... | LateBoundBinaryExpressionDeclaration<br>FalseSubtype &#x3D; (PropertySignature &amp; DynamicNamedDeclarationBase) | (PropertyDeclaration &amp; DynamicNamedDeclarationBase) | ... 17 more ... | DynamicNamedBinaryExpression<br></code></pre></td></tr></table></figure>

<p>That&#39;s a big union! Calculating these types, particularly the <code>FalseSubtype</code>, winds up being very expensive. This one call took 300ms on my laptop and accounted for 80% of the slowdown on one benchmark.</p>
<p>I tried adding a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57660" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/pull/57660', event);">few more optimizations</a> but unfortunately they didn&#39;t change the perf numbers much. So a 1-2% slowdown is where it was going to be.</p>
<p>A highlight here was getting a very positive <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1909849513" onclick="return trackOutboundLink('more performance', 'https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1909849513', event);">code review</a> from Anders. This is definitely going on my resume!</p>
<img src="https://effectivetypescript.com/images/anders-code-review.png" alt="Positive Code Review from Anders Hejlsberg" style="max-width: 100%">

<h2 id="A-productive-prod"><a href="#A-productive-prod" class="headerlink" title="A productive prod"></a>A productive prod</h2><p><em>March 12, 2024</em></p>
<p>At this point the PR stalled for around a week. I wanted to keep things moving along, but I also didn&#39;t want to be that person posting &quot;any updates?&quot; comments. I&#39;ve been on both sides of this. Those comments are rarely helpful. Presumably everyone wants the PR to make progress, there are just other priorities.</p>
<p>But in this case, there was an opportunity for a more constructive nudge. I had a draft of the <a target="_blank" rel="noopener" href="https://www.amazon.com/Effective-Typescript-Specific-Ways-Improve/dp/1098155068/" onclick="return trackOutboundLink('a productive prod', 'https://www.amazon.com/Effective-Typescript-Specific-Ways-Improve/dp/1098155068/', event);">second edition</a> of <em>Effective TypeScript</em> due on March 15th. One of the new items was &quot;Know how to filter null values from lists.&quot; If my PR went in, that item would be completely unsalvageable, and the best course of action would be to delete it completely.</p>
<p>Ryan Cavanaugh was a reviewer for the book, so I asked him what he thought the odds of my PR being merged were. If they were greater than 50/50, I should just delete the item.</p>
<p>Ryan said that Anders was &quot;super stoked&quot; on the PR and he thought it would go in for 5.5. Wow! Even better, he took the hint and reassigned the PR to Anders, who immediately approved it. Amazing! Ryan said he&#39;d ping the team for a last round of reviews.</p>
<h2 id="The-final-review"><a href="#The-final-review" class="headerlink" title="The final review"></a>The final review</h2><p><em>March 13‚Äì15, 2024</em></p>
<p>During that final round of reviews, Wes Wigham found <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1935559962" onclick="return trackOutboundLink('the final review', 'https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1935559962', event);">two more issues</a>:</p>
<ol>
<li>I needed to avoid inferring type predicates for <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" onclick="return trackOutboundLink('the final review', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters', event);">rest parameters</a> (a pathological case I&#39;d missed!)</li>
<li>I needed to make sure that inferred type predicates showed up in emitted declaration files (<code>.d.ts</code>), just like inferred return types do.</li>
</ol>
<p>Adding <code>.d.ts</code> emit would have been a daunting change at the start of this process, but by now I was comfortable enough navigating the TypeScript codebase that it didn&#39;t prove too difficult.</p>
<p>The most confusing part here was that the tests all started failing on TypeScript&#39;s CI. I couldn&#39;t reproduce the failures on my laptop. This was quite frustrating until I figured out what was going on: the TypeScript CI does a <code>git merge main</code> before running your tests. There are differing opinions on whether this is a good idea, and I usually don&#39;t set up my repos to do it. But once I realized what was going on, the fix was easy: I just needed to merge the upstream changes myself.</p>
<p>There was one funny bug that came up here. My generated <code>.d.ts</code> files initially contained code that looked like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syntaxRequiresTrailingSemicolonOrASI</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  kind: SyntaxKind</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">kind</span> <span class="hljs-title">is</span> <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">PropertyDeclaration</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">VariableStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ExpressionStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">DoStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ContinueStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">BreakStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ReturnStatement</span> |</span><br><span class="hljs-function">   ... 7 <span class="hljs-title">more</span> ... |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ExportDeclaration</span></span>;<br></code></pre></td></tr></table></figure>

<p>That &quot;... 7 more ...&quot; isn&#39;t valid TypeScript syntax! It turns out I needed to set an emit flag to prevent truncation.</p>
<p>Wes requested that I do some minor refactoring and then approved the PR.</p>
<p>After a last round of tests, Ryan merged my PR. This was happening!</p>
<h2 id="Aftermath"><a href="#Aftermath" class="headerlink" title="Aftermath"></a>Aftermath</h2><!-- 2024-03-15 -->

<p>Once my PR went in, there was <a target="_blank" rel="noopener" href="https://twitter.com/GabrielVergnaud/status/1769392854156095565" onclick="return trackOutboundLink('aftermath', 'https://twitter.com/GabrielVergnaud/status/1769392854156095565', event);">even more excitement</a> on TypeScript Twitter. <a target="_blank" rel="noopener" href="https://twitter.com/AndaristRake/status/1768722035369181466" onclick="return trackOutboundLink('aftermath', 'https://twitter.com/AndaristRake/status/1768722035369181466', event);">Andarist</a> and <a target="_blank" rel="noopener" href="https://twitter.com/mattpocockuk/status/1768809254733951424" onclick="return trackOutboundLink('aftermath', 'https://twitter.com/mattpocockuk/status/1768809254733951424', event);">Matt Pocock</a> both tweeted about it, and Matt even wrote a <a target="_blank" rel="noopener" href="https://www.totaltypescript.com/type-predicate-inference" onclick="return trackOutboundLink('aftermath', 'https://www.totaltypescript.com/type-predicate-inference', event);">blog post</a>. Jake Bailey put up a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57830" onclick="return trackOutboundLink('aftermath', 'https://github.com/microsoft/TypeScript/pull/57830', event);">very satisfying PR</a> that removed newly-superfluous type assertions from the TypeScript code base. There was one <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/57947" onclick="return trackOutboundLink('aftermath', 'https://github.com/microsoft/TypeScript/issues/57947', event);">bug filed</a> about inferring type predicates for tagged unions, which Andarist <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/57952" onclick="return trackOutboundLink('aftermath', 'https://github.com/microsoft/TypeScript/pull/57952', event);">quickly fixed</a>.</p>
<p>I explored a two followup changes:</p>
<ol>
<li>Lots of the Twitter reaction <a target="_blank" rel="noopener" href="https://twitter.com/MiTypeScript/status/1768741478199697806" onclick="return trackOutboundLink('aftermath', 'https://twitter.com/MiTypeScript/status/1768741478199697806', event);">asked</a> whether <code>filter(Boolean)</code> would work now. The answer is no, but I explored how we could make this work (for object types) and found it <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/50387#issuecomment-2037968462" onclick="return trackOutboundLink('aftermath', 'https://github.com/microsoft/TypeScript/issues/50387#issuecomment-2037968462', event);">harder than expected</a>.</li>
<li>I also looked into supporting type predicate inference for <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/58154" onclick="return trackOutboundLink('aftermath', 'https://github.com/microsoft/TypeScript/pull/58154', event);">functions with multiple <code>return</code> statements</a>. This isn&#39;t a major change to the existing logic and it has minimal performance impact. But there aren&#39;t many functions like this in the wild, so it may not be worth the effort.</li>
</ol>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Stepping back, creating this PR was a great experience that worked out far better than I had any right to expect. My goal was to get a better sense for how TypeScript worked internally, and I certainly did that! But fixing a seven year-old bug and seeing the wildly positive response was even better.</p>
<p>I filed this issue in 2017 when TypeScript 2.3 was the latest and greatest. I&#39;d initially been drawn to work on it because I thought that an unrelated change in TypeScript 4.4 (2021) might have made it more tractable. That change turned out to be irrelevant. All of the machinery I wound up using to infer type predicates was already in place way back in 2017. It&#39;s just that no one had thought to put the pieces together in quite this way.</p>
<p>This is a great example of how bringing fresh eyes into an ecosystem can be beneficial. I don&#39;t think there are any other places where the type checker synthesizes a flow node. But I didn&#39;t know that, so I just did it. And it worked great!</p>
<p>TypeScript 5.5 should come out for beta testing in the next few weeks, and a final version should be out in the next few months. It&#39;s exciting to think that my experimental code from January will soon be running on every TypeScript function in the world!</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="üí¨ blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('post learn more hover', 'https://amzn.to/3HIrQN6', event);">Buy the Book</a>
        <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" class="btn btn-info btn-lg hidden-xs" onclick="return trackOutboundLink('post learn more hover', 'https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1', event);">Buy eBook</a>
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript‚Äôs many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more ¬ª</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('conclusions', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
