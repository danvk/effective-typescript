<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2021-05-06T23:52:32.612Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Seven Sources of Unsoundness in TypeScript</title>
    <link href="https://effectivetypescript.com/2021/05/06/unsoundness/"/>
    <id>https://effectivetypescript.com/2021/05/06/unsoundness/</id>
    <published>2021-05-07T00:00:00.000Z</published>
    <updated>2021-05-06T23:52:32.612Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/square-peg-round-hole.png" title="A square peg in a round hole" width="212" height="197" style="float: right; padding-left: 10px;">Hang out on the internet much and you&#39;ll hear gripes about how TypeScript isn&#39;t &quot;sound,&quot; and that this makes it a poor choice of language. In this post, I&#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&#39;s never a good idea to listen to people on the internet!</p><p>Roughly speaking, a language is &quot;sound&quot; if the static type of every symbol is guaranteed to be compatible with its runtime value.</p><p>Here&#39;s a simple example of a sound type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Math</span>.random();<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>TypeScript infers a static type of <code>number</code> for <code>x</code>, and this is sound: whatever value <code>Math.random()</code> returns at runtime, it will be a <code>number</code>. This doesn&#39;t mean that <code>x</code> could be any <code>number</code> at runtime: a more precise type would be the half-open interval <code>[0, 1)</code>, but TypeScript has no way to express this. <code>number</code> is good enough. If you remember the <a href="https://wp.stolaf.edu/it/gis-precision-accuracy/">famous statistics dartboard</a>, soundness is more about accuracy than precision.</p><p>Here&#39;s an example of unsoundness in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];  <span class="hljs-comment">// type is number[]</span><br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The static type of <code>x</code> is inferred as <code>number</code>, but at runtime its value is <code>undefined</code>, which is not a <code>number</code>. So this is unsound.</p><p>Many programming languages include proofs of soundness, or at least purport to be sound. Fun fact: in 2016, two researchers <a href="https://dl.acm.org/doi/10.1145/2983990.2984004">discovered that Java had become unsound</a>! As we saw above, TypeScript is emphatically <em>not</em> sound. In fact, <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">soundness is not a design goal</a> of TypeScript at all. Instead, TypeScript favors convenience and the ability to work with existing JavaScript libraries.</p><p>That being said, unsoundness can lead to crashes and other problems at runtime, so it&#39;s a good idea to understand the ways that it can arise.</p><p>Here are the seven sources of unsoundness:</p><ol><li><a href="#any"><code>any</code></a></li><li><a href="#type-assertions">Type Assertions</a></li><li><a href="#object-and-array-lookups">Object and array lookups</a></li><li><a href="#inaccurate-type-definitions">Inaccurate type definitions</a></li><li><a href="#the-thing-with-variance-and-arrays">The thing with variance and arrays</a></li><li><a href="#function-calls-dont-invalidate-refinements">Function calls don&#39;t invalidate refinements</a></li><li><a href="#there-are-five-turtles">There Are Five Turtles</a></li></ol><p>For each of these, I&#39;ll assess how common it is in practice, show what it looks like, and explain how you can avoid it.</p><p>Note that this post assumes you&#39;re using <code>--strict</code>. If you&#39;re not, then there are more ways that TypeScript is unsound.</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h2><p><strong>How often does this occur?</strong> It depends how disciplined you are about not using <code>any</code>! But built-ins like <code>JSON.parse</code> that return <code>any</code> make it hard to avoid entirely.</p><p>If you &quot;put an <code>any</code> on it&quot;, then anything goes. The static types may or may not have anything to do with real runtime types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// static type of x is number, runtime type is string</span><br>&#125;<br><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;forty two&#x27;</span>;<br>alertNumber(num);<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The solution here is simple: limit your use of <code>any</code> or, better, don&#39;t use it at all! Chapter 5 of <a href="https://amzn.to/38s1oCK">Effective TypeScript</a> is all about how to mitigate and avoid the static type disaster that is <code>any</code>. The highlights are to limit the scope of <code>any</code> and to use <code>unknown</code> as a safer alternative when possible.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><strong>How often does this occur?</strong> Often (though not as often as object and array lookups).</p><p>The slightly less offensive cousin of <code>any</code> is the &quot;type assertion&quot; (<em>not</em> the &quot;cast&quot;, see my <a href="https://effectivetypescript.com/2021/02/03/pet-peeves/">rant on this terminology</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br>alertNumber(x1);<br><span class="hljs-comment">//          ~~ ... Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br>alertNumber(x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>);  <span class="hljs-comment">// type checks, but might blow up at runtime</span><br></code></pre></td></tr></table></figure><p>The <code>as number</code> in the last line is the type assertion, and it makes the error go away. It&#39;s the <a href="https://xkcd.com/149/">sudo make me a sandwich</a> of the type system.</p><p>Type assertions often come up in the context of input validation. You might fetch JSON via an API and give it a type using an assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json() <span class="hljs-keyword">as</span> FunFact;<br></code></pre></td></tr></table></figure><p>Nothing ensures that this API is <em>actually</em> returning a <code>FunFact</code>. You&#39;re simply asserting that it is. If it isn&#39;t, then the static type won&#39;t match reality.</p><p>What can you do about this? You can replace many assertions with conditionals (<code>if</code> statements or ternary operators):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br><span class="hljs-keyword">if</span> (x1 !== <span class="hljs-literal">null</span>) &#123;<br>  alertNumber(x1);  <span class="hljs-comment">// ok, x1&#x27;s type is number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Within the <code>if</code> block, the static type of <code>x1</code> is narrowed based on the condition, so the type assertion isn&#39;t needed.</p><p>For input validation, you can write a <a href="https://basarat.gitbook.io/typescript/type-system/typeguard">type guard function</a> to do some run-time type checking:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunFact</span>(<span class="hljs-params">data: unknown</span>): <span class="hljs-title">data</span> <span class="hljs-title">is</span> <span class="hljs-title">FunFact</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;fact&#x27;</span> <span class="hljs-keyword">in</span> data <span class="hljs-comment">/* &amp;&amp; ... */</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json();<br><span class="hljs-keyword">if</span> (!isFunFact(fact)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Either it wasn&#x27;t a fact or it wasn&#x27;t fun`</span>);<br>&#125;<br><span class="hljs-comment">// type of fact is now FunFact!</span><br></code></pre></td></tr></table></figure><p>Of course, you&#39;re still asserting that your type guard really guards the type. If you want to be more systematic about it, there are many possible approaches. One is to use a tool like <a href="https://github.com/colinhacks/zod">Zod</a> that&#39;s designed to solve this problem. Another is to generate JSON Schema from your TypeScript types (e.g. using <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a>) and validate the shape of your data at runtime using that. <a href="https://github.com/danvk/crosswalk">crosswalk</a> takes this approach.</p><!--The bit about about type guards being unchecked is called out here https://twitter.com/sebmck/status/1142601008251469824--><h2 id="Object-and-array-lookups"><a href="#Object-and-array-lookups" class="headerlink" title="Object and array lookups"></a>Object and array lookups</h2><p><strong>How often does this occur?</strong> All the time.</p><p>TypeScript doesn&#39;t do any sort of bounds checking on array lookups, and this can lead directly to unsoundness and runtime errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// static type is number but runtime type is undefined.</span><br>alert(x.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The same can happen when you reference a property on an object with an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string but runtime type is undefined.</span><br></code></pre></td></tr></table></figure><p>Why does TypeScript allow this sort of code? Because it&#39;s extremely common and because it&#39;s quite difficult to prove whether any particular index/array access is valid. If you&#39;d like TypeScript to try, there&#39;s a <a href="https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess"><code>noUncheckedIndexedAccess</code></a> option. If you turn it on, it finds the error in the first example but also flags perfectly valid code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><span class="hljs-keyword">const</span> x2 = xs[<span class="hljs-number">2</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x2.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p><code>noUncheckedIndexedAccess</code> is at least smart enough to understand some common array constructs:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>  <span class="hljs-built_in">console</span>.log(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-keyword">const</span> squares = xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);  <span class="hljs-comment">// also ok</span><br></code></pre></td></tr></table></figure><p>If you&#39;re concerned about unsafe access to specific arrays or objects, you can explicitly add <code>| undefined</code> to their value types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs: (<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><br><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string | undefined</span><br>alert(agent.toUpperCase());<br><span class="hljs-comment">//    ~~~~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p>The advantage of this approach over <code>noUncheckedIndexedAccess</code> is that it lets you limit the scope (and presumably false positives) of that flag. The disadvantage is that it lacks the smarts of the flag: the <code>for-of</code> loop will give you errors with this approach. It also introduces the possibility that you <code>push</code> an <code>undefined</code> onto the array.</p><p>Finally, it&#39;s often possible to rework your code to avoid the need for these sorts of lookups. Say your API looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuItem &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  displayText: <span class="hljs-built_in">string</span>;<br>  icon?: <span class="hljs-built_in">string</span>;<br>  hoverText?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This API is very likely to lead to lookups in the <code>onSelectItem</code> callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125; = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>Menu(&#123;<br>  menuItems,<br>  <span class="hljs-function"><span class="hljs-title">onSelectItem</span>(<span class="hljs-params">id</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> menuItem = menuItems[id]; <span class="hljs-comment">// oh no! object lookup!</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Instead, you might pass the <code>MenuItem</code> itself to the callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">menuItem: MenuItem</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is safer from a static types perspective.</p><h2 id="Inaccurate-type-definitions"><a href="#Inaccurate-type-definitions" class="headerlink" title="Inaccurate type definitions"></a>Inaccurate type definitions</h2><p><strong>How often does this occur?</strong> Surprisingly rarely, but it&#39;s annoying and surprising when it does!</p><p>The type declarations for a JavaScript library are like a giant type assertion: they claim to statically model the runtime behavior of the library but there&#39;s nothing that guarantees this. (Unless, that is, the library is written in TypeScript, the declarations are generated by <code>tsc</code> and the library doesn&#39;t break any of the rules in this post!)</p><p>It&#39;s hard to show a specific example here since these kinds of bugs tend to get fixed once you highlight them, particularly for declarations on DefinitelyTyped. But here&#39;s <a href="https://github.com/alex3165/react-mapbox-gl/issues/776">one example</a> in react-mapbox-gl that&#39;s been around for years. (Not to pick on react-mapbox-gl, we love you alex3165!)</p><p>How do you work around this? The best way is to fix the bug! For types on DefinitelyTyped (<code>@types</code>), the turnaround time on this is usually a week or less. If this isn&#39;t an option, you can work around some issues via <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">augmentation</a> or, in the worst case, a type assertion.</p><p>It&#39;s also worth noting that some functions have types that are just very hard to model statically. Take a look at the parameter list for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter"><code>String.prototype.replace</code></a> for a head-scratching example. There are also some functions that are <a href="https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598">incorrectly typed for historical reasons</a>, e.g. <code>Object.assign</code>.</p><h2 id="The-thing-with-variance-and-arrays"><a href="#The-thing-with-variance-and-arrays" class="headerlink" title="The thing with variance and arrays"></a>The thing with variance and arrays</h2><p><strong>How often does this occur?</strong> I&#39;ve never personally run into this, but I also tend not to use very deep or complex type hierarchies.</p><p>This is a famous one. TypeScript TL <a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> <a href="https://github.com/microsoft/TypeScript/issues/9825#issuecomment-234115900">offers</a> this example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat()];<br>addDogOrCat(z); <span class="hljs-comment">// Sometimes puts a Dog in a Cat array, sad!</span><br></code></pre></td></tr></table></figure><p>What can <em>you</em> do about this? The best solution is to avoid mutating array parameters. You can enforce this via <code>readonly</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: <span class="hljs-keyword">readonly</span> Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>  <span class="hljs-comment">//  ~~~~ Property &#x27;push&#x27; does not exist on type &#x27;readonly Animal[]&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will prevent this type of unsoundness. Instead, you might write the example this way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogOrCat</span>(<span class="hljs-params"></span>): <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat();<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat(), dogOrCat()];<br><span class="hljs-comment">//                           ~~~~~~~~~~ error, yay!</span><br><span class="hljs-comment">// Type &#x27;Animal&#x27; is missing the following properties from type &#x27;Cat&#x27;: ...</span><br></code></pre></td></tr></table></figure><p><em>(See <a href="https://www.typescriptlang.org/play?ssl=5&ssc=1&pln=6&pc=1#code/MYGwhgzhAECCB2BLAtmE0DeBfAsAKH1EhgFkxlV0BTADwBcr4ATGBFNTfaaRCMitAF46AJwCuVANz5cBPESjQAwmDrRaDZqXKVOebrxV1h4qVx4QAIgHsA5oIBmaCGbyzC4RTdvr6jFtD8uhjmvN4mEtL6FkaOzq7ueA5i8MB0iNbw0GBMTN4A8iJGABRgIiIAXHBIlADaALoAlHrcZSIAdAAOYhAAFsVkdL3tImDM1sjFzQB80AAM7QCs0AD80PBUAO7Q3lPQVRvbJY2NUYnJqemZ0LZUdEHOU1UPIA0t0CJ3YiJZDWf4+AA9IDoAAhfAXNIZLK9SAlNpVNh1JrvT50b5ZNrtCATKjFKjQQSzAmIeAQOhjYBUawOZSqU4yQiZcnQGjPHRoN6CG53F4QKZRYDMtQAT0J0FhEBKNAZcmByiZZLUAC8qkYudBaoc6XQpvUojk8nZCiVladoPL5QBlXHpZBUGDdOgwMA7Ow8TE67LlMAigA00AgOQAhPggA">full playground example</a>.)</em></p><p>Why does TypeScript allow this? Presumably because <code>readonly</code> wasn&#39;t always part of the language. In the future you could imagine a &quot;strict&quot; option that would prevent these types of errors. In the initial example, the <code>addDogOrCat</code> call should only be allowed with a subtype of <code>Animal[]</code> if it&#39;s declared as <code>readonly Animal[]</code>. This will have the side effect of pushing libraries to get better about declaring parameters <code>readonly</code>, which would be a very good thing!</p><p>TypeScript used to have more issues around function calls and variance, and you might still see gripes about this online. But these were largely fixed with <code>--strictFunctionTypes</code>, which was <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#strict-function-types">introduced with TypeScript 2.6</a> in November 2017.</p><h2 id="Function-calls-don-39-t-invalidate-refinements"><a href="#Function-calls-don-39-t-invalidate-refinements" class="headerlink" title="Function calls don&#39;t invalidate refinements"></a>Function calls don&#39;t invalidate refinements</h2><p><strong>How often does this come up?</strong> I&#39;ve rarely seen it myself, though this may depend on your style and the libraries that you use.</p><p>Here&#39;s some code that doesn&#39;t look too suspicious at first glance (at least from a type safety perspective):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> FunFact &#123;<br>  fact: <span class="hljs-built_in">string</span>;<br>  author?: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (fact.author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = fact.author.blink();  <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Depending on what <code>processor</code> does, however, the call to <code>blink()</code> might throw at runtime:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">&#x27;Peanuts are not actually nuts&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>);<br><span class="hljs-comment">// Type checks, but throws `Cannot read property &#x27;blink&#x27; of undefined`.</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>if (fact.author)</code> refines the type of <code>fact.author</code> from <code>string | undefined</code> to <code>string</code>. This is sound. However, the call to <code>processor(fact)</code> <em>should</em> invalidate this refinement. The type of <code>fact.author</code> should revert back to <code>string | undefined</code> because TypeScript has no way of knowing what the callback will do to our refined fact.</p><p>Why does TypeScript allow this? Because most functions don&#39;t mutate their parameters, and this sort of pattern is common in JavaScript.</p><p>How can you avoid this? A simple way is to avoid deeply mutating your parameters. You can enforce that callbacks do this by passing them a <code>Readonly</code> version of the object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: Readonly&lt;FunFact&gt;) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">`Peanuts aren&#x27;t actually nuts`</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>  <span class="hljs-comment">//          ~~~~~~~~</span><br>  <span class="hljs-comment">// The operand of a &#x27;delete&#x27; operator cannot be a read-only property.</span><br>);<br></code></pre></td></tr></table></figure><p>(Note that <code>Readonly</code> is shallow; you&#39;ll need to use a tool like <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> to get a <code>DeepReadonly</code>.)</p><p>You can also avoid this issue by refining a value itself, rather than the object that contains it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;author&#125; = fact;<br>  <span class="hljs-keyword">if</span> (author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = author.blink();  <span class="hljs-comment">// safe</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Because <code>author</code> is a primitive type (not an object), it cannot be changed by the callback and the <code>blink()</code> call is safe.</p><!--Here's an alternate example using refinements from string|number and a global (via https://twitter.com/sebmck/status/1146524039227174914):https://www.typescriptlang.org/play?strict=true#code/DYUwLgBAbghsBcEB2BXAtgIxAJwgHwgGcxsBLJAcwgF4IByOgbgChmAzFJAYzFIHskEGIUKkKSAHLos2ABQBKCAG9mEaHBoQATCwC+rDt14CIaGOQXLVEUmwiywATwAOIPndjAa1WnVSYcOkUVNTUwAAtsPgB3ZBBYgFFsKLk6CT5kaRxCIWBgGJAAEyCWNX1rAHoKiAARATpIJBAioSRHGyRC0mwQHn5BcJwQa2FRcSkAuXkWSuqAFXDSHMJwvhRgQog2c2AAGhswOhyYTMnrLgFiIhJEYjJKTU89IA--><h2 id="There-Are-Five-Turtles"><a href="#There-Are-Five-Turtles" class="headerlink" title="There Are Five Turtles"></a>There Are Five Turtles</h2><p><strong>How often does this come up?</strong> More or less never; if you run into it in real-world code, you might get mentioned at tsconf!</p><p>Anders explains this best:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/wpgKd-rwnMw?start=1714" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>I&#39;ve never been able to find the issue he references in the talk. And I&#39;ve heard rumors that there are now seven turtles. If you know more about either of these, please let me know in the comments!</p><hr><p>Those are the seven sources! But maybe there are eight, or nine, or ten. If you have an example of unsoundness that doesn&#39;t fit into any of these categories, please <a href="https://twitter.com/danvdk">let me know</a> and I&#39;ll update the post.</p><p>Further reading:</p><ul><li><a href="https://frenchy64.github.io/2018/04/07/unsoundness-in-untyped-types.html">Are unsound type systems wrong?</a>, a discussion of types of soundness and TypeScript&#39;s deliberate choice to be unsound (see also <a href="https://news.ycombinator.com/item?id=16780068">HN Comments</a>).</li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness">A Note on Soudness</a> from the TypeScript handbook; this page gives background on some of TypeScript&#39;s design decisions.</li><li><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&q=209#example/soundness">TypeScript Playground Soundness example</a>; this is a built-in example on the TypeScript Playground. Note that it does not have <code>strictFunctionTypes</code> enabled.</li></ul><!--https://github.com/microsoft/TypeScript-Handbook/issues/1059No excess property checks in object types with spread-> This is not unsoundness, just misunderstanding excess property checkingIncorrect definition of spread and Object.assign-> This is a spurious error, but that's not unsoundness, is it?-> This just seems like a bug-> Can easily be modified to be unsound.See https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598Maybe this falls under "incorrect library definitions"?Hacker News thread from 2017:https://news.ycombinator.com/item?id=15659657  Counterexamples here seem to revolve around variance, which has not been an issue for a while.Luca Cardelli, 1996 (quoted in _Types and Programming Languages_):> It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.-->]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/square-peg-round-hole.png&quot; title=&quot;A square peg in a round hole&quot; width=&quot;212&quot; height=&quot;197&quot;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The trouble with Jsonify: Unify types instead of modeling small differences</title>
    <link href="https://effectivetypescript.com/2021/04/09/unify-over-model/"/>
    <id>https://effectivetypescript.com/2021/04/09/unify-over-model/</id>
    <published>2021-04-09T13:45:00.000Z</published>
    <updated>2021-04-09T13:39:14.154Z</updated>
    
    <content type="html"><![CDATA[<!-- Alternate title: the trouble with Jsonify --><p>Last year I wrote about <a href="/2020/04/09/jsonify/"><code>Jsonify</code></a>, a generic that models how a type changes as it goes through JSON serialization and deserialization. This is especially relevant for JavaScript <code>Date</code>s, which get converted to strings in this process:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; JSON.parse(JSON.stringify(d))<br>&#39;2021-04-07T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure><p>If you use a type on your server, <code>Jsonify</code> tells you what that type will look like on your client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <a href="/2020/04/09/jsonify/">original post</a> generated some <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/">strong</a> <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/">reactions</a>. Since I posted it, I&#39;ve learned two things:</p><p>First, <strong>I didn&#39;t come up with this.</strong> In fact, Anders presented it at <a href="https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s">his keynote</a> at the original TSConf, in 2018. He, in turn, based it on <a href="https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545">discussion</a> on GitHub. What&#39;s surprising is that <em>I was at that talk</em>! But it must have gone in one ear and out the other. In any case, <code>Jsonify</code> became much more compelling once TypeScript 3.7 introduced <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases">recursive type aliases</a> in Nov. 2019.</p><p>Second, I&#39;ve learned that <strong><code>Jsonify</code> isn&#39;t a good idea</strong>.</p><p>Why not? While it&#39;s neat that you can model a transformation like this in the type system, it wound up being quite annoying when my team put it into practice.</p><p>For example, if you have an API on the server that produces a <code>Student</code>, then your client-side code should work in terms of <code>Jsonify&lt;Student&gt;</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>As you pass the <code>student</code> object around your application, you&#39;ll get long error messages any time you forget the <code>Jsonify</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);<br>  <span class="hljs-comment">//             ~~~~~~~</span><br>  <span class="hljs-comment">// Argument of type &#x27;&#123; id: number; name: string; birthday: string | null; &#125;&#x27; is not assignable to parameter of type &#x27;Student&#x27;.</span><br>  <span class="hljs-comment">//   Types of property &#x27;birthday&#x27; are incompatible.</span><br>  <span class="hljs-comment">//     Type &#x27;string | null&#x27; is not assignable to type &#x27;Date | null&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;string&#x27; is not assignable to type &#x27;Date | null&#x27;. (2345)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Nothing about this error says &quot;you forgot <code>Jsonify</code>.&quot; We just had to learn &quot;any time you see something about <code>Date</code> and <code>string</code>, it means you forgot a <code>Jsonify</code> somewhere.&quot; In more realistic code, there can be many <code>Date</code> objects that are deeply nested, leading to even longer, more confusing errors. These <code>Date</code> fields typically weren&#39;t used by the function producing the error, so we weren&#39;t even gaining safety for our trouble.</p><p>After battling <code>Jsonify</code> for a few months, we decided to get rid of it by eliminating <code>Date</code>s from our API. Most of these were coming from our database. By default, <code>node-postgres</code> <a href="https://node-postgres.com/features/types#date--timestamp--timestamptz">converts Postgres date/timestamp columns</a> to <code>Date</code> objects. This makes a lot of sense as a default. But to keep our server and and client types equal, we decided to just use strings instead.</p><p>To make this work, we had to reconfigure the types returned by node-postgres:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;types&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br>types.setTypeParser(types.builtins.DATE, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMPTZ, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMP, _.identity);<br></code></pre></td></tr></table></figure><p>We use <a href="https://github.com/danvk/pg-to-ts"><code>pg-to-ts</code></a> (a fork of <a href="https://github.com/PSYT/schemats"><code>schemats</code></a>) to generate types from our database schema (which we consider a source of truth). So we had to <a href="https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c">adapt it</a> with a <code>--datesAsStrings</code> flag.</p><p>With these changes in place, our API types were fully unified: they were exactly the same on the server and the client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Used to be Date | null</span><br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Student&gt;;  <span class="hljs-comment">// exactly the same!</span><br></code></pre></td></tr></table></figure><p>So we could drop <code>Jsonify</code>! Now we could write code like this error-free:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);  <span class="hljs-comment">// ok!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The lesson here is that <strong>you should prefer to unify your types rather than model small differences between them.</strong> By unifying your types, you&#39;ll save all the time and effort you would have spent getting the transformations exactly correct and applied in exactly the right places.</p><p>As another example, it&#39;s common to have <code>snake_case</code> column names in your database and convert them to <code>camelCase</code> for JS/TS variable names and types in your API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> StudentTable &#123;<br>  first_name: <span class="hljs-built_in">string</span>;<br>  last_name: <span class="hljs-built_in">string</span>;<br>  birth_date: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  firstName: <span class="hljs-built_in">string</span>;<br>  lastName: <span class="hljs-built_in">string</span>;<br>  birthDate: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>As I discussed in my <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> post, <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types">as of TypeScript 4.1</a> you can model this snake_case â†’ camelCase transformation in the type system. But should you? Following the mantra of &quot;unify rather than model small differences,&quot; clearly you should not! In this case you could either use <code>snake_case</code> names in your API or use a tool like <a href="https://github.com/hoegaarden/pg-camelcase">pg-camelcase</a> to convert the <code>snake_case</code> names to <code>camelCase</code> as you load them from the database (you can do something similar with <a href="http://knexjs.org/#Installation-wrap-identifier">knex</a>). In either case, you&#39;ll be able to forget about the type transformations entirely.</p><p>Of course, any rule comes with caveats.</p><p>First, this isn&#39;t always an option. You may need the two types if the database and the API aren&#39;t under your control. If this is the case, then modeling these sorts of differences systematically in the type system will help you find bugs in your transformation code. It&#39;s better than creating types ad-hoc and hoping they stay in sync.</p><p>Second, don&#39;t unify types that aren&#39;t representing the same thing! Say you have a tagged union, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseSuccess &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span>;<br>  payload: PayloadType;<br>&#125;<br><span class="hljs-keyword">interface</span> ResponseError &#123;<br>  status: <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  error: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Response = ResponseSuccess | ResponseError;<br></code></pre></td></tr></table></figure><p>It would be counterproductive to &quot;unify&quot; these types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don&#x27;t do this!</span><br><span class="hljs-keyword">interface</span> Response &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span> | <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  payload?: PayloadType;<br>  error?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This will make TypeScript less effective at finding bugs in your <code>Response</code>-handling code. The two <code>Response</code> types are fundamentally different, so they should not be unified. This rule is best applied to types that are fundamentally the same but superficially different.</p><p>If you find yourself creating lots of types that are only slightly different from one another, consider unifying them. You&#39;ll be happy you did!</p>]]></content>
    
    <summary type="html">
    
      Last year I wrote about &lt;code&gt;Jsonify&lt;/code&gt;, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with &lt;code&gt;Jsonify&lt;/code&gt; and 2) It&#39;s a bad idea!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Advent of Code 2020, this time in Rust</title>
    <link href="https://effectivetypescript.com/2021/03/24/advent-of-code/"/>
    <id>https://effectivetypescript.com/2021/03/24/advent-of-code/</id>
    <published>2021-03-24T04:00:00.000Z</published>
    <updated>2021-03-24T21:34:22.977Z</updated>
    
    <content type="html"><![CDATA[<p>There&#39;s been <a href="https://fettblog.eu/learning-rust-and-go/">lots of interest</a> in Rust in the JavaScript and TypeScript community over the past few years, both because <a href="https://rustwasm.github.io/book/">it can target WebAssembly</a> and because <a href="https://github.com/denoland/deno">deno</a> is written in Rust.</p><p>Last year I decided to learn Rust by doing the <a href="https://adventofcode.com/">Advent of Code</a> in it: two puzzles every day of December leading up to Christmas. I had a great time and learned a lot about Rust, and I&#39;d highly recommend this as a way to learn a language.</p><p>Since this is a bit off-topic for the <em>Effective TypeScript</em> blog, I posted my writeup on Medium. If you&#39;re interested in Rust, check it out: <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">Advent of Code 2020 (this time in Rust)</a>.</p><p>TL;DR: Rust is an interesting language that works great for a specific niche, but it&#39;s a bit annoying to work with and I wouldn&#39;t choose to use it unless I was working in its niche. Also, this year&#39;s Advent of Code was too easy!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;There&amp;#39;s been &lt;a href=&quot;https://fettblog.eu/learning-rust-and-go/&quot;&gt;lots of interest&lt;/a&gt; in Rust in the JavaScript and TypeScript commun
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Four words to avoid in TypeScript writing</title>
    <link href="https://effectivetypescript.com/2021/02/03/pet-peeves/"/>
    <id>https://effectivetypescript.com/2021/02/03/pet-peeves/</id>
    <published>2021-02-03T18:40:00.000Z</published>
    <updated>2021-02-03T18:52:46.721Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;ve <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);">written</a> <a href="https://effectivetypescript.com/archives/">many words</a> about TypeScript and I&#39;m sure I&#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!</p><a id="more"></a><ol><li><p><strong>&quot;Typescript&quot;</strong></p><p>It&#39;s not Typescript. It&#39;s Type<strong>S</strong>cript. Capital T, capital S. Fun fact: it&#39;s also JavaScript, capital J, capital S. I thought about ending my post here, this one bugs me so much! If you want to be taken seriously, you need to spell the name of the language correctly. The most egregious example of &quot;Typescript&quot; I know of this is the title of the <a href="https://www.reddit.com/r/typescript" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/typescript', event);">r/typescript</a> subreddit. (I&#39;ve requested that this be fixed several times, but to no avail.)</p></li><li><p><strong>&quot;strongly-typed&quot;</strong></p><p>This one is hyphenated, sorry. I don&#39;t like it because no one can agree on what &quot;strongly-typed&quot; means. The TypeScript types that look &quot;strong&quot; to you coming from a Java background might look weak to a Haskell developer. Or to someone who&#39;s been using TypeScript a bit longer. And can types that go away at runtime really be considered strong?</p><p>When you write &quot;strongly typed,&quot; perhaps you mean to write &quot;statically typed&quot; (which TypeScript is) or &quot;sound&quot; (which it isn&#39;t)? Adding to the confusion, a <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection', event);">weak type</a> is something very specific in TypeScript, and it&#39;s probably not the opposite of the &quot;strong types&quot; that you have in mind.</p></li><li><p><strong>&quot;advanced&quot;</strong></p><p>Expertise in programming is less about using &quot;advanced&quot; features and more about learning how to effectively use the basic building blocks of your language. To me, using the word &quot;advanced&quot; when discussing features like conditional types implies that that the more you use these features, the more &quot;advanced&quot; you are as a TS programmer. I prefer the word &quot;fancy&quot; (as in &quot;fancy types&quot;) since that has more accurate connotations about how often you really need to use these features. After all, the first rule of generics is to <a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">avoid them if you can</a>.</p></li><li><p><strong>&quot;cast&quot;</strong></p><p>The correct term for the expression <code>x as number</code> is &quot;type assertion&quot;. I don&#39;t like the word &quot;cast&quot; because in most languages (C, C++, Java, Rust, â€¦), a cast can have an effect at runtime. In C, for example, <code>(int)f</code> will  convert a <code>float</code> into an <code>int</code> by rounding down. But because <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://neugierig.org/software/blog/2016/04/typescript-types.html', event);">TypeScript types are erased at runtime</a>, the <code>as number</code> can&#39;t possibly have an effect. If you look at the generated JS in the <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOB5eA5ArgWxgXhgWQEMoALAOngLABMQMAKAShgH4YByAFgCY2YAuGNwDcAWABQoSLDCYccKElSyCEGDIwAjAKbwhMGAHoDMADwBaMzAAiILRDBtYBYFDQEANu4CeMAETAVKF8YLxA0eHl4AEswAHMYKBAYAjVMbXgAQnEgA" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOB5eA5ArgWxgXhgWQEMoALAOngLABMQMAKAShgH4YByAFgCY2YAuGNwDcAWABQoSLDCYccKElSyCEGDIwAjAKbwhMGAHoDMADwBaMzAAiILRDBtYBYFDQEANu4CeMAETAVKF8YLxA0eHl4AEswAHMYKBAYAjVMbXgAQnEgA', event);">TypeScript playground</a>, you can see this plainly. It&#39;s called a &quot;type assertion&quot; because you&#39;re asserting that the value <em>already</em> has the type you say it does. You&#39;re not &quot;casting&quot; it into that type. Item 9 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>, <em>Prefer Type Declarations to Type Assertions</em>, has much more to say about exactly when it&#39;s appropriate to use type assertions.</p></li></ol><p>I always try to maintain a positive tone in public forums, and I certainly don&#39;t want this post to discourage anyone from writing about <del>Typescript</del> TypeScript. If you&#39;ve learned something about the language and want to share it online, that&#39;s great! I hope you do. But please avoid these four terms!</p><!--1. Thinking "types" are only about "type safety"   Actually they drive all the great language service features.   `tsserver` is just as important as `tsc`.   This is what makes people love TS!2. Misc incorrect terminology:   1. "type assertion" vs. "cast" (it cannot have a runtime effect, unlike some `C++` casts.)   2. String literal vs. string literal type3. Prefixing all your interfaces with `I`. If you do this, then you should probably prefix your types with `T` and your classes with `I`. And maybe your numbers with `n` and your strings with `s`?4. Using object wrappers for everything. TypeScript isn't Java. This isn't the kingdom of the nouns! (See ch10 of _Mastering TypeScript_.)5. Putting type annotations on all your variables and function parameters, for example `beforeEach((done: jest.DoneCallback)` in ch10 of _Mastering TypeScript_.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I&amp;#39;ve &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;written&lt;/a&gt; &lt;a href=&quot;https://effectivetypescript.com/archives/&quot;&gt;many words&lt;/a&gt; about TypeScript and I&amp;#39;m sure I&amp;#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 3: Avoid Repeating Type Expressions</title>
    <link href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/"/>
    <id>https://effectivetypescript.com/2021/01/20/gentips-3-aliases/</id>
    <published>2021-01-21T02:40:00.000Z</published>
    <updated>2021-02-03T18:46:32.859Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk', event);">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: Avoid Repeating Type Expressions</li><li>Part 4: ???</li></ul><p>Recently there&#39;s been some <a href="https://twitter.com/kentcdodds/status/1348016701632221184" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://twitter.com/kentcdodds/status/1348016701632221184', event);">chatter</a> online about how you should use <a href="https://fettblog.eu/tidy-typescript-name-your-generics/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://fettblog.eu/tidy-typescript-name-your-generics/', event);">long names for generic types</a> (i.e. longer than just <code>T</code>). I&#39;d generalize all this a bit to say:</p><p><strong>Just because you&#39;re writing generics, don&#39;t forget everything you&#39;ve learned about programming!</strong></p><p>So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.</p><p>This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&#39;re worth learning because they&#39;re usually better than repeating yourself!</p><a id="more"></a><p>As a motivating example, we&#39;ll look at how <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk', event);">crosswalk</a> registers express endpoints (see the <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> for background on crosswalk). Recall that an API definition in crosswalk looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">'/users'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">'/users/:userId'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">the last post</a> we looked at how crosswalk defines safe wrappers to register handlers for an endpoint. Here&#39;s what usage looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>app.get(<br>  <span class="hljs-string">'/users/:userId'</span>,<br>  <span class="hljs-keyword">async</span> (params, request, response) =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>The <code>params</code> object has a type based on the path (<code>/users/:userId</code>) and the response is required to be <code>Promise&lt;User&gt;</code> (based on the <code>API</code> interface). Here&#39;s the implementation we wound up with in the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">last post</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ...;<br><span class="hljs-comment">// See https://twitter.com/danvdk/status/1301707026507198464</span><br><br><span class="hljs-keyword">class</span> TypedRouter&lt;API&gt; &#123;<br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>) &#123;&#125;<br>  <span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-comment">// ... implementation ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The real crosswalk API passes the express <code>request</code> and <code>response</code> objects to the callback as well as the path params. And express requests and responses <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8d49ebd3e913bdbb90294d7672cda5884566d62a/types/express/index.d.ts#L112-L118" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8d49ebd3e913bdbb90294d7672cda5884566d62a/types/express/index.d.ts#L112-L118', event);">take several generic parameters</a>: the path params, the request body type and the response type. For a GET request, we can ignore the request type (there&#39;s no request body) but the other two are relevant. They let you reference <code>request.params</code> and get a type, for example.</p><p>Here&#39;s what this looks like, focusing just on <code>get</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;<br>    &gt;,<br>    response: express.Response&lt;<br>      LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;<br>    &gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Wow that&#39;s a lot of a lot of repetition! The <code>ExtractRouteParams</code> clause appears twice and the response type (the <code>LooseKey2</code> bit) appears three times. It would be even worse for the <code>post</code> handler, where we have a request body to type, too.</p><p>So what can you do about this? There are a few options. They&#39;re better than nothing but, as we&#39;ll see, none are perfect.</p><h3 id="Factor-out-helper-types"><a href="#Factor-out-helper-types" class="headerlink" title="Factor out helper types"></a>Factor out helper types</h3><p>This is the generic equivalent of factoring out a helper function. Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You can factor the repeated bits out into a helper type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Exp&lt;T&gt; = Expression&lt;Involving&lt;T&gt;&gt;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">a: Exp&lt;T&gt;, b: Exp&lt;T&gt;</span>): <span class="hljs-title">Exp</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>(Of course, you should give the helper type a semantically meaningful name if possible.)</p><p>In the case of the crosswalk <code>get</code> method, we might want to factor out a helper to extract the <code>response</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> GetResponse&lt;API, Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt; =<br>  LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;;<br><br><span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      GetResponse&lt;API, Path&gt;<br>    &gt;,<br>    response: express.Response&lt;GetResponse&lt;API, Path&gt;&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;GetResponse&lt;API, Path&gt;&gt;<br>)<br></code></pre></td></tr></table></figure><p>While this does cut down on repetition in the <code>get</code> declaration itself, it forces us to repeat the constraint on <code>Path</code>. As with helper functions, helper types work best when they are semantically meaningful on their own. This makes them easier to think about and increases the likelihood that they&#39;ll be useful in other places.</p><h3 id="Introduce-a-local-type-alias"><a href="#Introduce-a-local-type-alias" class="headerlink" title="Introduce a local type alias"></a>Introduce a local type alias</h3><p>The <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> in this series looked at how you can use classes and currying to introduce new inference sites. Currying has another advantage: it introduces a new scope in which you can create type aliases (you can&#39;t introduce a type alias scoped to a <code>class</code>).</p><p>Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You could write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">type</span> Exp = Expresion&lt;Involving&lt;T&gt;&gt;;<br><br>  <span class="hljs-keyword">return</span> (a: Exp, b: Exp): <span class="hljs-function"><span class="hljs-params">Exp</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>By changing the signature, we&#39;re able to introduce a type alias that depends on the generic parameter, <code>T</code>. This greatly simplifies the resulting generic and doesn&#39;t require us to repeat any bounds on the generic parameters.</p><p>Here&#39;s what <code>get</code> might look like if we curried it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path<br>) =&gt; &#123;<br>  <span class="hljs-keyword">type</span> Params = ExtractRouteParams&lt;Path&gt;;<br>  <span class="hljs-keyword">type</span> ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;;<br><br>  <span class="hljs-keyword">return</span> (<br>    handler: (<br>      params: Params,<br>      request: express.Request&lt;Params, Response&gt;,<br>      response: express.Response&lt;Response&gt;<br>    ): <span class="hljs-built_in">Promise</span>&lt;Response&gt;) =&gt; &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>This is much clearer and much less repetitive. The downside is that it&#39;s more complicated for the caller. One hybrid option is to have a public, non-curried function that delegates to a curried, internal function. See crosswalk&#39;s <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L88" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L88', event);"><code>registerWithBody</code></a> for an example of this in action.</p><h3 id="Add-Generic-Parameters-with-Defaults"><a href="#Add-Generic-Parameters-with-Defaults" class="headerlink" title="Add Generic Parameters with Defaults"></a>Add Generic Parameters with Defaults</h3><p>What if you&#39;re defining a type alias, rather than a generic function? Then you can&#39;t create a local scope since there&#39;s no function body.</p><p>But if you&#39;re repeating the same type expression <em>a lot</em>, there is one mediocre option available: you can define another generic parameter with a default value.</p><p>Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A&gt; = [F&lt;A&gt;, F&lt;A&gt;, F&lt;A&gt;];<br></code></pre></td></tr></table></figure><p>You&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A, B <span class="hljs-keyword">extends</span> F&lt;A&gt; = F&lt;A&gt;&gt; = [B, B, B];<br></code></pre></td></tr></table></figure><p>You have to write <code>F&lt;A&gt;</code> twice, so this trick isn&#39;t helpful unless it appears three or more times in your type alias.</p><p>You can use the same technique with generic functions. For example, here&#39;s how you might write crosswalk&#39;s <code>get</code> with an extra generic parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">get</span>&lt;<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  ResponseType <span class="hljs-keyword">extends</span><br>    LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt; =<br>    LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;,<br>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      ResponseType<br>    &gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Because <code>ResponseType</code> appears three times, defining it this way <em>does</em> reduce repetition. But because <code>ExtractRouteParams&lt;Path&gt;</code> only appears twice, factoring that out in the same way wouldn&#39;t be a win.</p><p>The upside of this technique is that it effectively introduces a local type alias without changing the function signature. The downside is that it&#39;s gross and potentially confusing for your users, who may think they need to pass a value for the additional type parameter. But it works with type aliases and it&#39;s (arguably) better than nothing!</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Just because you&#39;re doing generic programming, don&#39;t forget that you&#39;re programming! Cryptic code is hard to follow, so use meaningful type names. And repetitive code is hard to follow and error-prone, so use the techniques at your disposal to reduce repetition.</p><p>Admittedly none of these options are perfect. I&#39;ve filed a <a href="https://github.com/microsoft/TypeScript/issues/42388" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://github.com/microsoft/TypeScript/issues/42388', event);">feature request</a> to support <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md', event);">Rust-style <code>where</code> syntax</a> for generics, which would let you write <code>get</code> like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">get</span>(<br>  path: Path,<br>  handler: (<br>    params: Params,<br>    request: express.Request&lt;Params, ResponseType&gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) where<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  Params = ExtractRouteParams&lt;Path&gt;,<br>  ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;,<br>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>In other words, you&#39;d get the local type alias without any of the downside. This would make the story around reducing repetition much better (and this blog post happily obsolete!). If you like the idea, please go vote it up!</p><p>The posts in this series have looked at how generic types are computed and inferred. In the next (and hopefully last) post, we&#39;ll look at your options for controlling how they&#39;re displayed.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This is part of an ongoing series on tips I learned for working with TypeScript generics from building the &lt;a href=&quot;https://github.com/danvk/crosswalk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/danvk/crosswalk&#39;, event);&quot;&gt;crosswalk&lt;/a&gt; library. Check out &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;part 1&lt;/a&gt; for more background.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part 0: &lt;a href=&quot;/2020/08/12/generics-golden-rule/&quot;&gt;The Golden Rule of Generics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 1: &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;Use Classes and Currying to create new inference sites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 2: &lt;a href=&quot;https://effectivetypescript.com/2020/12/09/gentips-2-intersect/&quot;&gt;Intersect what you have with whatever TypeScript wants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3: Avoid Repeating Type Expressions&lt;/li&gt;
&lt;li&gt;Part 4: ???&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recently there&amp;#39;s been some &lt;a href=&quot;https://twitter.com/kentcdodds/status/1348016701632221184&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://twitter.com/kentcdodds/status/1348016701632221184&#39;, event);&quot;&gt;chatter&lt;/a&gt; online about how you should use &lt;a href=&quot;https://fettblog.eu/tidy-typescript-name-your-generics/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://fettblog.eu/tidy-typescript-name-your-generics/&#39;, event);&quot;&gt;long names for generic types&lt;/a&gt; (i.e. longer than just &lt;code&gt;T&lt;/code&gt;). I&amp;#39;d generalize all this a bit to say:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Just because you&amp;#39;re writing generics, don&amp;#39;t forget everything you&amp;#39;ve learned about programming!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.&lt;/p&gt;
&lt;p&gt;This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&amp;#39;re worth learning because they&amp;#39;re usually better than repeating yourself!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Top Posts of 2020</title>
    <link href="https://effectivetypescript.com/2021/01/09/top-posts-2020/"/>
    <id>https://effectivetypescript.com/2021/01/09/top-posts-2020/</id>
    <published>2021-01-10T03:30:00.000Z</published>
    <updated>2021-01-10T03:03:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>I <a href="https://effectivetypescript.com/2020/03/06/hello-world/">started</a> the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&#39;d still be working remotely. It&#39;s been quite a year.</p><p>I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:</p><a id="more"></a><ol><li><p><a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a> (August 12th)</p><p>My most popular post is based on <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice', event);">advice in the TypeScript handbook</a>. The alternate title was &quot;Good use of generics or bad use of generics?&quot; This showcasing of good examples and bad examples made this article fun to write and, evidently, fun to read as well. The <a href="https://www.reddit.com/r/programming/comments/i8zqp9/good_use_of_generics_or_bad_use_of_generics/?" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/i8zqp9/good_use_of_generics_or_bad_use_of_generics/?', event);">extensive discussion</a> on r/programming is worth reading. I&#39;m intrigued by the idea of introducing generic parameters as a way of simulating nominal types to help get a function&#39;s implementation correct.</p></li><li><p><a href="https://effectivetypescript.com/2020/04/09/jsonify/">What&#39;s the type of JSON.parse(â€‹JSON.stringify(x))?</a> (April 9th)</p><p>I was quite happy when I &quot;discovered&quot; this trick, only to learn a few months later that I&#39;d subconsciously cribbed it from Anders Hejlsberg&#39;s <a href="https://www.youtube.com/watch?t=2550&v=wpgKd-rwnMw" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.youtube.com/watch?t=2550&v=wpgKd-rwnMw', event);">excellent tsconf 2018 keynote</a>. Whatever the provenance, I&#39;ve soured on tools like <code>Jsonify</code>. Better to unify types instead of modeling small differences. Look for a future post on this topic. Also notable on this was the wildly different response on <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">r/typescript</a> vs. <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/26/iterate-objects/">Item 54: Know How to Iterate Over Objects</a> (May 26th)</p><p>The blog started with several sample items from <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> and this one has done well with Google: &quot;Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the quirks of JavaScript objects and duck typing.&quot;</p></li><li><p><a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> (November 5th)</p><p>Template Literal Types are one of the most exciting additions to TypeScript in years, and we&#39;re all just starting to learn how to use them. This post introduces them to an audience that may not be familiar with TypeScript and explains why I think they&#39;re a particularly <em>TypeScripty</em> solution to a long-standing class of issues. See <a href="https://www.reddit.com/r/programming/comments/jsakpy/typescript_splits_the_atom_a_first_look_at_ts_41s/?" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/jsakpy/typescript_splits_the_atom_a_first_look_at_ts_41s/?', event);">discussion on r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a> (May 12th)</p><p>This article was inspired by a particularly insightful <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">answer</a> from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian Cernicova Dragomir</a> on Stack Overflow. I kept finding more uses for his trick, and I wanted to give it a catchy name. <code>Unionize</code> it is! I&#39;m quite proud of this post and I&#39;m happy to see it crack the top five.</p></li></ol><p>I&#39;m excited to see what 2021 brings to TypeScript! I&#39;ve started a <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">series on generics</a> that I plan to wrap up this month. I&#39;m working on &quot;Pet Peeves in TypeScript Writing&quot; post, and am planning some kind of (now late) &quot;Writing a book, the view from a year out&quot; retrospective. Subscribe or follow for updates!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I &lt;a href=&quot;https://effectivetypescript.com/2020/03/06/hello-world/&quot;&gt;started&lt;/a&gt; the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&amp;#39;d still be working remotely. It&amp;#39;s been quite a year.&lt;/p&gt;
&lt;p&gt;I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 2: Intersect what you have with whatever TypeScript wants</title>
    <link href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/"/>
    <id>https://effectivetypescript.com/2020/12/09/gentips-2-intersect/</id>
    <published>2020-12-09T22:50:00.000Z</published>
    <updated>2021-02-03T18:44:01.168Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk', event);">crosswalk</a> library. Check out <a href="/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: Intersect what you have with whatever TypeScript wants</li><li>Part 3: <a href="/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: ???</li></ul><p>Recall that an API definition in <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk', event);">crosswalk</a> looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">'/users'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">'/users/:userId'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(<code>Endpoint</code> and <code>GetEndpoint</code> are simple type aliases <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6', event);">defined by the library</a>. Their parameters are request and response types.)</p><p>In <a href="/2020/12/04/gentips-1-curry/">last week&#39;s post</a> we defined a <code>getUrl</code> function to safely generate API URLs. In this week&#39;s post, we&#39;ll create type-safe wrappers around <a href="https://expressjs.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://expressjs.com/', event);">express</a> methods to handle these endpoints.</p><p>Here&#39;s how you typically register a <code>get</code> handler in express:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">'/users/:userId'</span>, <span class="hljs-keyword">async</span> (request, response) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;userId&#125; = request.params;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUserById(userId);<br>  response.json(user);<br>  <span class="hljs-comment">// (error handling omitted)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>There are a few issues with this from a TypeScript perspective:</p><ol><li>The type of <code>request.params</code> is <code>any</code>. This means that <code>userId</code> also gets an <code>any</code> type, and this destructuring assignment is completely unsafe.</li><li>The call to <code>response.json()</code> doesn&#39;t check the type of its argument. In fact, nothing checks that we call <code>response.json</code> at all.</li></ol><p>Crosswalk defines a typed wrapper so that the registration looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>typedRouter.get(<br>  <span class="hljs-string">'/users/:userId'</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>Instead of using <code>response.json</code> to send a response, we return <code>Promise&lt;User&gt;</code>, which TypeScript checks against the <code>API</code> interface. Additionally, thanks to <a href="/2020/11/05/template-literal-types/">the magic of <code>ExtractRouteParams</code></a>, <code>params</code> has an inferred type of <code>{userId: string}</code>, so the reference to <code>params.userId</code> is type safe.</p><p>Let&#39;s take a crack at implementing <code>TypedRouter</code>. As <a href="/2020/12/04/gentips-1-curry/">last week&#39;s tip</a> explained, you can either use a class or a <a href="https://wiki.haskell.org/Currying" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://wiki.haskell.org/Currying', event);">curried function</a> to capture the <code>API</code> type parameter. In this case let&#39;s use a class. Then we can use a method (<code>get</code>) that infers a string literal type for the path. Here&#39;s a sketch:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> TypedRouter&lt;API&gt; &#123;<br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>) &#123;&#125;<br>  <span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;unknown&gt;  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> fill in this type!</span><br>  ) &#123;<br>    <span class="hljs-keyword">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This gets us some of the way there: the <code>params</code> parameter to our handler is getting the correct type:</p><p><img src="https://effectivetypescript.com/images/gentips-2-inferred-params.png" alt="path parameters being inferred"></p><p>But what about that return type? Really you&#39;d like to look it up from the <code>API</code> interface given <code>Path</code>.</p><p>Here&#39;s how you&#39;d do that with a type alias:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Response = API[<span class="hljs-string">'/users/:userId'</span>][<span class="hljs-string">'get'</span>][<span class="hljs-string">'response'</span>];<br><span class="hljs-comment">// type is User</span><br></code></pre></td></tr></table></figure><p>If you plug that into our <code>get</code> function, however, you get several errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;API[Path][<span class="hljs-string">'get'</span>][<span class="hljs-string">'response'</span>]&gt;<br>  <span class="hljs-comment">//           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br>  <span class="hljs-comment">// Type 'Path' cannot be used to index type 'API'. (2536)</span><br>  <span class="hljs-comment">// Type '"get"' cannot be used to index type 'API[Path]'. (2536)</span><br>  <span class="hljs-comment">// Type '"response"' cannot be used to index type 'API[Path]["get"]'. (2536)</span><br>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>It&#39;s reasonable for TypeScript to complain here. We haven&#39;t constrained <code>API</code> or <code>Path</code>, so it has no reason to believe that <code>Path</code> is defined on <code>API</code>, let alone that it has a <code>get</code> property which has a <code>response</code> property.</p><p>You can fix the first of these errors by changing:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends string&gt;(<br>+ get&lt;Path extends keyof API&gt;(<br></code></pre></td></tr></table></figure><p>Unfortunately, this introduces a <em>new</em> error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//              ~~~~</span><br><span class="hljs-comment">// Type 'string | number | symbol' is not assignable to type '(string | RegExp)[]'.</span><br></code></pre></td></tr></table></figure><p>(The full error is quite long, but that&#39;s the important part.)</p><p>The problem is that express wants the <code>path</code> parameter to be a <code>string</code> (or a <code>RegExp</code>), but in TypeScript, <code>keyof API</code> is a <code>PropertyKey</code>, which is <a href="https://github.com/microsoft/TypeScript/blob/4dc82fdfba577085a087db6535a4ad2cc755e503/lib/lib.es5.d.ts#L105" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/blob/4dc82fdfba577085a087db6535a4ad2cc755e503/lib/lib.es5.d.ts#L105', event);">defined in the standard library</a> as:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyKey = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol;<br></code></pre></td></tr></table></figure><p>The <code>number</code> is a lie (Item 16 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>, &quot;Prefer Arrays, Tuples, and ArrayLike to number Index Signatures&quot;, explains this in great detail). But <code>path</code> could certainly be a <code>string</code> or <code>symbol</code>. We don&#39;t care about the <code>symbol</code> or <code>number</code> cases, though. We only want the <code>string</code>. To get down to this, you can use an intersection type:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends keyof API&gt;(<br>+ get&lt;Path extends keyof API &amp; string&gt;(<br></code></pre></td></tr></table></figure><p>This eliminates the error with <code>router.get</code>! This intersection trick winds up being an extremely useful way to get rid of TypeScript errors with generics. As it turns out, it&#39;s this week&#39;s tip!</p><p><strong>To get rid of generic type errors, intersect what you have with whatever TypeScript wants.</strong></p><p>Let&#39;s use the same trick to get rid of the remaining two errors:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39;][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;get&quot;&#39; cannot be used to index type &#39;API[Path]&#39;. (2536)<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot;]&#39;. (2536)<br></code></pre></td></tr></table></figure><p>In the first error, TypeScript is saying that it&#39;s seeing <code>&#39;get&#39;</code>, but it wants something that can index <code>API[Path]</code>. In other words, <code>keyof API[Path]</code>. So let&#39;s intersect!</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot; &amp; keyof API[Path]]&#39;. (2536)<br></code></pre></td></tr></table></figure><p>Voila! The error is gone! It&#39;s like magic. You can get rid of the remaining error using the same trick. Watch out, this is going to get a little wordy:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">Promise</span>&lt;API[Path][<span class="hljs-string">'get'</span> &amp; keyof API[Path]][<span class="hljs-string">'response'</span> &amp; keyof API[Path][<span class="hljs-string">"get"</span> &amp; keyof API[Path]]]&gt;<br></code></pre></td></tr></table></figure><p>And the errors are gone! What&#39;s more, we have perfect type inference. The error if you return the wrong type from a handler is exactly what you&#39;d hope for:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">typedRouter.get(<br>  <span class="hljs-string">'/users/:userId'</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//              ~~~~</span><br>  <span class="hljs-comment">// Type 'Promise&lt;null&gt;' is not assignable to type 'Promise&lt;User&gt;'.</span><br>  <span class="hljs-comment">//   Type 'null' is not assignable to type 'User'. (2322)</span><br>);<br></code></pre></td></tr></table></figure><p>But this a mess. The issue is that for every index operator, you also have to introduce a <code>keyof</code>. And with three index operators (<code>Path</code>, <code>&#39;get&#39;</code>, <code>&#39;response&#39;</code>), this has spiraled out of control.</p><p>You can improve things with a short helper:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br></code></pre></td></tr></table></figure><p>This is like <code>T[K]</code> except that it doesn&#39;t require evidence that <code>K</code> is actually a key of <code>T</code>. (If it&#39;s not, it will resolve to <code>never</code>.) The win here is that while <code>T</code> appears twice in the definition of <code>LooseKey</code>, it only appears once when you use it. Here&#39;s how you can use it to simplify the monstruous type expression from earlier:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39; &amp; keyof API[Path][&quot;get&quot; &amp; keyof API[Path]]]&gt;<br>+ Promise&lt;LooseKey&lt;LooseKey&lt;API[Path], &#39;get&#39;&gt;, &#39;response&#39;&gt;&gt;<br></code></pre></td></tr></table></figure><p>As before, this still resolves all our types perfectly. You could even define a <code>LooseKey2</code> to simplify things a bit more:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><br><span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;&gt;<br></code></pre></td></tr></table></figure><p>(You could define a variadic version of this that works on tuples of keys. Give it a try!)</p><p>This technique also comes in handy with <a href="https://github.com/microsoft/TypeScript/pull/40336" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/pull/40336', event);">template literal types</a>. For example, let&#39;s define a generic type that capitalizes the property names of another type. You can do this using the built-in <code>Capitalize</code> generic and a mapped type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K&gt;]: T[K];<br>  <span class="hljs-comment">//                          ~</span><br>  <span class="hljs-comment">// Type 'K' does not satisfy the constraint 'string'.</span><br>  <span class="hljs-comment">//   Type 'keyof T' is not assignable to type 'string'.</span><br>  <span class="hljs-comment">//     Type 'string | number | symbol' is not assignable to type 'string'.</span><br>  <span class="hljs-comment">//       Type 'number' is not assignable to type 'string'. (2344)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This looks familiar! TypeScript wants a <code>string</code>, but we&#39;ve got a <code>PropertyKey</code>. By now you should see how to solve the problem: intersect with whatever TS wants!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K &amp; <span class="hljs-built_in">string</span>&gt;]: T[K];<br>&#125;<br></code></pre></td></tr></table></figure><p>and now this works as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Caps&lt;&#123;name: <span class="hljs-built_in">string</span>, age: <span class="hljs-built_in">number</span>&#125;&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     Name: string;</span><br><span class="hljs-comment">//     Age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>Of course, there&#39;s no free lunch. The downside of this approach is that TypeScript won&#39;t check that the property accesses in your generic are safe. You&#39;ll need to verify them in some other way, <a href="https://www.youtube.com/watch?v=nygcFEwOG8w" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.youtube.com/watch?v=nygcFEwOG8w', event);">probably with a test</a>. But it&#39;s undeniably convenient to have this safety valve available! You can think of it as a rough equivalent of <code>as any</code> for generic types.</p><p>Here&#39;s our final version of <code>TypedAPI</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> TypedRouter&lt;API&gt; &#123;<br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>) &#123;&#125;<br>  <span class="hljs-keyword">get</span>&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">'get'</span>, <span class="hljs-string">'response'</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-keyword">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>As usual, you can find the <a href="https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wKYA8xQ69AMyghDgHJtd9VyBuAKAaunmADsYMpDkBjDHACi7ACaQOMADwAlDAEcArvhgAaOHNSR2qDAD44AbwZw4eJSoBcGhctQxGpvFog6M1zdt2MAvsxyscDAAnmCCAOIYMCLiEJKy+F76cAC8wmISnFLsigA2ueqerrp6jAyS3LwCcACqulBGQaHuFIr19HB+FTz8gnXcqEVujW0D1v1QANoAunSd5ZyVvXAAwnjIXBNyFvaN7MggLfZQHADmc12LPdU1YKIbGBN7BxgA-NbHZ51lAPQ-cABlDCCAAWMBgYFQlj+p2AMBBigARgA6PikH73dgANwA1j8+CQCAB3ZC5HH+SCwODdKqCACCAAUAJJGEwUH6jKC0azGUymU5RayRaIZOJZCaDRLFfSOPmQezWGKZaRrDAPLa2FTqCalNk+WXkDn1VA-Sycpmicg8tn8wVwYVKsXSHWy0xgRQwRWi+K3e6bera+q60x+PwMP6A4FwMEQ6E-XIQPikkEQBUAFgADFmfgAmDN5n4ARkLPwzAFYflxwLkHgBaXJw7ik2shMImimBVuCIRYGBQfgwGQQD0YBnIfsgVBSAAqBjSn3Yp0wvYwYnQ07ZrxsaKgoikC9O6gPejZ1mny64a7gAAMACSGDiEbhwAD6AJg45gPks98fz7HE4+D8v7sE+DSaF+16bo0kw4tS7BwABBxwAAPnAOIYMEECEMIvb9nwg7DlwSGTgk9h6NMHx9l8fimGeF6rqI6B3g+oHPm+H6wN+IFgYh44HD4UGmFuhhwLB8F8ROlFwAe8x0UY+pMKIGB8DWeBwLkUQoGAYDWFQzioMiQ4jlAjDKap46CIQijsARwCuHAAowBMABCwQWgAFOaohUSci4AJTWAyJAgMAuhSC6TBdjYLjDGkjJMpMhqciaZr1Ba5DTElTmZUlzhJJljARtFYW1PUUXNHAAAyECphgADSmEzuo9VznA06TPVcAAGToZh2HtbMDDRTVdWNcEObNXA9WFi1OZtaNujjVIi0NU104tYWehzbqDAWQQ7XNKIxlcFAUgJQYvJwGiOh9ooBHQB5uDAFiDxmER3B6TgBlGR9UD+QpbJOVIY7wgxV4YVhOEJT1MnUYuegeTacBgBsIJBWjqjIyCyBiJpUDWEjfJyvxk6KnhA4naOpNTqDILbcjAMpAYwWkGFGArbVS2YZNCWTHT0zqOQOVC-l0rkHoJ6mADV2mPCYXIiQJnIk5T2Y3AHnmHYahmFKbhM5dyOmDjePcJrmr2MiqMTqg-lG3AyLwquHkQIiABWqQGGLbjIm7qCuC77v+f5rqdHbIYMGGN27F2x1-akcDsBgRKHWEccmedzKI8gOkh8NR1U1AKtRET7Ipaa3nkFjphoMEtkozTnuOVErnuaIas28i3l23n+dhKsOdTrOCdXZ1EmQwN55oAPYBwqSwAAF4c11vXHtJHX1dMkcVf355pCsg9SIY+yHL5ZzqMgArWDkICItwPi6sVlV76yEbEwAci8Z+LkV-zE3SV9E6KFvtwX+8wgA" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wKYA8xQ69AMyghDgHJtd9VyBuAKAaunmADsYMpDkBjDHACi7ACaQOMADwAlDAEcArvhgAaOHNSR2qDAD44AbwZw4eJSoBcGhctQxGpvFog6M1zdt2MAvsxyscDAAnmCCAOIYMCLiEJKy+F76cAC8wmISnFLsigA2ueqerrp6jAyS3LwCcACqulBGQaHuFIr19HB+FTz8gnXcqEVujW0D1v1QANoAunSd5ZyVvXAAwnjIXBNyFvaN7MggLfZQHADmc12LPdU1YKIbGBN7BxgA-NbHZ51lAPQ-cABlDCCAAWMBgYFQlj+p2AMBBigARgA6PikH73dgANwA1j8+CQCAB3ZC5HH+SCwODdKqCACCAAUAJJGEwUH6jKC0azGUymU5RayRaIZOJZCaDRLFfSOPmQezWGKZaRrDAPLa2FTqCalNk+WXkDn1VA-Sycpmicg8tn8wVwYVKsXSHWy0xgRQwRWi+K3e6bera+q60x+PwMP6A4FwMEQ6E-XIQPikkEQBUAFgADFmfgAmDN5n4ARkLPwzAFYflxwLkHgBaXJw7ik2shMImimBVuCIRYGBQfgwGQQD0YBnIfsgVBSAAqBjSn3Yp0wvYwYnQ07ZrxsaKgoikC9O6gPejZ1mny64a7gAAMACSGDiEbhwAD6AJg45gPks98fz7HE4+D8v7sE+DSaF+16bo0kw4tS7BwABBxwAAPnAOIYMEECEMIvb9nwg7DlwSGTgk9h6NMHx9l8fimGeF6rqI6B3g+oHPm+H6wN+IFgYh44HD4UGmFuhhwLB8F8ROlFwAe8x0UY+pMKIGB8DWeBwLkUQoGAYDWFQzioMiQ4jlAjDKap46CIQijsARwCuHAAowBMABCwQWgAFOaohUSci4AJTWAyJAgMAuhSC6TBdjYLjDGkjJMpMhqciaZr1Ba5DTElTmZUlzhJJljARtFYW1PUUXNHAAAyECphgADSmEzuo9VznA06TPVcAAGToZh2HtbMDDRTVdWNcEObNXA9WFi1OZtaNujjVIi0NU104tYWehzbqDAWQQ7XNKIxlcFAUgJQYvJwGiOh9ooBHQB5uDAFiDxmER3B6TgBlGR9UD+QpbJOVIY7wgxV4YVhOEJT1MnUYuegeTacBgBsIJBWjqjIyCyBiJpUDWEjfJyvxk6KnhA4naOpNTqDILbcjAMpAYwWkGFGArbVS2YZNCWTHT0zqOQOVC-l0rkHoJ6mADV2mPCYXIiQJnIk5T2Y3AHnmHYahmFKbhM5dyOmDjePcJrmr2MiqMTqg-lG3AyLwquHkQIiABWqQGGLbjIm7qCuC77v+f5rqdHbIYMGGN27F2x1-akcDsBgRKHWEccmedzKI8gOkh8NR1U1AKtRET7Ipaa3nkFjphoMEtkozTnuOVErnuaIas28i3l23n+dhKsOdTrOCdXZ1EmQwN55oAPYBwqSwAAF4c11vXHtJHX1dMkcVf355pCsg9SIY+yHL5ZzqMgArWDkICItwPi6sVlV76yEbEwAci8Z+LkV-zE3SV9E6KFvtwX+8wgA', event);">full code</a> for this post on the TypeScript playground.</p><p>Next week we&#39;ll add the express Request and Response objects to the callback and look at ways to mitigate the repetition of types that follows.</p>]]></content>
    
    <summary type="html">
    
      When you&#39;re working with generic types and run into a seemingly unavoidable error, there&#39;s a trick that can often make it go away: intersect what you have with whatever TypeScript wants it to be. Your errors will melt away! Read on for examples and caveats.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 1: Use Classes and Currying to create new inference sites</title>
    <link href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/"/>
    <id>https://effectivetypescript.com/2020/12/04/gentips-1-curry/</id>
    <published>2020-12-04T05:00:00.000Z</published>
    <updated>2021-02-03T18:44:09.256Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: Use Classes and Currying to create new inference sites</li><li>Part 2: <a href="/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: ???</li></ul><p>Perhaps the best thing about <a href="http://scottmeyers.blogspot.com/2013/01/effective-effective-books.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://scottmeyers.blogspot.com/2013/01/effective-effective-books.html', event);">Effective-style books</a> is that they present hard-earned lessons learned from years of experience using a language. The author has spent years falling into traps and digging out of them so that you don&#39;t have to! But this also makes <em>Effective</em> books difficult to write. You can&#39;t just read the documentation on a new feature and write an Item about it. You need to use that feature, make mistakes with it, and eventually learn how to use it well. This takes time.</p><p><a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> has relatively little to say about &quot;advanced&quot; topics like conditional types. That&#39;s largely because I didn&#39;t have enough practical experience working with them when I wrote the book. That&#39;s changed this year because of work that eventually made its way into the open source <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/crosswalk', event);">crosswalk</a> library.</p><p>I found writing the types for crosswalk extremely difficult this spring, but I found it much easier when I reworked it for open source this fall. So I must have learned something! This is the first in a series of posts that will explain some of the tips I&#39;ve picked up along the way. I&#39;ll aim to post one each week for the rest of this month.</p><p>Of course, any discussion of generics and &quot;fancy&quot; types should start with Rule Zero: don&#39;t use them unless you need to! My previous post on the <a href="/2020/08/12/generics-golden-rule/">&quot;Golden Rule of Generics&quot;</a> can help you tell whether this is the case.</p><h2 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h2><p>In <a href="https://github.com/danvk/crosswalk" target="_blank" rel="noopener" onclick="return trackOutboundLink('the problem', 'https://github.com/danvk/crosswalk', event);">crosswalk</a>, you define an API using a TypeScript <code>interface</code> that looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">'/users'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">'/users/:userId'</span>: &#123;<br>    <span class="hljs-keyword">get</span>: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(<code>Endpoint</code> and <code>GetEndpoint</code> are simple type aliases <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6" target="_blank" rel="noopener" onclick="return trackOutboundLink('the problem', 'https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6', event);">defined by the library</a>. Their parameters are request and response types.)</p><p>In addition to providing tools to safely implement an API for this schema using <a href="https://expressjs.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('the problem', 'https://expressjs.com/', event);">express</a>, crosswalk also offers a function to construct URLs for API endpoints. This checks a few things: that the endpoints exist, that you specify the proper path parameters, and that they have the correct type (<code>string</code>, not <code>string | null</code>). This is extremely helpful for making safe API calls from the client.</p><p>Here&#39;s how we&#39;d like that function work:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Correct usage:</span><br><span class="hljs-keyword">const</span> url = getUrl&lt;API&gt;(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">// returns '/users/bob'</span><br><br><span class="hljs-comment">// Incorrect usage; these should be errors:</span><br>getUrl&lt;API&gt;(<span class="hljs-string">'/users/:userId/profile'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">// endpoint doesn't exist</span><br>getUrl&lt;API&gt;(<span class="hljs-string">'/users/:userId'</span>, &#123;user: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">// should be userId, not user</span><br></code></pre></td></tr></table></figure><p>The logic to extract types for the path parameters is fascinating but a bit off-topic. If you&#39;re interested, check out my previous post: <a href="/2020/11/05/template-literal-types/">TypeScript Splits the Atom!</a> For now, let&#39;s assume we have a generic type that does this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Route&gt; = <span class="hljs-comment">/* ... */</span>;<br><span class="hljs-keyword">type</span> Params = ExtractRouteParams&lt;<span class="hljs-string">'/users/:userId'</span>&gt;;<br><span class="hljs-comment">// type is &#123;userId: string&#125;</span><br></code></pre></td></tr></table></figure><p>Given that, here&#39;s how you might declare <code>getUrl</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>&lt;</span><br><span class="hljs-function">  <span class="hljs-title">API</span>, <span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">API</span></span><br><span class="hljs-function">&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  path: Path, params: ExtractRouteParams&lt;Path&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>Unfortunately, when you try to use this, you&#39;ll get an unexpected error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API&gt;(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">//     ~~~ Expected 2 type arguments, but got 1. (2558)</span><br></code></pre></td></tr></table></figure><p>The problem is that type inference in TypeScript is <a href="https://github.com/microsoft/TypeScript/issues/10571" target="_blank" rel="noopener" onclick="return trackOutboundLink('the problem', 'https://github.com/microsoft/TypeScript/issues/10571', event);">all or nothing</a>: either you can let TS infer <em>all</em> the type parameters from usage, or you can specify all of them explicitly. There&#39;s no in between. (There was an <a href="https://github.com/microsoft/TypeScript/pull/26349" target="_blank" rel="noopener" onclick="return trackOutboundLink('the problem', 'https://github.com/microsoft/TypeScript/pull/26349', event);">attempt</a> to support this in TypeScript 3.1 but it was abandoned.)</p><p>The <code>API</code> parameter is free: it can&#39;t possibly be inferred. So it would seem the only solution here is to write the <code>Path</code> type explicitly:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API, <span class="hljs-string">'/users/:userId'</span>&gt;(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>This works, but yuck! Surely there&#39;s a better way. We need to somehow separate the place where we write the type parameter (<code>API</code>) from the place where we infer it.</p><h2 id="Solution-1-Classes"><a href="#Solution-1-Classes" class="headerlink" title="Solution 1: Classes"></a>Solution 1: Classes</h2><p>TypeScript has one very familiar tool to introduce a new inference site: classes.</p><p>Here&#39;s how you can use a class to solve this problem:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">class</span> URLMaker&lt;API&gt; &#123;<br>  getUrl&lt;<br>    Path <span class="hljs-keyword">extends</span> keyof API<br>  &gt;(<br>    path: Path,<br>    params: ExtractRouteParams&lt;Path&gt;<br>  ): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>And here&#39;s how you use it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> urlMaker = <span class="hljs-keyword">new</span> URLMaker&lt;API&gt;();<br>urlMaker.getUrl(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><br>urlMaker.getUrl(<span class="hljs-string">'/users/:userId/profile'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">//              ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">//  '"/users/:userId/profile"' is not assignable to '"/users/:userId" | "/users"'</span><br>urlMaker.getUrl(<span class="hljs-string">'/users/:userId'</span>, &#123;user: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">//                                 ~~~~~~~~~~~</span><br><span class="hljs-comment">//  '&#123; user: string; &#125;' is not assignable to '&#123; userId: string; &#125;'.</span><br></code></pre></td></tr></table></figure><p>This produces exactly the errors we were hoping for. Hurray!</p><p>What used to be a function that needed two generic type parameters is now a class with one generic type (that you specify explicitly) and a method with one generic type (that&#39;s inferred). TypeScript is perfectly happy to let you bind the <code>API</code> parameter when you call the class&#39;s constructor (<code>new URLMaker&lt;API&gt;()</code>) and then bind <code>Path</code> when you call the <code>getUrl</code> method.</p><p>Using classes to create a distinct binding site is particularly effective when you have multiple methods that all require the same generic parameter. Check out crosswalk&#39;s <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L71-L100" target="_blank" rel="noopener" onclick="return trackOutboundLink('solution  classes', 'https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L71-L100', event);"><code>typed-router.ts</code></a> for an example of this.</p><h2 id="Solution-2-Currying"><a href="#Solution-2-Currying" class="headerlink" title="Solution 2: Currying"></a>Solution 2: Currying</h2><p>Fun fact: programming languages don&#39;t really need functions that take more than one parameter. Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params">mon: <span class="hljs-built_in">string</span>, day: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Date</span></span>;<br>getDate(<span class="hljs-string">'dec'</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>You could instead write a function that returns a function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params">mon: <span class="hljs-built_in">string</span></span>): (<span class="hljs-params">day: <span class="hljs-built_in">number</span></span>) =&gt; <span class="hljs-title">Date</span></span>;<br>getDate(<span class="hljs-string">'dec'</span>)(<span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>Note the slightly different syntax to call the second version. This practice is known as <a href="https://wiki.haskell.org/Currying" target="_blank" rel="noopener" onclick="return trackOutboundLink('solution  currying', 'https://wiki.haskell.org/Currying', event);">currying</a>, after <a href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank" rel="noopener" onclick="return trackOutboundLink('solution  currying', 'https://en.wikipedia.org/wiki/Haskell_Curry', event);">Haskell Curry</a>, who always disavowed having come up with the technique.</p><p>Currying gives us the flexibility we need to introduce as many inference sites as we like. Each function can infer new generic parameters.</p><p>Here&#39;s how you can rework <code>getUrl</code> using functions that return functions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>&lt;<span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span>):</span><br><span class="hljs-function">  &lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    path: Path,</span></span><br><span class="hljs-function"><span class="hljs-params">    params: ExtractRouteParams&lt;Path&gt;</span></span><br><span class="hljs-function"><span class="hljs-params">  </span>) =&gt; <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>Now <code>getUrl</code> takes <em>no</em> parameters, but it returns a function that takes two. Here&#39;s how you use it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API&gt;()(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);  <span class="hljs-comment">// ok</span><br><br>getUrl&lt;API&gt;()(<span class="hljs-string">'/users/:userId/profile'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">//            ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">//  '"/users/:userId/profile"' is not assignable to '"/users/:userId" | "/users"'</span><br>getUrl&lt;API&gt;()(<span class="hljs-string">'/users/:userId'</span>, &#123;user: <span class="hljs-string">'bob'</span>&#125;);<br><span class="hljs-comment">//                               ~~~~~~~~~~~</span><br><span class="hljs-comment">//  '&#123; user: string; &#125;' is not assignable to '&#123; userId: string; &#125;'.</span><br></code></pre></td></tr></table></figure><p>So this works in the case where we want it to and fails in the others. Perfect!</p><p>For other examples of using currying with generics, check out my posts on building a <a href="/2020/07/27/safe-queryselector/">type-safe query selector</a> and <a href="/2020/06/16/typed-identity-functions/">using typed identity functions to guide inference</a>.</p><p>This isn&#39;t as distinct from the class approach as it might initially appear. If you use a different name and return an object type instead of a function, they look nearly identical:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlMaker</span>&lt;<span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span>): </span>&#123;<br>  getUrl&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path, params: ExtractRouteParams&lt;Path&gt;<br>  ): <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> maker = urlMaker&lt;API&gt;();<br>maker.getUrl(<span class="hljs-string">'/users/:userId'</span>, &#123;userId: <span class="hljs-string">'bob'</span>&#125;);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The only difference between this and the class exmaple is the keyword <code>new</code>.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>If you want to specify some generic parameters explicitly while allowing others to be inferred, classes and currying are your two options.</p><p>So which one should you prefer? Ultimately it&#39;s up to you! Whichever one feels most comfortable and produces the API you find most convenient is the way to go.</p><p>The currying approach does have at least one advantage in the context of TypeScript, however, which we&#39;ll discuss in next week&#39;s tip. Stay tuned!</p><p>As always, here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgUSQBNJkYAeAJWAEcBXYAZxgBo5rHIlHgA+OAN4AoOKLhRaDZgC52kpjADcIsRM4RuwWRy49lAXyFDQkWHBgBPMHgDiwGIRIQyVJrr5wAvAWKkU5JDoAGyC2HQ0eXmUhS2s4AFUeKC9BcystOAByOiTMxTh9ZVi8RLRGcM0UgTgcstlSqABtAF18wpj0uABhCUxUBup6BSq4JEwAWwzmKGQAczaizviwIj7gBpGxyYB+WWm5guiAeiO4AGVgPAALGBgwRmkT2YQYK7oAIwA6bAhxo9WkAA3ADWR2wUAgjEYAHdMEFgcZwNB4GQ0FhcHAAIIABQAkoIVKJMkdalBGJlZMIxNS4LN7LI7A5fM5-A1ym4InxlDSxJAZD4nC4esA1gN5Mw2A0ooTDjLiaTGEdpKTcUQKQSeaI6TAGfZHH4KFLuZqwHQdQKDeRlqt+klJUlpdTDIYhCdzpc4Dc7o8jkEINg4VdITqACwABgjRwATGGY0cAIzxo5hgCsR1Q4zAQTWAFogi80HCc8VFYjTPBigQQDAoDgYJQIGbgNjMLXxoxyAAVfjefZIWZwUCoYiMOCdmXbOQ-KBEch92Zsee8GWyTuD6vAEdwAAGABIBMh0Gg4AB9M4wVswfTSfeH48ttv6I63pBH5IcK-biepRrAxBIOAHwmOAAB84GBYALAgdAqxrOsGybID21cZheGaPYawOQxqVXddhyIUc9wPV9jzPC9YGvF830A1sJn0L9qUnapf3-Gi23QuB5wKFdBHaV1TjOCAgjNBANDgeNZC6bMoSMIhgGwbMJDgBTMChBJKAAGQAWUwCCoHIHFcX4KkxG1eIoCCcgZWpFtXjwzcCPAyDoKxPEZV4AAKazeT6K5ZFsq4WG80QwFo9tZHwata2wetG1QJCOwC5dqQASgwmZ+wMIwfm4eA6AsnS9JSJBgGhdTtN0tADLxTyUuUfKgkKtBPjMiyPPlJJFWVJJVUyNhqhVIhZEyd4IHeTICjqowGqaqAWvscygnaklOqVQajjACF0AQIJgD61JBuG0bxsm5Q3U1HkAD9rpu267vum7+KJAAiFayjWnqiA2raduAZ6JoQUckAgeBVMYBBZjGd5dvMCAslehUPrQVVntAuAEc6-6hBmyq5tapaOve7rkbVfqaiSI6xom-QpvOi76YZ6kHtup6sgGinOMwzKCgBoGQbgMGIahmGYDhzJ2ZJ9K5jaTJPiMJ7BOEmBRIAqNJPyqALDmWT5MUvB0DoJAYpV2kFos6qjI8tKVHIAL7K3CCoJgwzPJlULXn83ygupUK2weWDotixCwsS3zkrgFKvH4edonxi3auWxHiagXr+sOrJjsyGn8jgN0IARIQ45dq3E9W5PVW+6Dfv2gR05Gqns9ZhnmZbh7WcyDGifWzaq92-7ED50GoSFzBobwUX4beskkZTohUbAzuySxouapLwnp-L0nBFJSnxsbunGcPmlW8u9uJagKXuf0XnRn5wXIdHkWxfP1VL-mHm5aAA" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgUSQBNJkYAeAJWAEcBXYAZxgBo5rHIlHgA+OAN4AoOKLhRaDZgC52kpjADcIsRM4RuwWRy49lAXyFDQkWHBgBPMHgDiwGIRIQyVJrr5wAvAWKkU5JDoAGyC2HQ0eXmUhS2s4AFUeKC9BcystOAByOiTMxTh9ZVi8RLRGcM0UgTgcstlSqABtAF18wpj0uABhCUxUBup6BSq4JEwAWwzmKGQAczaizviwIj7gBpGxyYB+WWm5guiAeiO4AGVgPAALGBgwRmkT2YQYK7oAIwA6bAhxo9WkAA3ADWR2wUAgjEYAHdMEFgcZwNB4GQ0FhcHAAIIABQAkoIVKJMkdalBGJlZMIxNS4LN7LI7A5fM5-A1ym4InxlDSxJAZD4nC4esA1gN5Mw2A0ooTDjLiaTGEdpKTcUQKQSeaI6TAGfZHH4KFLuZqwHQdQKDeRlqt+klJUlpdTDIYhCdzpc4Dc7o8jkEINg4VdITqACwABgjRwATGGY0cAIzxo5hgCsR1Q4zAQTWAFogi80HCc8VFYjTPBigQQDAoDgYJQIGbgNjMLXxoxyAAVfjefZIWZwUCoYiMOCdmXbOQ-KBEch92Zsee8GWyTuD6vAEdwAAGABIBMh0Gg4AB9M4wVswfTSfeH48ttv6I63pBH5IcK-biepRrAxBIOAHwmOAAB84GBYALAgdAqxrOsGybID21cZheGaPYawOQxqVXddhyIUc9wPV9jzPC9YGvF830A1sJn0L9qUnapf3-Gi23QuB5wKFdBHaV1TjOCAgjNBANDgeNZC6bMoSMIhgGwbMJDgBTMChBJKAAGQAWUwCCoHIHFcX4KkxG1eIoCCcgZWpFtXjwzcCPAyDoKxPEZV4AAKazeT6K5ZFsq4WG80QwFo9tZHwata2wetG1QJCOwC5dqQASgwmZ+wMIwfm4eA6AsnS9JSJBgGhdTtN0tADLxTyUuUfKgkKtBPjMiyPPlJJFWVJJVUyNhqhVIhZEyd4IHeTICjqowGqaqAWvscygnaklOqVQajjACF0AQIJgD61JBuG0bxsm5Q3U1HkAD9rpu267vum7+KJAAiFayjWnqiA2raduAZ6JoQUckAgeBVMYBBZjGd5dvMCAslehUPrQVVntAuAEc6-6hBmyq5tapaOve7rkbVfqaiSI6xom-QpvOi76YZ6kHtup6sgGinOMwzKCgBoGQbgMGIahmGYDhzJ2ZJ9K5jaTJPiMJ7BOEmBRIAqNJPyqALDmWT5MUvB0DoJAYpV2kFos6qjI8tKVHIAL7K3CCoJgwzPJlULXn83ygupUK2weWDotixCwsS3zkrgFKvH4edonxi3auWxHiagXr+sOrJjsyGn8jgN0IARIQ45dq3E9W5PVW+6Dfv2gR05Gqns9ZhnmZbh7WcyDGifWzaq92-7ED50GoSFzBobwUX4beskkZTohUbAzuySxouapLwnp-L0nBFJSnxsbunGcPmlW8u9uJagKXuf0XnRn5wXIdHkWxfP1VL-mHm5aAA', event);">playground</a> with complete examples from this post.</p>]]></content>
    
    <summary type="html">
    
      This series will present a few tips and tricks for working with TypeScript generics that I&#39;ve picked up over the past year. This post looks at how you can use classes and currying to combine explicit type parameters and type inference.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Splits the Atom!</title>
    <link href="https://effectivetypescript.com/2020/11/05/template-literal-types/"/>
    <id>https://effectivetypescript.com/2020/11/05/template-literal-types/</id>
    <published>2020-11-05T05:00:00.000Z</published>
    <updated>2020-11-12T00:20:23.776Z</updated>
    
    <content type="html"><![CDATA[<img src="https://effectivetypescript.com/images/split-atom.png" width="324" height="298" alt="Splitting a string type" style="max-height: 100%; float: right"><p>TypeScript&#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming <a href="https://github.com/microsoft/TypeScript/issues/40124" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/issues/40124', event);">TypeScript 4.1 release</a> includes a particularly exciting new <a href="https://github.com/microsoft/TypeScript/pull/40336" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/pull/40336', event);">addition</a> to the type system: <em>template literal types</em>.</p><p>Template literal types solve a <a href="https://github.com/microsoft/TypeScript/issues/12754" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/issues/12754', event);">long-standing gap</a> in TypeScript&#39;s type system and, as I&#39;ll argue at the end of the post, they solve it in a particularly <em>TypeScripty</em> way.</p><p>To understand template literal types, let&#39;s start with a seemingly simple question: what can&#39;t you type?</p><a id="more"></a><h2 id="The-limits-of-type-safety-in-TypeScript"><a href="#The-limits-of-type-safety-in-TypeScript" class="headerlink" title="The limits of type safety in TypeScript"></a>The limits of type safety in TypeScript</h2><p>My standard example of a pattern you <em>couldn&#39;t</em> type has always been the <code>camelCase</code> function, which maps something like <code>&quot;foo_bar&quot;</code> â†’ <code>&quot;fooBar&quot;</code>. It&#39;s easy to implement in JavaScript using a regular expression:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> term.replace(<span class="hljs-regexp">/_([a-z])/g</span>, <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">1</span>].toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure><p>This function is trivial to <em>simply</em> type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>So that&#39;s not quite what I&#39;m getting at. Ideally you&#39;d like to be able to use this to convert objects with <code>snake_cased</code> properties (like you&#39;d get from a database) into one with <code>camelCased</code> properties (like you typically use in JS/TS). In other words, what should the return type of this function be to make the following code type check (or not) as you&#39;d expect?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out: <span class="hljs-built_in">any</span> = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] of <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>    out[camelCase(k)] = v;<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;foo_bar: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// camel's value at runtime is &#123;fooBar: 12&#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type of val is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;  <span class="hljs-comment">// should be a type error</span><br></code></pre></td></tr></table></figure><p>Prior to TypeScript 4.1 (now a release candidate) this just wasn&#39;t possible. The reason was that string literal types like <code>&quot;foo_bar&quot;</code> were &quot;atomic&quot; in the sense that you couldn&#39;t observe any structure inside of them. They were indivisible. But clearly there <em>is</em> structure in strings. Just look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Instance_methods" target="_blank" rel="noopener" onclick="return trackOutboundLink('the limits of type safety in typescript', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Instance_methods', event);">all the methods</a> on <code>String.prototype</code>.</p><p>Enter: TypeScript 4.1!</p><h2 id="TypeScript-splits-the-atom"><a href="#TypeScript-splits-the-atom" class="headerlink" title="TypeScript splits the atom"></a>TypeScript splits the atom</h2><p>TypeScript 4.1 introduce a few features that make it possible to precisely type the <code>objectToCamel</code> function:</p><ol><li><em>Template literal types</em> This is the key advance. Template literal types allow you to find structure inside string literal types and create infinite, strict subsets of <code>string</code> (think &quot;strings starting with <code>on</code>&quot;).</li><li><em>Key Remapping in Mapped Types</em> While it was possible to change the keys in an object before using tricks like <a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a>, this new feature makes it much more straightforward.</li></ol><p>Let&#39;s use these two features to implement <code>objectToCamel</code>.</p><p>First, let&#39;s look at template literal types. They look like ES template literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OnString = <span class="hljs-string">`on<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> onClick: OnString = <span class="hljs-string">'onClick'</span>;<br><span class="hljs-keyword">const</span> handleClick: OnString = <span class="hljs-string">'handleClick'</span>;<br>   <span class="hljs-comment">// ~~~~~~~~~~~ Type '"handleClick"' is not assignable to type '`on$&#123;string&#125;`'.</span><br></code></pre></td></tr></table></figure><p>This lets you create a type for &quot;strings starting with <code>on</code>.&quot; Before TypeScript 4.1, you either had <code>string</code> or an enumerated union of string literal types (<code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code>). Now you can define structured subsets of <code>string</code>.</p><p>Here are a few other patterns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdNum = <span class="hljs-string">`id<span class="hljs-subst">$&#123;<span class="hljs-built_in">number</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> id1: IdNum = <span class="hljs-string">'id123'</span>;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> id2: IdNum = <span class="hljs-string">'idABC'</span>;<br>   <span class="hljs-comment">// ~~~ Type 'idABC' is not assignable to IdNum</span><br><br><span class="hljs-keyword">type</span> Digit = <span class="hljs-string">'0'</span> | <span class="hljs-string">'1'</span> | <span class="hljs-string">'2'</span> | <span class="hljs-string">'3'</span> | <span class="hljs-string">'4'</span> |<br>             <span class="hljs-string">'5'</span> | <span class="hljs-string">'6'</span> | <span class="hljs-string">'7'</span> | <span class="hljs-string">'8'</span> | <span class="hljs-string">'9'</span>;<br><span class="hljs-keyword">type</span> ThreeDigitNum = <span class="hljs-string">`<span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p>What makes this really powerful is that you can use the <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript splits the atom', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/', event);"><code>infer</code> keyword</a> in a template literal type to do pattern matching:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel1&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;Tail&gt;&#125;</span>`</span><br>    : S;<br><br><span class="hljs-keyword">type</span> T = ToCamel1&lt;<span class="hljs-string">'foo_bar'</span>&gt;;  <span class="hljs-comment">// type is "fooBar" (!!!)</span><br></code></pre></td></tr></table></figure><p>The conditional matches string literal types of the form <code>&quot;head_tail&quot;</code>. The &quot;<code>_</code>&quot; acts as a delimiter to split the string. Because <a href="https://mariusschulz.com/blog/conditional-types-in-typescript#distributive-conditional-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript splits the atom', 'https://mariusschulz.com/blog/conditional-types-in-typescript#distributive-conditional-types', event);">conditional types distribute over unions</a>, this also works for union types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> TU = ToCamel1&lt;<span class="hljs-string">'first_name'</span> | <span class="hljs-string">'last_name'</span>&gt;;<br><span class="hljs-comment">// type is "firstName" | "lastName"</span><br></code></pre></td></tr></table></figure><p>There&#39;s a big issue, though. What if there&#39;s two <code>_</code>s in the string literal type?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T2 = ToCamel1&lt;<span class="hljs-string">'foo_bar_baz'</span>&gt;;  <span class="hljs-comment">// type is "fooBar_baz"</span><br></code></pre></td></tr></table></figure><p>We can&#39;t stop after the first &quot;<code>_</code>&quot;, we need to keep going. We can do this by making the type recursive:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;ToCamel&lt;Tail&gt;&gt;&#125;</span>`</span><br>    : S;<br><span class="hljs-keyword">type</span> T0 = ToCamel&lt;<span class="hljs-string">'foo'</span>&gt;;  <span class="hljs-comment">// type is "foo"</span><br><span class="hljs-keyword">type</span> T1 = ToCamel&lt;<span class="hljs-string">'foo_bar'</span>&gt;;  <span class="hljs-comment">// type is "fooBar"</span><br><span class="hljs-keyword">type</span> T2 = ToCamel&lt;<span class="hljs-string">'foo_bar_baz'</span>&gt;;  <span class="hljs-comment">// type is "fooBarBaz"</span><br></code></pre></td></tr></table></figure><p>The recursive bit is where we call <code>ToCamel&lt;Tail&gt;</code>.</p><p>Pretty neat! Now let&#39;s put it all together.</p><h2 id="A-typed-objectToCamel"><a href="#A-typed-objectToCamel" class="headerlink" title="A typed objectToCamel"></a>A typed objectToCamel</h2><p>Recall that a <a href="https://medium.com/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8" target="_blank" rel="noopener" onclick="return trackOutboundLink('a typed objecttocamel', 'https://medium.com/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8', event);">mapped type</a> in TypeScript looks and works something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Promisify&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">Promise</span>&lt;T[K]&gt;  <span class="hljs-comment">// &lt;-- the mapping</span><br>&#125;;<br><span class="hljs-keyword">type</span> VectorPromise = Promisify&lt;Vector&gt;;<br><span class="hljs-comment">// type is &#123; x: Promise&lt;number&gt;; y: Promise&lt;number&gt;; &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>keyof T</code> here produces a union of string literal types (<code>&quot;x&quot; | &quot;y&quot;</code>) and the mapped type produces an object type from this given a way to produce the values (the <code>Promise&lt;T[K]&gt;</code>). But the keys are set by the union. You can&#39;t change them.</p><p>With Key Remapping, you can add an <code>as</code> clause to the key in a mapped type to change things around. This works particularly well with template literal types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Evented&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;K &amp; <span class="hljs-built_in">string</span>&#125;</span>Changed`</span>]: <span class="hljs-function">(<span class="hljs-params">val: T[K]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">type</span> StudentEvents = Evented&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   nameChanged: (val: string) =&gt; void;</span><br><span class="hljs-comment">//   ageChanged: (val: number) =&gt; void;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>(The <code>&amp; string</code> is there for technical reasons that I don&#39;t want to get into.)</p><p>Using this, we can plug in our <code>ToCamel</code> generic to put it all together:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ObjectToCamel&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> ToCamel&lt;K&gt;]: T[K]<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">ObjectToCamel</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ... as before ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;foo_bar: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// type is &#123; fooBar: number &#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;<br>                <span class="hljs-comment">// ~~~~~~~ Property 'foo_bar' does not exist on type</span><br>                <span class="hljs-comment">//         '&#123; fooBar: number; &#125;'. Did you mean 'fooBar'?</span><br></code></pre></td></tr></table></figure><p>Here&#39;s a <a href="https://www.typescriptlang.org/play?ts=4.2.0-dev.20201109#code/C4TwDgpgBAKg9gYQIYFsIBsA8BlKEAewEAdgCYDOU5wATgJbEDmAfFALwBQU3UuBRZSgAMAJAG8GAMwg0oACQhJSAXwD64qTNhI66ZUK48A-FFFiFS5eORg6wJOjoAvCJnjI0WGDvTNm+w24ALl4Abg5QSFgABnZYRFQMTABySTg4ZOZQ7gB6HKhI6DpKACI0uBKI8GgYAEY490SsVPTVACMkGkzsqDyC6qhiqDL0gCFOysLYACYGhM8U8vbO5adu3PypoZG4cZpxp0qOSQBXYgBjYDo4YihzpuRyVxg8QhIKKloGFgAKIhoUCEYABKIHzJIwVhiQw0CDAE40W7-FAAOlhYHQSHOEB+OVUPwA2kgALROAC6wJyjAANFAUOxWCgCbUySjgHAAKpgSA0R444HAqBISiNBaQ8LKDhVKIAeTaACsIJdRRDXgIPnAFUrgKw2FBodwCQBpQa3ADWEBAcEksCFIvBWBNADJPvQmMwyUDjWSOMpwsczpdrrdNYrlQ63Gr3pRQ9rmD9Q0DQVA5WHgCqvFDDOcbtQoHATsAQkhiCA4mI-YY0rIfjniHmCWbaQA3Mn5m2p7UokhfCDkBMKgX6wL5wsE+6ePk-M3Att65vhbiS7iw+GI0fACVSut5sDC+7octLDo0EK1aZ+3qbAZDMTHzohYgnFBtGSSnfAO5NOKx8MeDA-Hu5AHsC4R9FslBiFA5R7I+z6vrI765p+zYOHEE4YCiMGdD04E3pQT4vjIHAflAqHoLMeoYegWGtCei48IxTE8H0AB+7EcaxUAAAo0HAPKgFALRwMsXRQKQcB9lAxBwJ+BDFJ+Nz9JAI7McxfRqUJUHYae0nwTI2TKMkKJQAAInQpBQFaJx0ootzCXsyRGBwQA" target="_blank" rel="noopener" onclick="return trackOutboundLink('a typed objecttocamel', 'https://www.typescriptlang.org/play?ts=4.2.0-dev.20201109#code/C4TwDgpgBAKg9gYQIYFsIBsA8BlKEAewEAdgCYDOU5wATgJbEDmAfFALwBQU3UuBRZSgAMAJAG8GAMwg0oACQhJSAXwD64qTNhI66ZUK48A-FFFiFS5eORg6wJOjoAvCJnjI0WGDvTNm+w24ALl4Abg5QSFgABnZYRFQMTABySTg4ZOZQ7gB6HKhI6DpKACI0uBKI8GgYAEY490SsVPTVACMkGkzsqDyC6qhiqDL0gCFOysLYACYGhM8U8vbO5adu3PypoZG4cZpxp0qOSQBXYgBjYDo4YihzpuRyVxg8QhIKKloGFgAKIhoUCEYABKIHzJIwVhiQw0CDAE40W7-FAAOlhYHQSHOEB+OVUPwA2kgALROAC6wJyjAANFAUOxWCgCbUySjgHAAKpgSA0R444HAqBISiNBaQ8LKDhVKIAeTaACsIJdRRDXgIPnAFUrgKw2FBodwCQBpQa3ADWEBAcEksCFIvBWBNADJPvQmMwyUDjWSOMpwsczpdrrdNYrlQ63Gr3pRQ9rmD9Q0DQVA5WHgCqvFDDOcbtQoHATsAQkhiCA4mI-YY0rIfjniHmCWbaQA3Mn5m2p7UokhfCDkBMKgX6wL5wsE+6ePk-M3Att65vhbiS7iw+GI0fACVSut5sDC+7octLDo0EK1aZ+3qbAZDMTHzohYgnFBtGSSnfAO5NOKx8MeDA-Hu5AHsC4R9FslBiFA5R7I+z6vrI765p+zYOHEE4YCiMGdD04E3pQT4vjIHAflAqHoLMeoYegWGtCei48IxTE8H0AB+7EcaxUAAAo0HAPKgFALRwMsXRQKQcB9lAxBwJ+BDFJ+Nz9JAI7McxfRqUJUHYae0nwTI2TKMkKJQAAInQpBQFaJx0ootzCXsyRGBwQA', event);">complete playground</a>.</p><h2 id="What-can-should-you-do-with-template-literal-types"><a href="#What-can-should-you-do-with-template-literal-types" class="headerlink" title="What can should you do with template literal types?"></a>What <del>can</del> should you do with template literal types?</h2><p>After template literal types landed, the TypeScript Twittersphere went crazy. I shared a use case around <a href="https://expressjs.com/en/guide/routing.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://expressjs.com/en/guide/routing.html', event);">express</a>, which quickly became the most popular tweet I&#39;ve ever posted:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Another use of <a href="https://twitter.com/typescript?ref_src=twsrc%5Etfw" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/typescript?ref_src=twsrc%5Etfw', event);">@TypeScript</a> 4.1&#39;s template literal types: extracting the URL parameters from an express route. Pretty amazing you can do this in the type system! <a href="https://t.co/gfZQy70whg" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://t.co/gfZQy70whg', event);">https://t.co/gfZQy70whg</a> <a href="https://t.co/aEyfMwjjqX" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://t.co/aEyfMwjjqX', event);">pic.twitter.com/aEyfMwjjqX</a></p>&mdash; Dan Vanderkam (@danvdk) <a href="https://twitter.com/danvdk/status/1301707026507198464?ref_src=twsrc%5Etfw" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/danvdk/status/1301707026507198464?ref_src=twsrc%5Etfw', event);">September 4, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>A <a href="https://twitter.com/buildsghost/status/1301976526603206657" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/buildsghost/status/1301976526603206657', event);">JSON parser</a> made the rounds and then someone <a href="https://github.com/codemix/ts-sql" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/codemix/ts-sql', event);">implemented a full SQL engine</a> in the type system. Hacker news <a href="https://news.ycombinator.com/item?id=24615185" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://news.ycombinator.com/item?id=24615185', event);">was impressed</a>.</p><p>As with any new tool, it will take some time for the community to figure out the best ways to use it. Here are a few ideas. We&#39;ll see how they pan out!</p><ul><li><p>Dotted access: <strong>easy win</strong></p><p>Lodash allows you to write <a href="https://stackoverflow.com/a/43395675/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://stackoverflow.com/a/43395675/388951', event);">&quot;iteratee&quot; expressions</a> like <code>xs.map(&#39;a.b.c&#39;)</code>, which is roughly the same as <code>xs.map(x =&gt; x.a.b.c)</code>. Template literal types will make it possible for this sort of API to be typed.</p><p>I&#39;ve never been a big fan of this style. I&#39;d prefer to write <code>x =&gt; x.a.b.c</code>. But perhaps some of this is just bias from not being able to type these properly in the past. Using string literals for enums, for example, is frowned upon in Java as unsafe, <a href="https://cocoacasts.com/the-danger-of-string-literals-and-stringly-typed-code" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://cocoacasts.com/the-danger-of-string-literals-and-stringly-typed-code', event);">stringly typed</a>, code. But it turns out to be fine in TypeScript because the type system is rich enough to capture it. So we&#39;ll see!</p></li><li><p>Parsing routes: <strong>huge win!</strong></p><p>See my tweet above. Parsing <code>{userId: string}</code> out of <code>/users/:userId</code> will be a big win for express users.</p><p>Going the other direction is also compelling. In a server I use at work, we issue API calls via something like <code>get(&#39;/users/:userId&#39;, {userId: &#39;id&#39;})</code>. We have types defined for the parameters for each route. But now we can just let TypeScript infer them to ensure that nothing will ever get out of sync.</p><p>Similar considerations apply to routes with <a href="https://reactrouter.com/web/example/url-params" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://reactrouter.com/web/example/url-params', event);">react-router</a>.</p></li><li><p>Better types for <code>querySelector</code> / <code>querySelectorAll</code>: <strong>nice win</strong></p><p>The <a href="https://github.com/microsoft/TypeScript/blob/b5b0437a86661c8d7bc76c5860c07305df17899c/lib/lib.dom.d.ts#L11341-L11349" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/microsoft/TypeScript/blob/b5b0437a86661c8d7bc76c5860c07305df17899c/lib/lib.dom.d.ts#L11341-L11349', event);">DOM typings</a> are clever enough to infer a subtype of <code>Element</code> here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.queryQuerySelector(<span class="hljs-string">'input'</span>);<br><span class="hljs-comment">// Type is HTMLInputElement | null</span><br></code></pre></td></tr></table></figure><p>But once you add anything more complex to the selector, you lose this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.queryQuerySelector(<span class="hljs-string">'input.my-class'</span>);<br><span class="hljs-comment">// Type is Element | null</span><br></code></pre></td></tr></table></figure><p>With template literal types, it will be possible to fix this. I wouldn&#39;t be surprised if it becomes common practice to replace calls to <code>getElementById</code> with equivalent calls to <code>querySelector</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> el1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'foo'</span>);<br><span class="hljs-comment">// type is Element | null</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div#foo'</span>);<br><span class="hljs-comment">// type is HTMLDivElement | null</span><br></code></pre></td></tr></table></figure><p>This will no doubt require me to rewrite Item 55 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> (&quot;Understand the DOM hierarchy&quot;). Oh well!</p></li><li><p>Parsing options in <a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://www.npmjs.com/package/commander', event);">Commander</a> or <a href="https://github.com/docopt/docopt.coffee" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/docopt/docopt.coffee', event);">docopt</a>: <strong>a small win</strong></p><p>With <a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://www.npmjs.com/package/commander', event);">Commander</a>, you define your command line tool&#39;s arguments using something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">program<br>  .option(<span class="hljs-string">'-d, --debug'</span>, <span class="hljs-string">'output extra debugging'</span>)<br>  .option(<span class="hljs-string">'-s, --small'</span>, <span class="hljs-string">'small pizza size'</span>)<br>program.parse(process.argv);<br><span class="hljs-built_in">console</span>.log(program.debug, program.small);<br></code></pre></td></tr></table></figure><p>Setting aside the mutation style, which is hard to model in TypeScript, template literal types should make it possible to extract the parameter names from the calls to <code>.option</code>.</p></li><li><p>Parsing SQL or GraphQL: <strong>I could go either way!</strong></p><p>The <a href="https://github.com/codemix/ts-sql" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/codemix/ts-sql', event);">ts-sql</a> demo <a href="https://news.ycombinator.com/item?id=24615185" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://news.ycombinator.com/item?id=24615185', event);">raised some eyebrows</a>, but it also made a real point about the power of template literal types. Given a TypeScript version of your database schema (which can be generated using <a href="https://github.com/PSYT/schemats" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/PSYT/schemats', event);">schemats</a> or <a href="https://github.com/danvk/schemats" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/danvk/schemats', event);">pg-to-ts</a>), it should be possible to infer result types for a SQL query:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;Schema&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./dbschema'</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudentsByAge</span>(<span class="hljs-params">db: Pool, age: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> db.query&lt;Schema&gt;(<span class="hljs-string">`</span><br><span class="hljs-string">  SELECT first_name, last_name FROM students</span><br><span class="hljs-string">  WHERE age = $1;</span><br><span class="hljs-string">  `</span>, [age]);  <span class="hljs-comment">// checks that type of age is number</span><br>  <span class="hljs-keyword">return</span> result.rows;<br>  <span class="hljs-comment">// type is &#123;first_name: string, last_name: string&#125;[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This seems potentially amazing, but also perhaps brittle. You&#39;d have to work in the subset of SQL that your types understood: presumably you wouldn&#39;t want to implement all of <a href="https://en.wikipedia.org/wiki/PL/pgSQL" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://en.wikipedia.org/wiki/PL/pgSQL', event);">PL/pgSQL</a> in the type system. But I could imagine getting a large class of queries, including joins, to work.</p><p>So I&#39;m on the fence on this one! Similar considerations apply to GraphQL queries, which would be a bit easier to join with a schema in the type system than raw SQL.</p></li></ul><p>Template literal types open up many new doors for TypeScript library authors and should improve the overall experience of using TypeScript for everyone by capturing more JavaScript patterns in the type system.</p><p>I&#39;d like to conclude by pointing out that this is a very <em>TypeScripty</em> solution to this problem. TypeScript is full of &quot;puns&quot; between value and type syntax. Depending on the context, <code>&quot;foo&quot;</code> could either be the literal value <code>&quot;foo&quot;</code> or a type consisting of the single value <code>&quot;foo&quot;</code>. (I explore this in Item 8 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>, &quot;Know How to Tell Whether a Symbol Is in the Type Space or Value Space&quot;). Another famous example is <a href="https://basarat.gitbook.io/typescript/type-system/index-signatures" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://basarat.gitbook.io/typescript/type-system/index-signatures', event);">index types</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;x: <span class="hljs-number">12</span>&#125;;<br><span class="hljs-keyword">const</span> value = obj[<span class="hljs-string">'x'</span>];  <span class="hljs-comment">// JS index operator, value at runtime is 12.</span><br><span class="hljs-keyword">type</span> T = (<span class="hljs-keyword">typeof</span> obj)[<span class="hljs-string">'x'</span>];  <span class="hljs-comment">// TS index operator, type is number.</span><br></code></pre></td></tr></table></figure><p>Template literal types continue this pattern by repurposing a runtime JavaScript syntax (template strings) into something that makes sense in the type system (template literal types). The <code>concat</code> function really hammers this home:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concat</span>&lt;<span class="hljs-title">A</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>&gt;(<span class="hljs-params">a: A, b: B</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span><span class="hljs-subst">$&#123;B&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>On the return line, <code>`${a}${b}`</code> is the runtime JavaScript template literal and <code>`${A}${B}`</code> is the TypeScript type. It&#39;s not an accident that they look identical!</p><p>I never would have thought to do it this way, but kudos to Anders and the TypeScript team for coming up with such an on-brand solution!</p><p><em>Image credit: modified version of <a href="https://commons.wikimedia.org/wiki/File:Nuclear_fission_chain_reaction.svg" target="_blank" rel="noopener" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://commons.wikimedia.org/wiki/File:Nuclear_fission_chain_reaction.svg', event);">File:Nuclear fission chain reaction.svg</a> from Wiki Commons</em></p><!--Good use cases for template literal types:- Parsing express routes (my tweet)  - Also react-router routes- Type-safe lodash accessors ('a.b.c')- Better type inference for querySelector- Parsing options in CommanderOnes I'm less sure of:- Parsing SQL to infer result typesreach deep into domainsThis is a very TypeScript-y solution to the problem.link to the awesome list somewhere-->]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://effectivetypescript.com/images/split-atom.png&quot; width=&quot;324&quot; height=&quot;298&quot; alt=&quot;Splitting a string type&quot; style=&quot;max-height: 100%; float: right&quot;&gt;

&lt;p&gt;TypeScript&amp;#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/40124&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/microsoft/TypeScript/issues/40124&#39;, event);&quot;&gt;TypeScript 4.1 release&lt;/a&gt; includes a particularly exciting new &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/40336&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/microsoft/TypeScript/pull/40336&#39;, event);&quot;&gt;addition&lt;/a&gt; to the type system: &lt;em&gt;template literal types&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Template literal types solve a &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/12754&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/microsoft/TypeScript/issues/12754&#39;, event);&quot;&gt;long-standing gap&lt;/a&gt; in TypeScript&amp;#39;s type system and, as I&amp;#39;ll argue at the end of the post, they solve it in a particularly &lt;em&gt;TypeScripty&lt;/em&gt; way.&lt;/p&gt;
&lt;p&gt;To understand template literal types, let&amp;#39;s start with a seemingly simple question: what can&amp;#39;t you type?&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Finding dead code (and dead types) in TypeScript</title>
    <link href="https://effectivetypescript.com/2020/10/20/tsprune/"/>
    <id>https://effectivetypescript.com/2020/10/20/tsprune/</id>
    <published>2020-10-20T22:20:56.000Z</published>
    <updated>2020-11-11T15:15:19.922Z</updated>
    
    <content type="html"><![CDATA[<p>Software engineering is a battle against complexity. Without any planning or care, it&#39;s easy to build programs where everything interacts with everything else (the &quot;big ball of yarn&quot; model). With a ball of yarn, if you double the number of components, you quadruple the number of interactions:</p><img src="https://effectivetypescript.com/images/quadratic.png" alt="Complexity increases with the number of interactions, i.e. quadratically" width="439" height="262"><p>One of the best ways to fight against this ramp-up of complexity is to simply reduce N, i.e. to write fewer lines of code. Using a higher level programming language or depending on well-tested third-party libraries are common ways to do this. But one of the easiest ways is to find code you don&#39;t need any more and delete it.</p><a id="more"></a><p>Or, to quote <a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Ken_Thompson', event);">Ken Thompson</a>:</p><blockquote><p>One of my most productive days was throwing away 1000 lines of code.</p></blockquote><p>So how do you find dead code (and dead types) in a TypeScript project? There are a few ways to do it, but my current solution involves the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/compiler-options.html', event);"><code>--noUnusedLocals</code></a> compiler option and the <a href="https://github.com/nadeesha/ts-prune" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune', event);">ts-prune</a> tool from <a href="https://nadeeshacabral.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://nadeeshacabral.com/', event);">Nadeesha Cabral</a>.</p><h3 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h3><p>First, <code>--noUnusedLocals</code>. This is typically set this in your <code>tsconfig.json</code> file. It&#39;s on by default so its behavior should be familiar. In addition to detecting unused local variables in function bodies, it also detects unused symbols at the module level:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>      <span class="hljs-comment">// ~~~ 'foo' is declared but its value is never read.</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>(In VS Code, unused symbols typically appear in a lighter color instead of getting the red squiggly underline error treatment. This is because it&#39;s often only a temporary state until you write the code that uses the symbol.)</p><p>In this example nothing calls <code>foo</code> or otherwise references it, so it&#39;s dead code. And while <code>bar</code> is unused in this module, it&#39;s exported, so there&#39;s at least the possibility that another module could import it and call it.</p><p>Since imported symbols are local variables inside their module, <code>noUnusedLocals</code> will also catch unused imports for you.</p><h3 id="ts-prune"><a href="#ts-prune" class="headerlink" title="ts-prune"></a>ts-prune</h3><p>But what about exported symbols? They&#39;re still dead code if they&#39;re unused, but determining whether that&#39;s the case is harder. It requires analysis of your whole program and it&#39;s a little trickier than you might expect at first blush. To see why, let&#39;s first look at an incorrect way to do it.</p><p>What if we just look at all the <code>import</code>s in a program and pair them up with the <code>export</code>s? With this approach, an <code>export</code>ed symbol is unused if it&#39;s never <code>import</code>ed.</p><p>There are several problems with this approach. Here are a few:</p><ol><li>Code can be <code>import</code>ed but still dead. Here are three ways this can happen:<ol><li>A function is only imported by its test.</li><li>Two functions call each other (mutual recursion), but are otherwise unused.</li><li>A function is only used by other dead code.</li></ol></li><li>An <code>export</code>ed symbol can be alive even if it&#39;s never <code>import</code>ed. This happens if it&#39;s used in its own module.</li></ol><p>This is all a little easier to understand in picture form:</p><img src="https://effectivetypescript.com/images/dead-code-depgraph.png" alt="Dependency graph showing dead code" width="678" height="353" style="max-height: 100%"><p><em>Dead code is in gray, live code is bold. Code can be dead despite being referenced. Examples are if it&#39;s referenced from other dead code (<code>recA</code>/<code>recB</code>), or code that is not relevant for &quot;liveness&quot; like a test (<code>deadA</code>).</em></p><p>I&#39;m saying &quot;functions&quot; here, but the same considerations apply to types and interfaces, too.</p><p>The first category of problems (imported but still dead) is reminiscent of a problem in <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)', event);">garbage collection</a>: if you do pure <a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Reference_counting', event);">reference counting</a>, then you have a problem with cycles, where two objects reference each other but are otherwise dead. The solution there is to start with some known &quot;live&quot; objects and follow all the references from them. This is known as <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep', event);">mark and sweep</a>.</p><p>We can do something similar with ts-prune. To get the most value out of it, you create a special <code>tsconfig.json</code> file with a list of entrypoints to your program:</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"files"</span>: [<br>    <span class="hljs-string">"src/entry1.ts"</span>,<br>    <span class="hljs-string">"src/entry2.ts"</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>I usually call this <code>tsconfig.ts-prune.json</code>. What constitutes an entrypoint depends on your program. For a Node program like a server, it&#39;s the file you run (perhaps <code>server.ts</code> or <code>main.ts</code> or <code>app.ts</code>). For a web application, it&#39;s the entrypoint you list in your webpack or equivalent config. For a library, it&#39;s any file you want your users to be able to import from the resulting distribution (typically <code>index.ts</code> / <code>index.js</code>).</p><p>Once you&#39;ve created that file, you run something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ ts-prune -p tsconfig.ts-prune.json | grep -v &#39;used in module&#39;<br>src&#x2F;example.ts:4 - bar<br></code></pre></td></tr></table></figure><p>The <code>-p</code> points <code>ts-prune</code> at your special <code>tsconfig.json</code>. Since you never <code>import</code> tests, they wind up being ignored for purposes of detecting alive vs. dead code. The same goes for un-<code>import</code>ed modules.</p><p>The <code>grep</code> filters out the second category of problems from the above list. I have no problem exporting symbols that are never imported (in fact, I recommend it in Item 47 <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>: Export All Types That Appear in Public APIs).</p><p><em>(Sidebar: why? Two main reasons. First, you often wind up needing to import them later, and exporting them makes it possible for tsserver to offer auto-import. Second, you&#39;re effectively exporting them already if they&#39;re part of a public API. You may as well make it easy.)</em></p><p>The output of ts-prune tells us that the <code>bar</code> symbol is unused despite being exported. This is exactly what we wanted to know!</p><p>I highly recommend setting up ts-prune for your project. You might find some dead code that you&#39;d forgotten about! It also works great with more exotic setups like media imports and generated code. Two examples of this from my own projects:</p><ol><li>My team has a file, <code>icons.ts</code>, that imports all the images in my web app, either from PNGs in my project or from Material-UI, and re-exports them. In this case running ts-prune finds the unused images, which shrinks your bundle! (Tree shaking would help here, too.)</li><li>We use codegen to <a href="https://github.com/danvk/schemats" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/schemats', event);">produce TypeScript types from our Postgres schema</a>. In this case an unused export may correspond to a dead <em>database table</em>, which should definitely be dropped!</li></ol><p>As with most dead code elimination tool, when you delete some dead code that it&#39;s surfaced, you should immediately run <code>tsc</code> and <code>ts-prune</code> again. Running <code>tsc</code> will surface dead references to the dead code (e.g. its tests), which you should delete. In the process, you might have deleted the last reference to something, which will surface even more dead code. Repeat until convergence (or until you have no code left!).</p><p>References:</p><ul><li><a href="https://github.com/nadeesha/ts-prune" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune', event);">ts-prune</a> is a zero config CLI tool by <a href="https://nadeeshacabral.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://nadeeshacabral.com/', event);">Nadeehsa Cabral</a>. I <a href="https://github.com/nadeesha/ts-prune/pull/74" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune/pull/74', event);">added</a> the &quot;used in module&quot; output to make it more useful for finding dead code in addition to unused imports.</li><li><a href="https://github.com/pzavolinsky/ts-unused-exports" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky/ts-unused-exports', event);">ts-unused-exports</a> is a related tool by <a href="https://github.com/pzavolinsky" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky', event);">Patricio Zavolinsky</a>. I <a href="https://github.com/pzavolinsky/ts-unused-exports/issues/2" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky/ts-unused-exports/issues/2', event);">ran into issues</a> with this tool that eventually led me to ts-prune, but you may prefer it if you don&#39;t like ts-prune. It certainly has many options!</li><li>I&#39;m not aware of any tools for finding dead code in <em>JavaScript</em>. But since TypeScript is a superset of JavaScript, ts-prune should, in theory, be able to work on JS projects. I&#39;ve never tried this, but, if you get it to work, I&#39;d love to hear about it.</li></ul><!--It seems that there aren't god tools available in JavaScript:<https://www.google.com/search?q=javascript+find+dead+code>Anecdotes:- When I first ran ts-prune, it incorrectly reported dead code.  It turned out I hadn't ported all of my tests to TS yet!- Unused asset imports let you delete unused images.- If you can eliminate third-party imports, this shrinks your bundle.- Your test utils should only be imported by tests.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Software engineering is a battle against complexity. Without any planning or care, it&amp;#39;s easy to build programs where everything interacts with everything else (the &amp;quot;big ball of yarn&amp;quot; model). With a ball of yarn, if you double the number of components, you quadruple the number of interactions:&lt;/p&gt;
&lt;img src=&quot;https://effectivetypescript.com/images/quadratic.png&quot; alt=&quot;Complexity increases with the number of interactions, i.e. quadratically&quot; width=&quot;439&quot; height=&quot;262&quot;&gt;

&lt;p&gt;One of the best ways to fight against this ramp-up of complexity is to simply reduce N, i.e. to write fewer lines of code. Using a higher level programming language or depending on well-tested third-party libraries are common ways to do this. But one of the easiest ways is to find code you don&amp;#39;t need any more and delete it.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Repeat yourself a little less: Strategies for mitigating prop drilling with React and TypeScript</title>
    <link href="https://effectivetypescript.com/2020/10/01/prop-drilling/"/>
    <id>https://effectivetypescript.com/2020/10/01/prop-drilling/</id>
    <published>2020-10-02T01:30:00.000Z</published>
    <updated>2020-10-02T01:28:03.357Z</updated>
    
    <content type="html"><![CDATA[<p>I have a new post up on the LogRocket blog this week: <a href="https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescript/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescript/', event);">Repeat yourself a little less:Strategies for mitigating prop drilling with React and TypeScript</a>.</p><p>It presents the problem of &quot;prop drilling&quot; in React, where you want to add a prop to a component somewhere deep down in your hierarchy and you have to add it in ten other places to get it there. It then looks at five different solutions, all of which work in TypeScript. Give it a read and let me know what you think!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I have a new post up on the LogRocket blog this week: &lt;a href=&quot;https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Exercises</title>
    <link href="https://effectivetypescript.com/2020/09/10/problem-sets/"/>
    <id>https://effectivetypescript.com/2020/09/10/problem-sets/</id>
    <published>2020-09-10T13:25:00.000Z</published>
    <updated>2020-09-10T13:23:34.549Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;d never describe problem sets as &quot;fun,&quot; but there&#39;s a reason teachers assign them. It&#39;s one thing to nod your head as you read a book (&quot;yes, that makes sense&quot;) but quite another to apply what you&#39;ve learned. Software is very much a &quot;learn by doing&quot; field. You retain knowledge better when you actively use it.</p><p>I would have liked to include exercises in <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> but never quite got around to it. Fortunately, there are several excellent sources of TypeScript exercises and puzzles online. Here are a few:</p><a id="more"></a><h2 id="TypeScript-Exercises"><a href="#TypeScript-Exercises" class="headerlink" title="TypeScript Exercises"></a>TypeScript Exercises</h2><p><img src="/images/typescript-exercises.png" alt="TypeScript Exercises"></p><p>I can&#39;t recommend <a href="https://twitter.com/mdevils" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://twitter.com/mdevils', event);">Marat Dulin</a>&#39;s <a href="https://typescript-exercises.github.io/" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://typescript-exercises.github.io/', event);">TypeScript Exercises</a> enough. The problems all build on one another, starting very simple and getting very complex. They have a story and a theme to them that I found thoroughly enjoyable (&quot;CEO&#39;s friend Nick told us that if we randomly swap user names from time to time in the community, it would be very funny and the project would definitely succeed!&quot;) Marat&#39;s latest update includes a hosted version, so you can complete the exercises without leaving your browser. My solutions and commentary on a previous version are <a href="https://github.com/typescript-exercises/typescript-exercises/pull/11" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://github.com/typescript-exercises/typescript-exercises/pull/11', event);">here</a>.</p><h2 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type Challenges"></a>Type Challenges</h2><p><img src="/images/type-challenges.png" alt="Type Challenges"></p><p>The <a href="https://github.com/type-challenges/type-challenges#challenges" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://github.com/type-challenges/type-challenges#challenges', event);">Type Challenges</a> project was created by <a href="https://antfu.me/" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://antfu.me/', event);">Anthony Fu</a> and others. (It&#39;s also available in Chinese!) These challenges are independent puzzles and can be done in any order. Each challenge takes you to a TypeScript playground with infuriating red squiggles that must be fixed. This project is very community-oriented: you&#39;re encouraged to submit your solutions and suggest other puzzles. I expect that over time it will grow to include many, many more challenges.</p><p>If you&#39;ve read <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> and want to apply what you&#39;ve learned, these are both great resources. Are there others I&#39;ve missed? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I&amp;#39;d never describe problem sets as &amp;quot;fun,&amp;quot; but there&amp;#39;s a reason teachers assign them. It&amp;#39;s one thing to nod your head as you read a book (&amp;quot;yes, that makes sense&amp;quot;) but quite another to apply what you&amp;#39;ve learned. Software is very much a &amp;quot;learn by doing&amp;quot; field. You retain knowledge better when you actively use it.&lt;/p&gt;
&lt;p&gt;I would have liked to include exercises in &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; but never quite got around to it. Fortunately, there are several excellent sources of TypeScript exercises and puzzles online. Here are a few:&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Golden Rule of Generics</title>
    <link href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/"/>
    <id>https://effectivetypescript.com/2020/08/12/generics-golden-rule/</id>
    <published>2020-08-12T19:30:00.000Z</published>
    <updated>2020-08-12T19:43:52.425Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/ruler.png" alt="Golden Ruler" style="float:right" width="300" height="180"><p>The <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://microsoft.github.io/TypeScript-New-Handbook/everything/', event);">New TypeScript Handbook</a> has some real gems in it. Here&#39;s <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions', event);">what it has to say about generics</a>:</p><blockquote><p>Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren&#39;t needed can make inference less successful, frustrating callers of your function.</p></blockquote><p>It goes on to offer a few specific pieces of advice about how to use generics, including one that I&#39;ve started to think of as the <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice', event);">&quot;Golden Rule of Generics&quot;</a>:</p><blockquote><h5 id="Type-Parameters-Should-Appear-Twice"><a href="#Type-Parameters-Should-Appear-Twice" class="headerlink" title="Type Parameters Should Appear Twice"></a>Type Parameters Should Appear Twice</h5><p>Type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it&#39;s not relating anything.</p><p><strong>Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it.</strong></p></blockquote><p>I love this rule because it&#39;s so concrete. It gives you a specific way to tell whether any use of generics is good or bad.</p><a id="more"></a><p>But it&#39;s not always obvious how to apply this rule, and it doesn&#39;t offer much guidance about how rework your code if you&#39;re using generics poorly. So in a nod to the <a href="https://fivethirtyeight.com/features/politics-podcast-good-use-of-polling-or-bad-use-of-polling-in-the-west-wing/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://fivethirtyeight.com/features/politics-podcast-good-use-of-polling-or-bad-use-of-polling-in-the-west-wing/', event);">folks at 538</a>, let&#39;s play the &quot;good use of generics or bad use of generics&quot; game. The examples that follow have been edited to protect the innocent, but they are all based on real code I&#39;ve encountered either in blog posts or in print.</p><p>Let&#39;s start with the identity function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>Good use of generics or bad use? In this example the generic argument, <code>T</code>, appears in two places after its declaration:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>             <span class="hljs-comment">// (dec)     1   2</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><!-- Via TS handbook hb-generics --><p>So this passes the test and is a good use of generics. And rightly so: it relates two types because it says that the input parameter&#39;s type and the return type are the same.</p><p>How about this one?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">third</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt;(<span class="hljs-params">a: A, b: B, c: C</span>): <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>The generic parameter <code>C</code> appears twice, so it&#39;s fine. But <code>A</code> and <code>B</code> only appear once (other than in their declarations), so this function fails the test. In fact, we can rewrite it using only one generic parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">third</span>&lt;<span class="hljs-title">C</span>&gt;(<span class="hljs-params">a: unknown, b: unknown, c: C</span>): <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><!--Source: <https://www.digitalocean.com/community/tutorials/typescript-generics-in-typescript>--><p>Here&#39;s a function that parses <a href="https://en.wikipedia.org/wiki/YAML" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/YAML', event);">YAML</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Is this a good use of generics or a bad use of generics? The type paramter <code>T</code> only appears once, so it must be bad. How to fix it? It depends what your goal is. These so-called &quot;return-only generics&quot; are dangerous because they&#39;re equivalent to <code>any</code>, but don&#39;t use the word <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Weight &#123;<br>  pounds: <span class="hljs-built_in">number</span>;<br>  ounces: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> w: Weight = parseYAML(<span class="hljs-string">''</span>);<br></code></pre></td></tr></table></figure><p>The <code>Weight</code> here could be any type and this code would type check. If that&#39;s what you want, you may as well just be explicit about your <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>But the recommended way to do this is by returning <code>unknown</code> instead:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">unknown</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will force users of the function to perform a type assertion on the result:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> w = parseYAML(<span class="hljs-string">''</span>) <span class="hljs-keyword">as</span> Weight;<br></code></pre></td></tr></table></figure><p>This is actually a good thing since it forces you to be explicit about your unsafe type assertion. There are no illusions of type safety here!</p><p>How about this one?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(obj[key]);<br>&#125;<br></code></pre></td></tr></table></figure><p>Since <code>K</code> only appears once, this is a bad use of generics (<code>T</code> appears both as a parameter type and as a constraint on <code>K</code>). Fix it by moving the <code>keyof T</code> into the parameter type and eliminating <code>K</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printProperty</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: keyof T</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(obj[key]);<br>&#125;<br></code></pre></td></tr></table></figure><p>This function looks superficially similar:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>This one, however, is actually a good use of generics! The trick is to look at the return type of this function. Hovering over it in your editor, you can see its full type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T, key: K</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>]</span><br></code></pre></td></tr></table></figure><p>The return type is inferred as <code>T[K]</code>, so <code>K</code> <em>does</em> appear twice! This is a good use of generics: <code>K</code> is related to <code>T</code>, and the return type is related to both <code>K</code> and <code>T</code>.</p><p>What about a class?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> ClassyArray&lt;T&gt; &#123;<br>  arr: T[];<br>  <span class="hljs-keyword">constructor</span>(<span class="hljs-params">arr: T[]</span>) &#123; <span class="hljs-keyword">this</span>.arr = arr; &#125;<br><br>  <span class="hljs-keyword">get</span>(): T[] &#123; <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.arr; &#125;<br>  add(item: T) &#123; <span class="hljs-keyword">this</span>.arr.push(item); &#125;<br>  remove(item: T) &#123;<br>    <span class="hljs-keyword">this</span>.arr = <span class="hljs-keyword">this</span>.arr.filter(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el !== item)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is fine since <code>T</code> appears many times in the implementation (I count 5). When you instantiate a <code>ClassyArray</code>, you bind the type variable and it relates the types of all the properties and methods on the class.</p><p>This class, on the other hand, fails the test:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Joiner&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt; &#123;<br>  join(els: T[]) &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">''</span> + el).join(<span class="hljs-string">','</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>First of all, <code>T</code> only applies to <code>join</code>, so it can be moved down onto the method, rather than the class:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Joiner &#123;<br>  join&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;(els: T[]) &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">''</span> + el).join(<span class="hljs-string">','</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>By moving the declaration of <code>T</code> closer to its use, we make it possible for TypeScript to infer the type of <code>T</code>. Generally this is what you want!</p><!--It would be nice to provide an example of this, but it requires an examplethat's actually a good use of generics!--><p>But in this case, since <code>T</code> only appears once, you should make it non-generic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">class</span> Joiner &#123;<br>  join(els: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[]) &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">''</span> + el).join(<span class="hljs-string">','</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Finally, why does this need to be a class at all? This noun-ing feels like a <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html', event);">Java-ism</a>. Just make it a standalone function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>(<span class="hljs-params">els: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[]</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">''</span> + el).join(<span class="hljs-string">','</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>How about this function to get the length of any array-like object?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthy &#123;<br>  length: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthy</span>&gt;(<span class="hljs-params">x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>Since <code>T</code> only appears once after its definition, this is a bad use of generics. It could be written as:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: Lengthy</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>or even:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: &#123;length: <span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>Or, since TypeScript has a <a href="https://github.com/microsoft/TypeScript/blob/9ff24b6fc87dd4a376a434d1019d356dfe743c53/lib/lib.es5.d.ts#L1451-L1454" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/blob/9ff24b6fc87dd4a376a434d1019d356dfe743c53/lib/lib.es5.d.ts#L1451-L1454', event);">built-in <code>ArrayLike</code> type</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: ArrayLike</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you&#39;ve made it this far, you should have a good sense for how to apply the golden rule of generics and how to fix the declarations that break it. As you read and write generic functions, think about whether they follow this rule! If you&#39;re having trouble telling or aren&#39;t sure how to fix one, <a href="https://twitter.com/danvdk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://twitter.com/danvdk', event);">tweet at me</a>!</p><p><em>(Credit for this rule <a href="https://twitter.com/danvdk/status/1288201956759146496" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://twitter.com/danvdk/status/1288201956759146496', event);">goes to</a> TypeScript engineering lead <a href="https://twitter.com/SeaRyanC" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://twitter.com/SeaRyanC', event);">Ryan Cavanaugh</a>. If you like it, be sure to thank him! If you <strong>really</strong> like it, consider turning it into an <a href="https://eslint.org/docs/developer-guide/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://eslint.org/docs/developer-guide/', event);">eslint rule</a>. Golden ruler is from <a href="https://freesvg.org/molumen-ruler" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://freesvg.org/molumen-ruler', event);">FreeSvg</a>.)</em></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/ruler.png&quot; alt=&quot;Golden Ruler&quot; style=&quot;float:right&quot; width=&quot;300&quot; height=&quot;180&quot;&gt;

&lt;p&gt;The &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://microsoft.github.io/TypeScript-New-Handbook/everything/&#39;, event);&quot;&gt;New TypeScript Handbook&lt;/a&gt; has some real gems in it. Here&amp;#39;s &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions&#39;, event);&quot;&gt;what it has to say about generics&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren&amp;#39;t needed can make inference less successful, frustrating callers of your function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It goes on to offer a few specific pieces of advice about how to use generics, including one that I&amp;#39;ve started to think of as the &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice&#39;, event);&quot;&gt;&amp;quot;Golden Rule of Generics&amp;quot;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;Type-Parameters-Should-Appear-Twice&quot;&gt;&lt;a href=&quot;#Type-Parameters-Should-Appear-Twice&quot; class=&quot;headerlink&quot; title=&quot;Type Parameters Should Appear Twice&quot;&gt;&lt;/a&gt;Type Parameters Should Appear Twice&lt;/h5&gt;&lt;p&gt;Type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it&amp;#39;s not relating anything.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I love this rule because it&amp;#39;s so concrete. It gives you a specific way to tell whether any use of generics is good or bad.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Writing a safe querySelector: the one-way street from values to types</title>
    <link href="https://effectivetypescript.com/2020/07/27/safe-queryselector/"/>
    <id>https://effectivetypescript.com/2020/07/27/safe-queryselector/</id>
    <published>2020-07-27T13:57:32.000Z</published>
    <updated>2020-11-11T15:21:00.465Z</updated>
    
    <content type="html"><![CDATA[<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector', event);"><code>querySelector</code></a> method lets you retrieve DOM elements from JavaScript using CSS selectors:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> codeBlockEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'p.intro code'</span>);<br></code></pre></td></tr></table></figure><p>This API is ubiquitous in JavaScript, but it presents some challenges in a TypeScript context. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl.textContent);<br>   <span class="hljs-comment">// ~~~~~~~~~~~ const codeBlockEl: Element | null</span><br>   <span class="hljs-comment">//             Object is possibly 'null'.</span><br></code></pre></td></tr></table></figure><p>There&#39;s no guarantee that the selector will match any element, in which case it returns <code>null</code>. If you know from context that such an element does exist, you can use a non-<code>null</code> assertion (<code>!</code>) to silence the error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl!.textContent);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><code>codeBlockEl!</code> is shorthand for <code>(codeBlockEl as Element)</code> and is just as unsafe as any type assertion. If you <em>don&#39;t</em> know that the selector will match, you can use a conditional to narrow its type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (codeBlockEl) &#123;<br>  alert(codeBlockEl.textContent);  <span class="hljs-comment">// also ok</span><br>&#125;<br></code></pre></td></tr></table></figure><p>You can also use the optional chaining operator to allow <code>undefined</code>s to bubble up:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl?.textContent);  <span class="hljs-comment">// ok, might alert null or undefined</span><br></code></pre></td></tr></table></figure><p>But <code>null</code> isn&#39;t the only problem. You might also get a type that&#39;s not specific enough. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input.first-name'</span>);<br>alert(nameEl!.value);<br>           <span class="hljs-comment">// ~~~~~ Property 'value' does not exist on type 'Element'.</span><br></code></pre></td></tr></table></figure><p><code>document.querySelector</code> returns an <code>Element</code>, but the <code>value</code> property is only defined on <code>HTMLInputElement</code>, which is a subtype. The solutions to this problem are similar. You can either use an unsafe type assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl =<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input.first-name'</span>) <span class="hljs-keyword">as</span> HTMLInputElement;<br>alert(nameEl.value);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Or you can use an <code>instanceof</code> check to narrow the type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'input.first-name'</span>);<br><span class="hljs-keyword">if</span> (!(nameEl <span class="hljs-keyword">instanceof</span> HTMLInputElement)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Something has gone very, very wrong.'</span>);<br>&#125;<br>alert(nameEl.value);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>If you plug this last example into the <a href="https://www.typescriptlang.org/play/#code/MYewdgzgLgBGCGBbApgUQDYwLwwCYmAFcUwoA6AR0OQCcBPAZWXWWChBoAoByASzAAOhcgDNeNaAFoEKbgEoA3ACheImJwCEnGWkz9o8MMGQg1ACQAqAWQAyASUHCMyElDlyYAbyUwYUABY0IADucMihqDRBXNwMICgB-ADmMP7wEDBJ4MgwAG60dAA0eQUwwUFgSWTyygC+SvAsNFDaSLpkuY3Uir4A9L0wIADWSkA" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/play/#code/MYewdgzgLgBGCGBbApgUQDYwLwwCYmAFcUwoA6AR0OQCcBPAZWXWWChBoAoByASzAAOhcgDNeNaAFoEKbgEoA3ACheImJwCEnGWkz9o8MMGQg1ACQAqAWQAyASUHCMyElDlyYAbyUwYUABY0IADucMihqDRBXNwMICgB-ADmMP7wEDBJ4MgwAG60dAA0eQUwwUFgSWTyygC+SvAsNFDaSLpkuY3Uir4A9L0wIADWSkA', event);">TypeScript playground</a> and mouse over <code>nameEl</code> on the last line, you&#39;ll see that its TypeScript type is <code>HTMLInputElement</code>. Every other type would have made the code throw.</p><p>Writing these sorts of checks out every time you use <code>querySelector</code> quickly becomes tedious. Let&#39;s try to write a generic version instead!</p><p>The <code>null</code> checking is easy to abstract:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkedQuerySelector</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Element | Document, selector: <span class="hljs-built_in">string</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Element</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> el = parent.querySelector(selector);<br>  <span class="hljs-keyword">if</span> (!el) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> didn't match any elements.`</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> el;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can swap this in for any use of <code>querySelector</code> to exclude <code>null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(checkedQuerySelector(<span class="hljs-built_in">document</span>, <span class="hljs-string">'p.intro code'</span>).textContent);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>But what about the case where you need a more specific type? It&#39;s tempting to plug in a generic type parameter and try to implement something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeQuerySelector</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Document|Element, selector: <span class="hljs-built_in">string</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> el = checkedQuerySelector(parent, selector);<br>  <span class="hljs-keyword">if</span> (!(el <span class="hljs-keyword">instanceof</span> T)) &#123;<br>                   <span class="hljs-comment">// ~ 'T' only refers to a type, but is</span><br>                   <span class="hljs-comment">//    being used as a value here.</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> returned the wrong type.`</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> el;<br><span class="hljs-comment">// ~~~~~~~~~ Type 'Element' is not assignable to type 'T'.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The error on the <code>instanceof</code> check is a fundamental one that cannot be worked around. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof', event);"><code>instanceof</code></a> is an operator that is evaluated at runtime. As Item 3 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> (&quot;Understand That Code Generation Is Independent of Types&quot;) and <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://neugierig.org/software/blog/2016/04/typescript-types.html', event);">many other sites</a> explain, TypeScript types <em>do not exist at runtime</em>. So referencing them in a runtime expression is nonsensical. You can&#39;t get a value at runtime from a TypeScript type. It just won&#39;t work.</p><p>You <em>can</em> go the other way, however! Given a value, you can get a TypeScript type using <code>typeof</code>. And fortunately for us, there are runtime values corresponding to all the DOM types, just as there are for all classes. <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement', event);"><code>HTMLButtonElement</code></a> in TypeScript can refer to either a type or a value depending on the context.</p><p>So instead of passing in the type we want, let&#39;s pass in a value. Here&#39;s a sketch:</p><!-- verifier:skip because it's incomplete --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeQuerySelector</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> ???&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Document | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): ??? </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> buttonEl = safeQuerySelector(<br>  <span class="hljs-built_in">document</span>, HTMLButtonElement, <span class="hljs-string">'button.save'</span><br>);  <span class="hljs-comment">// type should be HTMLButtonElement</span><br></code></pre></td></tr></table></figure><p>Don&#39;t let the name fool you: <code>type</code> here is a <em>value</em>. We&#39;ve got a few blanks to fill in, but this declaration at least has the great advantage of not going against TypeScript&#39;s design principles!</p><p>Every value has a type. So what&#39;s the type of <code>HTMLButtonElement</code> in the previous function call? It&#39;s <code>typeof HTMLButtonElement</code>, of course! You can see what this really is by hovering over <code>T</code> in the following sample:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> HTMLButtonElement;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    new (): HTMLButtonElement;</span><br><span class="hljs-comment">//    prototype: HTMLButtonElement;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This definition comes from <a href="https://github.com/microsoft/TypeScript/blob/73b268ec5b7b31f7065b77c20b6a8d759e0b7091/lib/lib.dom.d.ts#L6610-L6613" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/blob/73b268ec5b7b31f7065b77c20b6a8d759e0b7091/lib/lib.dom.d.ts#L6610-L6613', event);"><code>lib.dom.d.ts</code></a>. It says that you can <code>new</code> an instance of <code>typeof HTMLButtonElement</code> to get an instance of the <code>HTMLButtonElement</code> type. The other DOM element classes (such as <code>HTMLElement</code>) have similar types.</p><p>We can use this to place a constraint on the generic parameter, <code>T</code>:</p><!-- verifier:skip because it's incomplete --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryElement</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">typeof</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  container: Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): ??? </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The <code>Element</code> in <code>T extends typeof Element</code> refers to a value, but <code>typeof Element</code> is a type. If <code>HTMLButtonElement</code> is a subtype of <code>Element</code>, then <code>typeof HTMLButtonElement</code> is a subtype of <code>typeof Element</code>. Passing in <code>HTMLButtonElement</code> will work, but passing in <code>RegExp</code> or <code>console</code> won&#39;t. And by using a generic parameter, we&#39;ll be able to infer a precise type based on the value of the <code>type</code> parameter at the call site.</p><!--<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Test of the claim in the previous paragraph.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-keyword">typeof</span> Element</span>) </span>&#123;&#125;<br><br>test(Element);<br>test(HTMLElement);<br>test(HTMLButtonElement);<br>test(HTMLDivElement);<br>test(<span class="hljs-regexp">/foo/</span>);<br>  <span class="hljs-comment">// ~~~~~ Type RegExp is not assignable to type typeof Element</span><br>test(<span class="hljs-built_in">console</span>);<br>  <span class="hljs-comment">// ~~~~~ Type Console is not assignable to type typeof Element</span><br></code></pre></td></tr></table></figure><p>--&gt;</p><p>What about the return type? How do we go from <code>typeof Element</code> to <code>Element</code> (the type)? This is precisely what TypeScript&#39;s built-in <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypet" target="_blank" rel="noopener"><code>InstanceType</code></a> generic does:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> HTMLButtonElement;<br><span class="hljs-keyword">type</span> U = InstanceType&lt;T&gt;;  <span class="hljs-comment">// type is HTMLButtonElement</span><br></code></pre></td></tr></table></figure><p>With that in place, we can finally implement the function:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryElement</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">typeof</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  container: Document | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">InstanceType</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> el = checkedQuerySelector(container, selector);<br>  <span class="hljs-keyword">if</span> (!(el <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">type</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>      <span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> matched <span class="hljs-subst">$&#123;el&#125;</span> which is not an <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>`</span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> el <span class="hljs-keyword">as</span> InstanceType&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>And this works exactly as you&#39;d hope:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> el = queryElement(<br>  <span class="hljs-built_in">document</span>, HTMLTextAreaElement, <span class="hljs-string">'textarea.deep-thoughts'</span><br>);<br>alert(el.value);  <span class="hljs-comment">// ok, el's type is HTMLTextAreaElement</span><br></code></pre></td></tr></table></figure><p>(If you know how to get rid of the type assertion on the <code>return</code> line, please <a href="https://twitter.com/danvdk" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://twitter.com/danvdk', event);">let me know</a>!)</p><p>If you preferred the syntax of the explicit generic argument, where the <code>Element</code> subtype is more clearly separated from the usual <code>querySelector</code> parameters, you can get close by <a href="https://wiki.haskell.org/Currying" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://wiki.haskell.org/Currying', event);">currying</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> curryQueryElement = &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-keyword">typeof</span> Element&gt;(<br>  <span class="hljs-keyword">type</span>: T,<br>) =&gt; (<br>  container: Document | Element,<br>  selector: <span class="hljs-built_in">string</span>,<br>) =&gt; queryElement(container, <span class="hljs-keyword">type</span>, selector);<br><br><span class="hljs-keyword">const</span> el = curryQueryElement(HTMLTextAreaElement)(<br>  <span class="hljs-built_in">document</span>, <span class="hljs-string">'textarea.deep-thoughts'</span><br>);<br><br><span class="hljs-comment">// Or:</span><br><span class="hljs-keyword">const</span> textareaQuery = curryQueryElement(HTMLTextAreaElement);<br><span class="hljs-keyword">const</span> el2 = textareaQuery(<span class="hljs-built_in">document</span>, <span class="hljs-string">'textarea.deep-thoughts'</span>);<br></code></pre></td></tr></table></figure><p>If you ever find yourself wanting to use a TypeScript type at runtime, ðŸ›‘STOP ðŸ›‘! Remember that TypeScript types get erased when your code is converted to JavaScript, leaving only the values. But if your goal is to check the runtime type <em>and</em> narrow the TypeScript type, there may still be hope. Types and values are a one-way street: you can go from a value to a type (with <code>typeof</code>), but not from a type to a value. So the solution is often to rework your API to pass around values and derive the types from those. The safe <code>querySelector</code> we&#39;ve built in this post is one example of doing that. In future posts we&#39;ll look at a few more examples of how this strategy can play out in practice.</p><p>Related material:</p><ul><li>Item 3: &quot;Understand That Code Generation Is Independent of Types&quot; or Evan Martin&#39;s <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://neugierig.org/software/blog/2016/04/typescript-types.html', event);">TypeScript&#39;s type independent output</a>.</li><li>Item 8: &quot;Know How to Tell Whether a Symbol Is in the Type Space or Value Space&quot; or Florian Reuschel&#39;s <a href="https://dev.to/loilo/typescript-s-secret-parallel-universe-54i6" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://dev.to/loilo/typescript-s-secret-parallel-universe-54i6', event);">TypeScript&#39;s Secret Parallel Universe</a></li><li>Item 55: &quot;Understand the DOM hierarchy&quot;</li></ul>]]></content>
    
    <summary type="html">
    
      The DOM&#39;s &lt;code&gt;document.querySelector&lt;/code&gt; method is ubiquitious in JavaScript but somewhat tricky to type in a safe way. This post walks through how you can create a safe &lt;code&gt;querySelector&lt;/code&gt; for use in TypeScript code and explains how this is an example of a general pattern of using values (which exist at runtime) as a source of truth, rather than types (which don&#39;t).

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Type-safe blogs and books with literate-ts</title>
    <link href="https://effectivetypescript.com/2020/06/30/literate-ts/"/>
    <id>https://effectivetypescript.com/2020/06/30/literate-ts/</id>
    <published>2020-06-30T21:00:00.000Z</published>
    <updated>2020-07-04T20:52:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Years ago when Brett Slatkin wrote <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://effectivepython.com/', event);"><em>Effective Python</em></a>, he <a href="https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html', event);">blogged about</a> creating a tool call <a href="https://github.com/bslatkin/pyliterate" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/bslatkin/pyliterate', event);">pyliterate</a> to run all the code samples in his book and verify that their output matched what he&#39;d written in the text. The idea stuck with me and when I started writing <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> in early 2019, I thought I&#39;d do something similar. If nothing else, static analysis of a book seems very much in the spirit of TypeScript. Creating <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> wound up being a lot of work, but in the end I think it more justified itself, though not quite for the reasons I expected!</p><a id="more"></a><p>TypeScript presents a few challenges for verification. You can compile and run a TypeScript program through Node to check its output, sure, but then you&#39;re not testing anything relating to the errors or inferred types. Usually you see these by mousing over a symbol or an error in your editor. But what&#39;s &quot;mousing over&quot; in a printed book? Still, inferred types and errors are both essential parts of the TypeScript experience and I wanted to both show them in <em>Effective TypeScript</em> and check them with a verifier.</p><p>As I wrote, I eventually settled on a system. To show an error in a code sample, I&#39;d put tildes and the error message in a comment under the line on which the error occurred. This is meant to evoke the squiggly red lines under an error in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">'not a number'</span>;<br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = str;<br><span class="hljs-comment">//  ~~~ Type 'string' is not assignable to type 'number'.</span><br></code></pre></td></tr></table></figure><p>In addition to conveying the error to the reader, there are a few things for that can be verified here:</p><ol><li>When you run it through <code>tsc</code>, does the code sample produce that one error <em>and no others</em>?</li><li>Do the tildes line up with the true error?</li><li>Do the error messages match?</li></ol><p>For inferred types, I used a slightly different comment syntax, always starting with &quot;type is&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x = <span class="hljs-number">12</span>;  <span class="hljs-comment">// type is number</span><br><span class="hljs-string">'four score'</span>.split(<span class="hljs-string">' '</span>);  <span class="hljs-comment">// type is string[]</span><br></code></pre></td></tr></table></figure><p>This indicates that if you mouse over <code>x</code> you&#39;ll see that the inferred type is <code>number</code>. For the second line, you need to assign the expression to a variable or mouse over <code>split</code> to see the <code>string[]</code> type. It&#39;s usually quite intuitive which symbol the &quot;type is&quot; refers to, but getting this right in the verifier took a bit of care. The main thing to verify here, of course, is the type of the symbol or expression. The string representations of the types are matched, character-for-character, ala <a href="https://github.com/microsoft/dtslint" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/dtslint', event);">dtslint</a>.</p><p>If the types don&#39;t line up, or the errors aren&#39;t quite right, <code>literate-ts</code> will complain:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cat sample.asciidoc<br>TypeScript will infer types in the absence of annotations:<br><br>[source,ts]<br>----<br>const n &#x3D; 10;  &#x2F;&#x2F; type is number<br>----<br><br>$ literate-ts --alsologtostderr sample.asciidoc<br>Verifying with TypeScript 4.0.0-dev.20200629<br><br>Code passed type checker.<br>sample-4: Failed type assertion for const n &#x3D; 10; (tested n)<br>  Expected: number<br>    Actual: 10<br>  0&#x2F;1 type assertions matched.<br></code></pre></td></tr></table></figure><p>(The issue is here is that the inferred type is the numeric literal type <code>10</code> rather than <code>number</code>. Either the comment should be changed or the variable should be declared with <code>let</code>.)</p><p>Overall I&#39;m pretty happy with how things turned out! You can check out the results over at the <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> repo. All in all, there are about 600 code samples in <em>Effective TypeScript</em> that all get checked. Running these checks takes 5â€“10 minutes on my Macbook.</p><p>So what sorts of errors did literate-ts turn up? Initiallyâ€¦ not many! I&#39;d been pretty careful about running code samples through VS Code or the TypeScript playground before committing them. Here was the first mistake that it caught (at the end of Item 7, &quot;Think of Types as Sets of values&quot;):</p><blockquote><p>Finally, it&#39;s worth noting that not all sets of values correspond to TypeScript types. There is no TypeScript type for all the integers, or for all the objects which have <code>x</code> and <code>y</code> properties but no others. You can sometimes subtract types using <code>Exclude</code>, but only when it would result in a proper TypeScript type:</p></blockquote><!-- verifier:skip because this is an example of a mistake --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Exclude&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">Date</span>, <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;  <span class="hljs-comment">// type is number</span><br><span class="hljs-keyword">type</span> NonZeroNums = Exclude&lt;<span class="hljs-built_in">number</span>, <span class="hljs-number">0</span>&gt;;  <span class="hljs-comment">// type is still just number</span><br></code></pre></td></tr></table></figure><p>It should be &quot;type is Date&quot;, not &quot;type is number&quot;. Not a major mistake (the argument is still valid) but a nice validation of literate-ts nonetheless. There were a handful of small mistakes like this.</p><p>Where literate-ts <em>really</em> shone was when I started <del>refactoring</del> editing the text. It&#39;s exactly the same as in coding. Writing it right the first time isn&#39;t nearly so hard as changing things and <em>keeping</em> them right. As I incorporated feedback from my editors and reworked Items, I constantly found myself introducing real mistakes that were caught by the verifier. Score one for literate-ts!</p><p>This was doubly true when the O&#39;Reilly editors started editing the text directly in the run-up to publication. Inevitably some mistakes were made, e.g. dropping quotes or comment markers. literate-ts caught all of these. (Since the book is stored in a git repo, <code>git log</code> and <code>git diff</code> were also extremely useful tools for catching these sorts of problems.)</p><p>But the biggest benefit came when new TypeScript versions were released. In the week before <em>Effective TypeScript</em> came out, the beta of TypeScript 3.7 was announced. As Anders Hejlsberg has said, semantic versioning isn&#39;t very meaningful when it comes to <code>tsc</code>: the whole <em>point</em> of new versions of TypeScript is to break your code! (Or rather to reveal ways in which it was already broken.) So as a book author, this was a bit terrifying. But no big deal, I just updated literate-ts and ran all the code samples.</p><p>The biggest issue I found was that I had a code sample showing that <code>interface</code>s could be recursive but <code>type</code> aliases couldn&#39;t. And that was trueâ€¦ until <a href="https://github.com/microsoft/TypeScript/pull/33050" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/pull/33050', event);">TypeScript 3.7!</a>. So I knew exactly what I had to fix. But just as importantly for my peace of mind, I knew that the rest of the book was OK. As new versions of TypeScript have come out since the book&#39;s publication in October of 2019, I&#39;ve continued to re-run the verifier and make minor revisions as needed.</p><p>So what sorts of mistakes <em>didn&#39;t</em> literate-ts catch? It&#39;s the classic case of <a href="https://www.destroyallsoftware.com/talks/ideology" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.destroyallsoftware.com/talks/ideology', event);">tests vs. types</a>. Here&#39;s a particularly egregious example:</p><!-- #binary-search-sorted-list --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SortedList&lt;T&gt; = T[] &amp; &#123;_brand: <span class="hljs-string">'sorted'</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSorted</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">xs: T[]</span>): <span class="hljs-title">xs</span> <span class="hljs-title">is</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; xs.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (xs[i] &lt; xs[i - <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">xs: SortedList&lt;T&gt;, x: T</span>): <span class="hljs-title">boolean</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This comes from Item 37, which discusses &quot;brands&quot;, a way of simulating nominal typing in TypeScript to create types for things like &quot;non-empty sets&quot; or &quot;sorted sets&quot; that can&#39;t be represented directly.</p><p>The implementation of <code>binarySearch</code> is listed earlier in the text and assumes a list that&#39;s sorted in ascending order. The <code>isSorted</code> type guard checks that the list is sortedâ€¦ but in descending order. Oops! This all type checks great, but it produces incorrect results. A type checker can&#39;t tell you that <code>&lt;</code> should be <code>&gt;</code> (Haskell people, please tell me if I&#39;m wrong!). You really need a unit test.</p><p>At some point I realized that you <em>could</em> create a unit test with literate-ts! The trick is to write some code that calls the function and <code>console.log</code>s the results. Then literate-ts can check the expected output against the actual output. This can all go in a comment so that the reader doesn&#39;t see it.</p><p>Basically all of the <a href="https://www.oreilly.com/catalog/errata.csp?isbn=0636920261544" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.oreilly.com/catalog/errata.csp?isbn=0636920261544', event);">errata</a> have been variations on this: things that weren&#39;t checked by the verifier. I&#39;m not aware of a single mistake having to do with the type system itself.</p><p>I&#39;ve recently published <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);"><code>literate-ts</code></a> to npm and added support for Markdown sources (O&#39;Reilly books are written in Asciidoc). And I&#39;ve started applying it to this blog. If you&#39;re writing a TypeScript book or blog yourself, head over to the <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> repo, give it a try and let me know how it goes!</p><p>If you prefer videos, literate-ts comes up in my 2019 tsconf talk on Testing Types:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/nygcFEwOG8w?start=1198" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><!--Reviewing _Mastering TypeScript_ is probably a good opportunity to polish this up and publicize it.literate-ts repo to-do:- To what extent have literate-ts and verifier diverged?- Make it use node_modules from the asciidoc directory  (or make this configurable?)- Speed it up (don't rebuild compiler on every sample)- Less verbose logging- Type check ets-site (i.e. support markdown)-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Years ago when Brett Slatkin wrote &lt;a href=&quot;https://effectivepython.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://effectivepython.com/&#39;, event);&quot;&gt;&lt;em&gt;Effective Python&lt;/em&gt;&lt;/a&gt;, he &lt;a href=&quot;https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html&#39;, event);&quot;&gt;blogged about&lt;/a&gt; creating a tool call &lt;a href=&quot;https://github.com/bslatkin/pyliterate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/bslatkin/pyliterate&#39;, event);&quot;&gt;pyliterate&lt;/a&gt; to run all the code samples in his book and verify that their output matched what he&amp;#39;d written in the text. The idea stuck with me and when I started writing &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; in early 2019, I thought I&amp;#39;d do something similar. If nothing else, static analysis of a book seems very much in the spirit of TypeScript. Creating &lt;a href=&quot;https://github.com/danvk/literate-ts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/danvk/literate-ts&#39;, event);&quot;&gt;literate-ts&lt;/a&gt; wound up being a lot of work, but in the end I think it more justified itself, though not quite for the reasons I expected!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Use typed identity functions to guide type inference</title>
    <link href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/"/>
    <id>https://effectivetypescript.com/2020/06/16/typed-identity-functions/</id>
    <published>2020-06-16T15:00:00.000Z</published>
    <updated>2021-03-31T23:10:42.973Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a> is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types. <span id="more"></span></p><p>Say you have a function to calculate the <a href="https://en.wikipedia.org/wiki/Pythagorean_theorem">distance between two points</a>:</p><!-- verifier:prepend-to-following --><!-- #point --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Point = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dist</span>(<span class="hljs-params">[x1, y1]: Point, [x2, y2]: Point</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>If you define some points and try to call this function, you&#39;ll get an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);<br><span class="hljs-comment">//           ~~ Argument of type &#x27;number[]&#x27; is not assignable</span><br><span class="hljs-comment">//                to parameter of type &#x27;Point&#x27;.</span><br><span class="hljs-comment">//              Type &#x27;number[]&#x27; is missing the following properties</span><br><span class="hljs-comment">//                from type &#x27;[number, number]&#x27;: 0, 1 (2345)</span><br></code></pre></td></tr></table></figure><p>The issue is that TypeScript has inferred the types of <code>p1</code> and <code>p2</code> as <code>number[]</code>, whereas you would have preferred <code>Point</code>. These aren&#39;t compatible (there are many number arrays that aren&#39;t <code>Point</code>s) and hence the error.</p><p>There are a whole class of type errors like this that happen when the inferred type wasn&#39;t quite the one you had in mind. In this case the easiest solution is to either declare the type of each point:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1: Point = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2: Point = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>or use a &quot;const assertion&quot; to avoid inferring the wider types:</p><!-- verifier:skip because I don't want to talk about readonly here --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>In this case the inferred types are much narrower than <code>Point</code>, but they are assignable to <code>Point</code>, so this type checks.</p><p>But in this post I want to talk about a slightly different approach, which is to use identity functions that adjust the inferred type. Here&#39;s one way you could use an identity(ish) function to get a <code>Point</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Point = (x: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">Point</span> =&gt;</span> [x, y];<br><br><span class="hljs-keyword">const</span> p1 = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> p2 = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The <code>Point</code> function is a value, so it&#39;s fine that it has the same name as the <code>Point</code> type, which exists in a separate namespace (Item 8 in <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a> discusses how to know if a symbol is in type or value space). The &quot;<code>: Point</code>&quot; declares the return type of the function. This is preferable to <code>as Point</code>, which <a href="https://stackoverflow.com/questions/41964087/in-typescript-is-there-a-reason-to-prefer-const-foo-type-or-const-foo">would not perform excess property checking</a>.</p><p>This certainly solves the problem and is sometimes more convenient than using declarations. Examples of this pattern in the wild include Material-UI&#39;s <a href="https://material-ui.com/guides/typescript/#using-createstyles-to-defeat-type-widening"><code>createStyles</code></a> and React Native&#39;s <a href="https://reactnative.dev/docs/style"><code>StyleSheet.create</code></a>.</p><p>In the case of a tuple, though, there&#39;s a neat trick (which I learned from Boris Cherny&#39;s <a href="https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656"><em>Programming TypeScript</em></a>) to solve this more generally. You can use a generic identity function to get TypeScript to infer a tuple type, rather than an array:</p><!-- verifier:prepend-subset-to-following:1-1 --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>[]&gt;</span>(...args: T): T =&gt; args;</span><br><br><span class="xml">const p1 = tuple(0, 0);</span><br><span class="xml">const p2 = tuple(3, 4);</span><br><span class="xml">let d = dist(p1, p2);  // ok</span><br></code></pre></td></tr></table></figure><p>If you mouse over <code>p1</code> or <code>p2</code> <a href="https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A16EA">in the playground</a>, you&#39;ll see that its type has been inferred as <code>[number, number]</code>, just like we wanted.</p><p>This works with any sort of tuples, including those with mixed types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-regexp">/three/</span>]; <span class="hljs-comment">// type is (string | number | RegExp)[]</span><br><span class="hljs-keyword">const</span> tup = tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-regexp">/three/</span>); <span class="hljs-comment">// type is [number, string, RegExp]</span><br></code></pre></td></tr></table></figure><p>The <code>tuple</code> function isn&#39;t one you&#39;d write in plain JavaScript (it&#39;s shorter to use an array literal), but in the TypeScript context it becomes an extremely useful way to change up the inferred type.</p><p>You can apply the same idea if you want to let TypeScript infer the keys of an object but still provide an explicit type for the values. For example:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals = &#123;<br>  ny: [-<span class="hljs-number">73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [-<span class="hljs-number">121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [-<span class="hljs-number">134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br></code></pre></td></tr></table></figure><p>If you try to calculate the distance between two capitals, you&#39;ll get the same error as before:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">dist(capitals.ny, capitals.ak);<br><span class="hljs-comment">//   ~~~~~~~~~~~ Argument of type &#x27;number[]&#x27; is not assignable</span><br><span class="hljs-comment">//                 to parameter of type &#x27;Point&#x27;</span><br></code></pre></td></tr></table></figure><p>(To calculate the actual distance you should use something like <a href="https://turfjs.org/docs/#distance"><code>turf.distance</code></a>.)</p><p>Mousing over <code>capitals</code>, you&#39;ll see its type is inferred as <code>&#123;ny: number[]; ca: number[]; ak: number[];&#125;</code>. You could wrap all the capital locations in <code>tuple</code> like before, but let&#39;s try writing a different identity function to force them all to be <code>Point</code>s:</p><!-- verifier:reset --><!-- verifier:prepend-id-to-following:point --><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueType = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">V</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>&gt;</span>() =&gt;</span><br>  &lt;T extends Record&lt;PropertyKey, V&gt;&gt;(o: T) =&gt; o;<br><br>const capitals = withValueType&lt;Point&gt;()(&#123;<br>  ny: [-73.7562, 42.6526],<br>  ca: [-121.4944, 38.5816],<br>  ak: [-134.4197, 58.3019],<br>&#125;);<br><br>let d = dist(capitals.ny, capitals.ak);  // ok<br></code></pre></td></tr></table></figure><p>If you mouse over the type of <code>capitals</code> now, it&#39;s</p><!-- verifier:skip because this is hovertext, not TS --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals: &#123;<br>    ny: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ca: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ak: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>and the types all work out!</p><p>So how does <code>withValueType</code> work? In order to infer the object&#39;s type as something different, we first need to capture it in a generic argument, just like we did with <code>tuple</code>. This is <code>T</code>, and we want TypeScript to infer it. We also want to explicitly write the value type <code>V</code> (<code>Point</code> in this case). Unfortunately you can&#39;t have a function with one explicit generic parameter and one inferred parameter. TypeScript will either infer all the generic parameters to a function or none of them, <a href="https://github.com/Microsoft/TypeScript/issues/14400">not a mix</a>.</p><p>There is a standard workaround for this problem: split the function into two, one with an explicit generic parameter and one with an inferred parameter. Instead of an identity function, we now have a function that <em>returns</em> an identity function. (Note the extra <code>()</code> after <code>withValueType</code>!)</p><p>It&#39;s important to note that this is quite different than using an <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types">index type</a> or <code>Record</code>, which also fixes the type error:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (Don&#x27;t do this, see below!)</span><br><span class="hljs-keyword">const</span> capitalsRec: Record&lt;<span class="hljs-built_in">string</span>, Point&gt; = &#123;<br>  ny: [-<span class="hljs-number">73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [-<span class="hljs-number">121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [-<span class="hljs-number">134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br><br>d = dist(capitalsRec.ny, capitalsRec.ak);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The difference is that accessing an invalid key produces an error when you let TypeScript infer the keys, but not when you use an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">capitalsRec.in;  <span class="hljs-comment">// allowed</span><br>capitals.in;<br>      <span class="hljs-comment">// ~~ Property &#x27;in&#x27; does not exist on type ...</span><br></code></pre></td></tr></table></figure><p>The inferred type of <code>capitals</code> is more like <code>Record&lt;&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;, Point&gt;</code> than <code>Record&lt;string, Point&gt;</code>. But because the keys were inferred, you didn&#39;t have to write <code>&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;</code> explicitly.</p><p>As a final example, you may find that you want to define an object that has some (but not all) of the fields of another object.</p><p>For example:</p><!-- verifier:reset --><!-- verifier:prepend-subset-to-following:1-7 --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> CSSColor = <span class="hljs-string">&#x27;aliceblue&#x27;</span> | <span class="hljs-string">&#x27;antiquewhite&#x27;</span> | <span class="hljs-string">&#x27;aqua&#x27;</span> | <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-comment">// | ...;</span><br><span class="hljs-keyword">interface</span> DisplayValue &#123;<br>  value: <span class="hljs-built_in">number</span>;<br>  units: <span class="hljs-built_in">string</span>;<br>  color: CSSColor;<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span> | <span class="hljs-string">&#x27;bold&#x27;</span> | <span class="hljs-string">&#x27;italic&#x27;</span> | <span class="hljs-string">&#x27;bolditalic&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaults = &#123;<br>  color: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// Type ... is not assignable to type &#x27;DisplayValue&#x27;.</span><br>   <span class="hljs-comment">//   Types of property &#x27;color&#x27; are incompatible.</span><br>   <span class="hljs-comment">//     Type &#x27;string&#x27; is not assignable to type &#x27;CSSColor&#x27;.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25_259_974_097_204</span>,<br>  units: <span class="hljs-string">&#x27;inches&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>What went wrong? Despite the error on <code>distanceToJupiter</code>, the problem is with <code>defaults</code>. Its type is inferred as <code>&#123; color: string; style: string; &#125;</code>, rather than the narrower value types required for a <code>DisplayValue</code>.</p><p>You might try to solve the problem by using <code>Partial</code> in the declaration of <code>defaults</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> defaults: Partial&lt;DisplayValue&gt; = &#123;<br>  color: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// ... Type &#x27;undefined&#x27; is not assignable to type &#x27;CSSColor&#x27;.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25_259_974_097_204</span>,<br>  units: <span class="hljs-string">&#x27;inches&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>Now the issue is that you&#39;ve lost the specificity of the keys in <code>defaults.</code> The <code>Partial&lt;DisplayValue&gt;</code> type marks <em>all</em> the properties as optional, including <code>color</code> and <code>style</code> which you&#39;ve definitely specified. Hence the error about <code>undefined</code>. (You can see this error on the <a href="https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=21&pc=1#code/C4TwDgpgBAwgynGB7ANkgTlAvFA5AQxQEsBjCAIxQFcJcoAfPfAO2CIEcaB3ACyOFoMmnfHUa5K+EgGs6AejlCAdCoDcAKCKsI6AGZToAESIBnMCnwgAaoRpQA3uqhQAbrYgAuKMyoBbcjoazlTM-CZeJsDoWgDmQVAkqBhe8IhJ6PGRICieeOgQMVQW6GJ45KgAJqW4-ISk1eUoFbXEJLgaAL7q6onMkVAVEPpFwOFQAAr46GyEADzGZhbW7gB82A5OCeleEhYyuAA0m1k5O-mFxYfqHRo9SH3AA6bALGQAKkgAUlRg-DpeC3Mlhs1GgOEczigCigAD84fCEYi4ZsoYpnG9wNBcCFBrotBAqlBTN4kI98CYTEQYsx8JRoMAkFBQJA8KlkGgSkooAAKABMAGZebyAJSbFRKXH4EYmI7ONygry8gCsAH1lQBOFXqgDsABYVQAGHVqg262VQEJhHZaEg8CAmK43dRAA">playground</a>.)</p><p>You can&#39;t solve this using <code>withValueType</code> since the values for <code>color</code> and <code>style</code> have different types. Instead, you can craft a slightly different generic identity function. I call this <code>withValueTypesFrom</code>, since you&#39;re taking the value types from some other type (if you have a better name, please suggest it!):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueTypesFrom = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">V</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>&gt;</span>() =&gt;</span><br>    &lt;K extends keyof V&gt;(x: Pick&lt;V, K&gt;): Pick&lt;V, K&gt; =&gt; x;<br><br>const defaults = withValueTypesFrom&lt;DisplayValue&gt;()(&#123;<br>  color: &#x27;black&#x27;,<br>  style: &#x27;regular&#x27;,<br>&#125;);  // Type is Pick&lt;DisplayValue, &quot;color&quot; | &quot;style&quot;&gt;<br><br>const distanceToJupiter: DisplayValue = &#123;<br>  ...defaults,<br>  value: 25_259_974_097_204,<br>  units: &#x27;inches&#x27;,<br>&#125;;  // ok<br></code></pre></td></tr></table></figure><p>It&#39;s worth repeating that none of the values have changed here, just the types. This has all the right properties: if you specify an invalid color in <code>defaults</code>, you&#39;ll get an error. If you misspell <code>color</code> as <code>colour</code>, you&#39;ll get an error. And if you leave out <code>value</code> or <code>units</code> in <code>distanceToJupiter</code>, you&#39;ll also get an error.</p><p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. But when you use tuples or string literal types, this will sometimes go wrong. When this happens, type declarations or const assertions are typically the answer. But if you want to adjust inference in more general or complex ways, typed identity functions give you the flexibility to do so.</p><p>Do you have other examples of functions that help with inference? Chime in in the comments! You can find the full code from this example on the <a href="https://www.typescriptlang.org/play/?ssl=52&ssc=7&pln=52&pc=20#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A10pl7qh+sRlphJFAAOTAFpwQnkPaOMwQPZ0X6HUAA05CcHEAA+gmIyAGbIAShABhUdB07tlcssXusCcTSeTflSIDTdn9GSc6sCqJdOdzyPzBaJbqLUC0EI4AGq2PI4CAlY7LIpm8qVaq1epIJqtJDdPRoSalJ1VGp1fmZYg8IowYhwSAeEAAaQgIHIZs63TgIx9kzgs0x2VYtjApstdQwJvNluttsgEcUwG9QkMxiQIHkmF8AHY3k52wBWABsaignxUTj7PZUfeopCMUHzrd84hU4icnwAnJ9PuQ3gAOJw97fiSfT4y2Brz8RvT4r8Sr9vkfdON4bG9T+gpZLpGEYOHCfOF4DFk4zbkH+RZ5PwTinh+fwmCYAB+CGIUhcFQAAgoM+DVKgcCMP80CEqyHSEoCdTNNi-D8AgAxILYBAFPQMGwUxzGwcAcBQGA-S2Hg5gkFAOF4US8DaISGLzLOyyNhQLZYB2Xa9gOXwjmOE6vsYc6yYuy5rhuW67vuh5qVMZ6aZe163veu5Pi+04pDm4mgQB4EhvIIZwGGRTakgAzkMJKCTBgUnNvOnbdv2g7DqO45HjOGltlpK7rpuUA7nuB4xSeJnxWZnw3neUAPtZq6vnZGIFmB-Ahk4yAMI5gE1TOsF-AhsBRjGoBEsgxE8HAECkXAqAVAI2HcKqUC9E46RjQAwgAyrN01wHk7nLISloIKwEB0daxFskStgoAgrjWi0DimhAu37cdtiXWt114P0yAXVAe2EnRtisA0xF-HtE0MNoJCMB90AACICPktggBaVrQFJABuFYQPIrIMMYLCmsMUBeQMqOzkt7nyHNC348QuOCCABTyISZgDDgeT9LdBBLTwt1gRtjPM2zrCEqk6R-LmqDIIwJAwBtDT2o6FSBq6jTNG03oTFA-pSy6dQwP0HCWg6qZCOmUCjIr2ZGlAZYOND1r8FWfUAGJRngEsBqrboevLQiZo1Stxo7QZQA0iYCSmXjyKLn0OuQcadGMsBi2HUAR4roj2VivAQEDdPACWJummbiOW8c-C23AeBFGD-AQ1DiP1lJmTLcQVPvZ95IzuTlNEjTdMM7ZH7Gz+B2bSUcAAFKrOdddQKX5fm4UBgzhNPCp7Y6f8MeUAIzD8gqD2AD6m+rlvt6fFvGy3jvGybjO6MZ1TyCsA4fVN6VQA">TypeScript playground</a>. <em>Some of the examples in this post come from an older post with a very different focus that I wrote for the <a href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/">LogRocket blog</a>.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of &lt;a href=&quot;https://amzn.to/38s1oCK&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types.
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 54: Know How to Iterate Over Objects</title>
    <link href="https://effectivetypescript.com/2020/05/26/iterate-objects/"/>
    <id>https://effectivetypescript.com/2020/05/26/iterate-objects/</id>
    <published>2020-05-26T13:30:45.000Z</published>
    <updated>2020-11-23T15:56:11.759Z</updated>
    
    <content type="html"><![CDATA[<p><em>Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the <a href="https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c', event);">quirks</a> of JavaScript objects and <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/interfaces.html', event);">duck typing</a>. Reading through this item again, I&#39;d add that this is all a good reason to consider using an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map', event);">ES6 <code>Map</code></a> instead of an object to store key/value pairs!</em></p><p>This code runs fine, and yet TypeScript flags an error in it. Why?</p><!-- #one-two-three --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  one: <span class="hljs-string">'uno'</span>,<br>  two: <span class="hljs-string">'dos'</span>,<br>  three: <span class="hljs-string">'tres'</span>,<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];<br>         <span class="hljs-comment">// ~~~~~~ Element implicitly has an 'any' type</span><br>         <span class="hljs-comment">//        because type ... has no index signature</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Inspecting the <code>obj</code> and <code>k</code> symbols gives a clue:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// const obj: &#123;</span><br><span class="hljs-comment">//     one: string;</span><br><span class="hljs-comment">//     two: string;</span><br><span class="hljs-comment">//     three: string;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-comment">// const k: string</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type of <code>k</code> is <code>string</code>, but you&#39;re trying to index into an object whose type only has three specific keys: <code>&#39;one&#39;</code>, <code>&#39;two&#39;</code>, and <code>&#39;three&#39;</code>. There are strings other than these three, so this has to fail.</p><p>Plugging in a narrower type declaration for <code>k</code> fixes the issue:</p><!-- verifier:prepend-id-to-following:one-two-three --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> k: keyof <span class="hljs-keyword">typeof</span> obj;  <span class="hljs-comment">// Type is "one" | "two" | "three"</span><br><span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure><p>So the real question is: why is the type of <code>k</code> in the first example inferred as <code>string</code> rather than <code>&quot;one&quot; | &quot;two&quot; | &quot;three&quot;</code>?</p><p>To understand, let&#39;s look at a slightly different example involving an interface and a function:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ABC &#123;<br>  a: <span class="hljs-built_in">string</span>;<br>  b: <span class="hljs-built_in">string</span>;<br>  c: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// const k: string</span><br>    <span class="hljs-keyword">const</span> v = abc[k];<br>           <span class="hljs-comment">// ~~~~~~ Element implicitly has an 'any' type</span><br>           <span class="hljs-comment">//        because type 'ABC' has no index signature</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>It&#39;s the same error as before. And you can &quot;fix&quot; it using the same sort of declaration (<code>let k: keyof ABC</code>). But in this case TypeScript is right to complain. Here&#39;s why:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = &#123;a: <span class="hljs-string">'a'</span>, b: <span class="hljs-string">'b'</span>, c: <span class="hljs-number">2</span>, d: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>foo(x);  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure><p>The function <code>foo</code> can be called with any value <em>assignable</em> to <code>ABC</code>, not just a value with &quot;a,&quot; &quot;b,&quot; and &quot;c&quot; properties. It&#39;s entirely possible that the value will have other properties, too (see Item 4: Get Comfortable with Structural Typing). To allow for this, TypeScript gives <code>k</code> the only type it can be confident of, namely, <code>string</code>.</p><p>Using the <code>keyof</code> declaration would have another downside here:</p><!--// verifier:reset// verifier:prepend-to-following    interface ABC {      a: string;      b: string;      c: number;    }--><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> k: keyof ABC;<br>  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// let k: "a" | "b" | "c"</span><br>    <span class="hljs-keyword">const</span> v = abc[k];  <span class="hljs-comment">// Type is string | number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code> is too narrow for <code>k</code>, then <code>string | number</code> is certainly too narrow for <code>v</code>. In the preceding example one of the values is a <code>Date</code>, but it could be anything. The types here give a false sense of certainty that could lead to chaos at runtime.</p><p>So what if you just want to iterate over the object&#39;s keys and values without type errors? <code>Object.entries</code> lets you iterate over both simultaneously:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] of <span class="hljs-built_in">Object</span>.entries(abc)) &#123;<br>    k  <span class="hljs-comment">// Type is string</span><br>    v  <span class="hljs-comment">// Type is any</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>While these types may be hard to work with, they are at least honest!</p><p>You should also be aware of the possibility of <em>prototype pollution</em>. Even in the case of an object literal that you define, for-in can produce additional keys:</p><pre data-type="programlisting">&gt; <strong>Object.prototype.z = 3;</strong> // Please don't do this!&gt; <strong>const obj = {x: 1, y: 2};</strong>&gt; <strong>for (const k in obj) { console.log(k); }</strong>xyz</pre><p>Hopefully this doesn&#39;t happen in a nonadversarial environment (you should never add enumerable properties to <code>Object.prototype</code>), but it is another reason that for-in produces <code>string</code> keys even for object literals.</p><p>If you want to iterate over the keys and values in an object, use either a <code>keyof</code> declaration (<code>let k: keyof T</code>) or <code>Object.entries</code>. The former is appropriate for constants or other situations where you know that the object won&#39;t have additional keys and you want precise types. The latter is more generally appropriate, though the key and value types are more difficult to work with.</p><h4 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h4><ul><li>Use <code>let k: keyof T</code> and a for-in loop to iterate objects when you know exactly what the keys will be. Be aware that any objects your function receives as parameters might have additional keys.</li><li>Use <code>Object.entries</code> to iterate over the keys and values of any object.</li></ul>]]></content>
    
    <summary type="html">
    
      Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. This item explains why the types you get from &lt;code&gt;Object.keys&lt;/code&gt; or a &lt;code&gt;for-in&lt;/code&gt; loop aren&#39;t quite what you&#39;d expect, and what your available workarounds are.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Unionize and Objectify: A Trick for Applying Conditional Types to Objects</title>
    <link href="https://effectivetypescript.com/2020/05/12/unionize-objectify/"/>
    <id>https://effectivetypescript.com/2020/05/12/unionize-objectify/</id>
    <published>2020-05-12T17:00:00.000Z</published>
    <updated>2021-01-20T02:37:14.866Z</updated>
    
    <content type="html"><![CDATA[<p><em>Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents <code>Unionize</code> and <code>Objectify</code>, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.</em></p><p>Sometimes the easiest way to get from A to B isn&#39;t the direct path. If you have great tools to solve problems in another domain, then mapping your problem onto that domain might just do the trick:</p><p><img src="/images/problem-domain-mapping.png" alt="Going from A to B is hard, but f(A) to f(B) is easy"></p><p>Examples of this are everywhere in math, science and software. It&#39;s not obvious that assigning <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Cartesian_coordinate_system', event);">cartesian coordinates</a> to points in a geometry problem will help solve it, but it works because we have great tools for solving algebra problems. It&#39;s not obvious that writing computer programs as a series of matrix operations will help you recognize <a href="https://en.wikipedia.org/wiki/MNIST_database" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/MNIST_database', event);">handwritten digits</a>, but it does because we have great tools like GPUs, <a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Backpropagation', event);">backprop</a> and <a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Gradient_descent', event);">gradient descent</a> for working with the matrix formulation.</p><p>So what does this have to do with TypeScript? In TypeScript our most powerful tool is <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/', event);">conditional types</a>. This is because they have two unique abilities:</p><ol><li>They distribute over unions.</li><li>They enable you to use the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types', event);"><code>infer</code> keyword</a>.</li></ol><p>So to the extent that we can map TypeScript problems into the domain of unions and conditional types, we&#39;ll find them easier to solve.</p><h3 id="Jsonify-with-methods"><a href="#Jsonify-with-methods" class="headerlink" title="Jsonify with methods"></a>Jsonify with methods</h3><p>As an example, consider a <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a> where we looked at the type of a variable before and after JSON serialization:</p><!--// verifier:prepend-to-following<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>--&gt;</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">123</span>, name: <span class="hljs-string">'Bobby'</span>, birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2007-10-10'</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The definition of JSON serialization in that post wasn&#39;t quite complete. If there&#39;s a method defined on an object, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">the MDN docs</a> say it will be omitted during serialization:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; JSON.stringify(&#123; name: &#39;Bobby&#39;, age: 12, greet() &#123; return &#39;Hi!&#39;; &#125;&#125;)<br>&#39;&#123;&quot;name&quot;: &quot;Bobby&quot;,&quot;age&quot;: 12&#125;&#39;<br></code></pre></td></tr></table></figure><p>Using the last version of <code>Jsonify</code> from the <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a>, however, we get something different (<a href="https://www.typescriptlang.org/play/#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyMobIA1AAboTJqRlZOXlc5vJIbQC2EAIA5ABCujogRwA0Km3Dh1AAjABMN-LDNbW8DFA1dQ1QI4ACRQAEIjkEwjcpJMZAB6OFQUCQQR0cwIyxQXYHAQDIbDEIYyx3B5IGJ7HRiQmIywfCC1AT0KTUsIyIA" target="_blank" rel="noopener">playground</a>):</p><!-- verifier:reset --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">//    greet: &#123;&#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>To get a more accurate type, we&#39;ll need to filter out the properties with function values. But how do you do that? More generally, how do you filter out properties from an object type that are assignable to some other type?</p><!-- verifier:skip because it's fill in the blank --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = ???;<br></code></pre></td></tr></table></figure><h3 id="OmitProperties"><a href="#OmitProperties" class="headerlink" title="OmitProperties"></a>OmitProperties</h3><p>One idea is to use <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types', event);">mapped types</a> and conditional types together:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: T[k] <span class="hljs-keyword">extends</span> V ? never : T[k];<br>&#125;;<br></code></pre></td></tr></table></figure><p>If the value type for a key (<code>T[k]</code>) extends <code>V</code>, then we change it to a <code>never</code> type. Otherwise we leave it as-is. Here&#39;s how that shakes out:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  greet: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> NonFunctionalPeople = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">//   greet: never;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This is close to what we want, but it&#39;s not exactly right. The <code>getId</code> key is still in the result type. It has a <code>never</code> value type, sure, but it&#39;s distracting and it will still show up in <code>keyof</code> expressions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = keyof NonFunctionalPeople;  <span class="hljs-comment">// type is "name" | "age" | "greet"</span><br></code></pre></td></tr></table></figure><p>Depending on the situation, this might be a disaster. For example, if you have a function to index a list based on a field, <code>greet</code> will be allowed because it&#39;s in <code>keyof T</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> people: NonFunctionalPeople[];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  vals: T[], field: keyof OmitProperties&lt;T, <span class="hljs-built_in">Function</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">const</span> index = indexByField(people, <span class="hljs-string">'greet'</span>);  <span class="hljs-comment">// OK, should be an error</span><br></code></pre></td></tr></table></figure><p>So what to do? We used conditional types here, but we didn&#39;t apply them to a union type, which is where they do their best work. To make a better  <code>OmitProperties</code>, we need to map from the domain of object types to the domain of union types.</p><!-- verifier:reset --><h3 id="Unionize-and-Objectify"><a href="#Unionize-and-Objectify" class="headerlink" title="Unionize and Objectify"></a>Unionize and Objectify</h3><p>I learned a trick for this from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian Cernicova-Dragomir</a> on <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">Stack Overflow</a>. You map from an object type to a union type of <code>{k, v}</code> pairs. Let&#39;s call this transformation <code>Unionize</code>:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Unionize&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: &#123;k: k; v: T[k]&#125;<br>&#125;[keyof T];<br><br><span class="hljs-keyword">type</span> PersonUnion = Unionize&lt;Person&gt;;<br><span class="hljs-comment">// type is &#123; k: "name"; v: string; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "greet"; v: () =&gt; string; &#125;</span><br></code></pre></td></tr></table></figure><p>We&#39;ve used a mapped type <code>[k in keyof T]</code> and an index operation <code>[keyof T]</code> to transform the object type into a union of types with <code>k</code> / <code>v</code> pairs. The key is a string literal type and the value is the value type.</p><p>You can put the object back together again using the inverse operation. Let&#39;s call that <code>Objectify</code>:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVPair = &#123;k: PropertyKey; v: unknown&#125;<br><span class="hljs-keyword">type</span> Objectify&lt;T <span class="hljs-keyword">extends</span> KVPair&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> T[<span class="hljs-string">'k'</span>]]: Extract&lt;T, &#123;k: k&#125;&gt;[<span class="hljs-string">'v'</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><p>This one is a little tricker. <code>PropertyKey</code> is an alias for anything that can be used as a property key in TypeScript: <code>string | number | symbol</code>. The <code>T[&#39;k&#39;]</code> extracts all the key types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = PersonUnion[<span class="hljs-string">'k'</span>];  <span class="hljs-comment">// type is "age" | "name" | "greet"</span><br></code></pre></td></tr></table></figure><p>Then we use <a href="https://fettblog.eu/typescript-built-in-generics/#extract" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://fettblog.eu/typescript-built-in-generics/#extract', event);"><code>Extract</code></a> to find the k/v pair for each key and pull out the corresponding value:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KV = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;;  <span class="hljs-comment">// type is &#123;k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> V = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;[<span class="hljs-string">'v'</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The result is that we can put our object type back together again:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReformedPerson = Objectify&lt;PersonUnion&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//     age: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     greet: () =&gt; string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>So we have a complete mapping between object types and unions of key/value pairs. Now we can put conditional types to work on their home turf! Let&#39;s see what this lets us do.</p><h3 id="OmitProperties-with-the-new-helpers"><a href="#OmitProperties-with-the-new-helpers" class="headerlink" title="OmitProperties with the new helpers"></a>OmitProperties with the new helpers</h3><p>First, <code>OmitProperties</code>. It&#39;s easy to filter a k/v pair based on the value type using a conditional:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? never : T;<br><br><span class="hljs-keyword">type</span> KV1 = OmitKV&lt;&#123;k: <span class="hljs-string">'age'</span>, v: <span class="hljs-built_in">number</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123; k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> KV2 = OmitKV&lt;&#123;k: <span class="hljs-string">'greet'</span>, v: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is never</span><br></code></pre></td></tr></table></figure><p>Now the fun part! Because <code>OmitKV</code> is a conditional type, it distributes over unions. And in a type union, <code>never</code> disappears:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVs = OmitKV&lt;PersonUnion, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "name"; v: string; &#125;</span><br></code></pre></td></tr></table></figure><p>By sandwiching <code>OmitKV</code> between <code>Unionize</code> and <code>Objectify</code>, we can take the long way around (as in the diagram at the start of the post) and get an <code>OmitProperties</code> implementation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Objectify&lt;OmitKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> T = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>greet</code> property, which was a function, is really, truly gone! ðŸ¤©</p><p>You can implement the opposite operation, <code>PickProperties</code>, in a similar way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? T : never;<br><span class="hljs-keyword">type</span> PickProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Objectify&lt;PickKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> PersonStrings = PickProperties&lt;Person, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type is &#123; name: string &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: keyof PickProperties&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>indexByField(people, <span class="hljs-string">'name'</span>);  <span class="hljs-comment">// OK</span><br>indexByField(people, <span class="hljs-string">'greet'</span>);<br>                   <span class="hljs-comment">// ~~~~~ Argument of type '"greet"' is not assignable</span><br>                   <span class="hljs-comment">//       to parameter of type '"name"'. (2345)</span><br></code></pre></td></tr></table></figure><p>Of course, if you just want the keys then you don&#39;t need to go back through <code>Objectify</code>. Something simpler accomplishes the same thing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Extract&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: PickKeys&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><h3 id="Jsonify-with-Unionize-and-Objectify"><a href="#Jsonify-with-Unionize-and-Objectify" class="headerlink" title="Jsonify with Unionize and Objectify"></a>Jsonify with Unionize and Objectify</h3><p>What other problems can you solve with this technique?</p><p>Looking back at <a href="https://effectivetypescript.com/2020/04/09/jsonify/"><code>Jsonify</code></a>, we can make it filter out Function values:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (opposite of PickKeys, above)</span><br><span class="hljs-keyword">type</span> OmitKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Exclude&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span>&lt;infer U&gt;<br>  ? <span class="hljs-built_in">Array</span>&lt;Jsonify&lt;U&gt;&gt;<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> OmitKeys&lt;T, <span class="hljs-built_in">Function</span>&gt;]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>greet</code> method is gone entirely, just as it should be. Amazing!</p><h3 id="Lodash-39-s-invert"><a href="#Lodash-39-s-invert" class="headerlink" title="Lodash&#39;s _.invert"></a>Lodash&#39;s <code>_.invert</code></h3><p>Yet another application (and the one that <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">introduced me to this technique</a>) is precisely typing <a href="https://lodash.com/docs/4.17.15#invert" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://lodash.com/docs/4.17.15#invert', event);">lodash&#39;s <code>_.invert()</code></a>, which swaps the keys and values in an object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> longToShort = _.invert(shortToLong);  <span class="hljs-comment">// what's the type?</span><br></code></pre></td></tr></table></figure><p>As of this writing, the type you get using <code>@types/lodash</code> is just <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002', event);"><code>_.Dictionary&lt;string&gt;</code></a>, which isn&#39;t wrong, but also isn&#39;t very precise. You can get a more precise result using <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Record&lt;<span class="hljs-built_in">string</span>, keyof T&gt;;<br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//    [x: string]: "p" | "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>shortToLong</code> constant is probably intended to be entirely immutable, so we can use a <a href="https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/', event);">const assertion</a> to get a more precise type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// type is &#123; readonly p: 'pageNum'; readonly n: 'numResults'; &#125;</span><br></code></pre></td></tr></table></figure><p>Now we should be able to get a <em>really</em> precise type for the inverse! It should be <code>{pageNum: &#39;p&#39;; numResults: &#39;n&#39;;}</code>. Let&#39;s see how <code>Unionize</code> and <code>Objectify</code> can help us get there.</p><p>First of all, swapping the <code>k</code> and <code>v</code> in a k/v pair is easy:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never;<br></code></pre></td></tr></table></figure><p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types', event);"><code>infer</code> keyword</a> (a conditional types superpower) to pull out the key and value types from a k/v pair.</p><p>If you try to wrap this in <code>Unionize</code> and <code>Objectify</code>, you&#39;ll get a very long, cryptic error. I&#39;ll spare you the full message, but the root cause is that <code>Objectify</code> requires that <code>k</code> be a <code>PropertyKey</code> and there&#39;s no guarantee that <code>V</code> is assignable to that. If we bake in that constraint, then everything works:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? V <span class="hljs-keyword">extends</span> PropertyKey  <span class="hljs-comment">// &lt;-- additional PropertyKey constraint</span><br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never<br>  : never;<br><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Objectify&lt;SwapKV&lt;Unionize&lt;T&gt;&gt;&gt;;<br></code></pre></td></tr></table></figure><p>Now we get perfect types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     pageNum: "p";</span><br><span class="hljs-comment">//     numResults: "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>If you drop the <code>as const</code>, you&#39;ll get a less-precise type, just like before. It would be nice to restrict <code>Inverted</code> to only allow types with <code>PropertyKey</code> values, but I&#39;ll leave that as an exercise to the reader.</p><p>If you have duplicate values, you get a union of the values for the key type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> playerToTeam = &#123;<br>  a: <span class="hljs-string">'A'</span>,<br>  b: <span class="hljs-string">'A'</span>,<br>  c: <span class="hljs-string">'B'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> playerToTeam&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     A: "a" | "b";</span><br><span class="hljs-comment">//     B: "c";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This seems sensible since TypeScript doesn&#39;t have a notion of the order of keys in an object or elements in a union. I recommend working out the sequence of operations yourself to see how this union (<code>&quot;a&quot; | &quot;b&quot;</code>) comes about.</p><!--It would be nice if TypeScript displayed types as objects in this:function invert<T extends object>(o: T): Inverted<T> {  return _.invert(o);}const invMapping = invert(mapping);// const invMapping: Objectify<{//     k: "fooBar";//     v: "foo_bar";// } | {//     k: "bazQuux";//     v: "baz_quux";// } | {//     k: "fooBar";//     v: "bar";// }>Titian's `{} &` trick seems to be of no use here.--><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Ever since I learned about them, I&#39;ve been finding more and more uses for <code>Unionize</code> and <code>Objectify</code>. You&#39;ve seen three of them in this post, but I&#39;m sure there are many others. They have a real knack for transforming difficult problems with object types into much simpler problems with union types. Next time you run into a problem with types, think about whether unionization can help!</p><p>To experiment with the code samples in this post, use <a href="https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA', event);">this playground link</a>.</p><p><em>A huge thanks to <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian</a> for introducing me to this! He uses &quot;AllValues&quot; instead of &quot;Unionize&quot;. If you don&#39;t like the names, feel free to choose your own. You could go with &quot;ToPairs&quot; and &quot;FromPairs&quot; to match lodash, or &quot;ToUnion&quot; and &quot;ToObject&quot;. If you just want something like <code>OmitProperties</code>, take a look at ts-essential&#39;s <a href="https://github.com/krzkaczor/ts-essentials#omitproperties" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://github.com/krzkaczor/ts-essentials#omitproperties', event);"><code>OmitProperties</code></a>.</em></p>]]></content>
    
    <summary type="html">
    
      Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents &lt;code&gt;Unionize&lt;/code&gt; and &lt;code&gt;Objectify&lt;/code&gt;, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 19: Avoid Cluttering Your Code with Inferable Types</title>
    <link href="https://effectivetypescript.com/2020/04/28/avoid-inferable/"/>
    <id>https://effectivetypescript.com/2020/04/28/avoid-inferable/</id>
    <published>2020-04-28T15:23:45.000Z</published>
    <updated>2020-07-04T20:46:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 3 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);">Effective TypeScript</a> covers type inference: the process by which TypeScript infers the type of symbols in the absence of explicit annotations. A significant fraction of the comments I leave on TypeScript code reviews point out places where type annotations are unnecessary and can be omitted. This item explains why explicitly annotating inferable types is typically a bad idea, and enumerates a few specific exceptions to this rule.</em></p><p>The first thing that many new TypeScript developers do when they convert a codebase from JavaScript is fill it with type annotations. TypeScript is about <em>types</em>, after all! But in TypeScript many annotations are unnecessary. Declaring types for all your variables is counterproductive and is considered poor style.</p><p>Donâ€™t write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>Instead, just write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>If you mouse over <code>x</code> in your editor, youâ€™ll see that its type has been inferred as <code>number</code>:</p><img src="/images/efts_03in01.png" title="A text editor showing that the inferred type of x is number." width="33%"><p>The explicit type annotation is redundant. Writing it just adds noise. If you&#39;re unsure of the type, you can check it in your editor.</p><p>TypeScript will also infer the types of more complex objects. Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> person: &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  born: &#123;<br>    where: <span class="hljs-built_in">string</span>;<br>    when: <span class="hljs-built_in">string</span>;<br>  &#125;;<br>  died: &#123;<br>    where: <span class="hljs-built_in">string</span>;<br>    when: <span class="hljs-built_in">string</span>;<br>  &#125;<br>&#125; = &#123;<br>  name: <span class="hljs-string">'Sojourner Truth'</span>,<br>  born: &#123;<br>    where: <span class="hljs-string">'Swartekill, NY'</span>,<br>    when: <span class="hljs-string">'c.1797'</span>,<br>  &#125;,<br>  died: &#123;<br>    where: <span class="hljs-string">'Battle Creek, MI'</span>,<br>    when: <span class="hljs-string">'Nov. 26, 1883'</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>you can just write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> person = &#123;<br>  name: <span class="hljs-string">'Sojourner Truth'</span>,<br>  born: &#123;<br>    where: <span class="hljs-string">'Swartekill, NY'</span>,<br>    when: <span class="hljs-string">'c.1797'</span>,<br>  &#125;,<br>  died: &#123;<br>    where: <span class="hljs-string">'Battle Creek, MI'</span>,<br>    when: <span class="hljs-string">'Nov. 26, 1883'</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>Again, the types are exactly the same. Writing the type in addition to the value just adds noise here. (Item 21, Understand Type Widening, has more to say on the types inferred for object literals.)</p><p>What&#39;s true for objects is also true for arrays. TypeScript has no trouble figuring out the return type of this function based on its inputs and operations:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> nums.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);<br>&#125;<br><span class="hljs-keyword">const</span> squares = square([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">// Type is number[]</span><br></code></pre></td></tr></table></figure><p>TypeScript may infer something more precise than what you expected. This is generally a good thing. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> axis1: <span class="hljs-built_in">string</span> = <span class="hljs-string">'x'</span>;  <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">const</span> axis2 = <span class="hljs-string">'y'</span>;  <span class="hljs-comment">// Type is "y"</span><br></code></pre></td></tr></table></figure><p><code>&quot;y&quot;</code> is a more precise type for the <code>axis</code> variable, and using it may fix some errors that would appear with the less-precise <code>string</code>.</p><p>Allowing types to be inferred can also facilitate refactoring. Say you have a <code>Product</code> type and a function to log it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> id: <span class="hljs-built_in">number</span> = product.id;<br>  <span class="hljs-keyword">const</span> name: <span class="hljs-built_in">string</span> = product.name;<br>  <span class="hljs-keyword">const</span> price: <span class="hljs-built_in">number</span> = product.price;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>At some point you learn that product IDs might have letters in them in addition to numbers. So you change the type of <code>id</code> in <code>Product</code>. Because you included explicit annotations on all the variables in <code>logProduct</code>, this produces an error:</p><!-- verifier:prepend-subset-to-following:1-5 --><!-- #inferable-product --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> id: <span class="hljs-built_in">number</span> = product.id;<br>     <span class="hljs-comment">// ~~ Type 'string' is not assignable to type 'number'</span><br>  <span class="hljs-keyword">const</span> name: <span class="hljs-built_in">string</span> = product.name;<br>  <span class="hljs-keyword">const</span> price: <span class="hljs-built_in">number</span> = product.price;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>Had you left off all the annotations in the <code>logProduct</code> function body, the code would have passed the type checker without modification.</p><p>A better implementation of <code>logProduct</code> would use destructuring assignment:</p><!-- #log-product --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, price&#125; = product;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><p>This version allows the types of all the local variables to be inferred. The corresponding version with explicit type annotations is repetitive and cluttered:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logProduct</span>(<span class="hljs-params">product: Product</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, price&#125;: &#123;id: <span class="hljs-built_in">string</span>; name: <span class="hljs-built_in">string</span>; price: <span class="hljs-built_in">number</span> &#125; = product;<br>  <span class="hljs-built_in">console</span>.log(id, name, price);<br>&#125;<br></code></pre></td></tr></table></figure><!-- verifier:reset --><p>Explicit type annotations are still required in some situations where TypeScript doesnâ€™t have enough context to determine a type on its own. You have seen one of these before: function parameters.</p><p>Some languages will infer types for parameters based on their eventual usage, but TypeScript does not. In TypeScript, a variable&#39;s type is generally determined when it is first introduced.</p><p>Ideal TypeScript code includes type annotations for function/method signatures but not for the local variables created in their bodies. This keeps noise to a minimum and lets readers focus on the implementation logic.</p><p>There are some situations where you can leave the type annotations off of function parameters, too. When thereâ€™s a default value, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseNumber</span>(<span class="hljs-params">str: <span class="hljs-built_in">string</span>, base=10</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Here the type of <code>base</code> is inferred as <code>number</code> because of the default value of <code>10</code>.</p><p>Parameter types can usually be inferred when the function is used as a callback for a library with type declarations. The declarations on <code>request</code> and <code>response</code> in this example using the express HTTP server library are not required:</p><!-- #express-example --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don't do this:</span><br>app.get(<span class="hljs-string">'/health'</span>, <span class="hljs-function">(<span class="hljs-params">request: express.Request, response: express.Response</span>) =&gt;</span> &#123;<br>  response.send(<span class="hljs-string">'OK'</span>);<br>&#125;);<br><br><span class="hljs-comment">// Do this:</span><br>app.get(<span class="hljs-string">'/health'</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  response.send(<span class="hljs-string">'OK'</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>For much more on this, see Item 26: Understand How Context Is Used in Type Inference.</p><p>There are a few situations where you may still want to specify a type even where it can be inferred.</p><p>One is when you define an object literal:</p><!-- verifier:prepend-id-to-following:inferable-product --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> elmo: Product = &#123;<br>  name: <span class="hljs-string">'Tickle Me Elmo'</span>,<br>  id: <span class="hljs-string">'048188 627152'</span>,<br>  price: <span class="hljs-number">28.99</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>When you specify a type on a definition like this, you enable excess property checking. This can help catch errors, particularly for types with optional fields. (This is discussed in more detail in Item 11: Recognize the Limits of Excess Property Checking.)</p><p>You also increase the odds that an error will be reported in the right place. If you leave off the annotation, a mistake in the object&#39;s definition will result in a type error where it&#39;s used, rather than where it&#39;s defined:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> furby = &#123;<br>  name: <span class="hljs-string">'Furby'</span>,<br>  id: <span class="hljs-number">630509430963</span>,<br>  price: <span class="hljs-number">35</span>,<br>&#125;;<br>logProduct(furby);<br>        <span class="hljs-comment">// ~~~~~ Argument .. is not assignable to parameter of type 'Product'</span><br>        <span class="hljs-comment">//         Types of property 'id' are incompatible</span><br>        <span class="hljs-comment">//         Type 'number' is not assignable to type 'string'</span><br></code></pre></td></tr></table></figure><p>With an annotation, you get a more concise error in the place where the mistake was made:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"> <span class="hljs-keyword">const</span> furby: Product = &#123;<br>   name: <span class="hljs-string">'Furby'</span>,<br>   id: <span class="hljs-number">630509430963</span>,<br><span class="hljs-comment">// ~~ Type 'number' is not assignable to type 'string'</span><br>   price: <span class="hljs-number">35</span>,<br> &#125;;<br> logProduct(furby);<br></code></pre></td></tr></table></figure><!-- verifier:reset --><p>Similar considerations apply to a function&#39;s return type. You may still want to annotate this even when it can be inferred to ensure that implementation errors don&#39;t leak out into uses of the function.</p><p>Say you have a function which retrieves a stock quote:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://quotes.example.com/?q=<span class="hljs-subst">$&#123;ticker&#125;</span>`</span>)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json());<br>&#125;<br></code></pre></td></tr></table></figure><p>You decide to add a cache to avoid duplicating network requests:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> cache: &#123;[ticker: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>&#125; = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (ticker <span class="hljs-keyword">in</span> cache) &#123;<br>    <span class="hljs-keyword">return</span> cache[ticker];<br>  &#125;<br>  <span class="hljs-keyword">return</span> fetch(<span class="hljs-string">`https://quotes.example.com/?q=<span class="hljs-subst">$&#123;ticker&#125;</span>`</span>)<br>      .then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> response.json())<br>      .then(<span class="hljs-function"><span class="hljs-params">quote</span> =&gt;</span> &#123;<br>        cache[ticker] = quote;<br>        <span class="hljs-keyword">return</span> quote;<br>      &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Thereâ€™s a mistake in this implementation: you should really be returning <code>Promise.resolve(cache[ticker])</code> so that <code>getQuote</code> always returns a Promise. The mistake will most likely produce an errorâ€¦ but in the code that calls <code>getQuote</code>, rather than in <code>getQuote</code> itself:</p><!--// verifier:prepend-to-following<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">considerBuying</span>(<span class="hljs-params">x: <span class="hljs-built_in">any</span></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>--&gt;</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getQuote(<span class="hljs-string">'MSFT'</span>).then(considerBuying);<br>              <span class="hljs-comment">// ~~~~ Property 'then' does not exist on type</span><br>              <span class="hljs-comment">//        'number | Promise&lt;any&gt;'</span><br>              <span class="hljs-comment">//      Property 'then' does not exist on type 'number'</span><br></code></pre></td></tr></table></figure><p>Had you annotated the intended return type (<code>Promise&lt;number&gt;</code>), the error would have been reported in the correct place:</p><!-- verifier:reset --><!-- #get-quote-error --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> cache: &#123;[ticker: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">number</span>&#125; = &#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getQuote</span>(<span class="hljs-params">ticker: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">if</span> (ticker <span class="hljs-keyword">in</span> cache) &#123;<br>    <span class="hljs-keyword">return</span> cache[ticker];<br>        <span class="hljs-comment">// ~~~~~~~~~~~~~ Type 'number' is not assignable to 'Promise&lt;number&gt;'</span><br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><!-- verifier:reset --><p>When you annotate the return type, it keeps implementation errors from manifesting as errors in user code. (<code>async</code> functions are an effective way to avoid this specific error with Promises. They&#39;re discused in detail in Item 25: Use async Functions Instead of Callbacks for Asynchronous Code).</p><p>Writing out the return type may also help you think more clearly about your function: you should know what its input and output types are <em>before you implement it</em>. While the implementation may shift around a bit, the function&#39;s contract (its type signature) generally should not. This is similar in spirit to test-driven development (TDD), in which you write the tests that exercise a function before you implement it. Writing the full type signature first helps get you the function you want, rather than the one the implementation makes expedient.</p><p>A final reason to annotate return values is if you want to use a named type. You might choose not to write a return type for this function, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2D &#123; x: <span class="hljs-built_in">number</span>; y: <span class="hljs-built_in">number</span>; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: Vector2D, b: Vector2D</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123; x: a.x + b.x, y: a.y + b.y &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript infers the return type as <code>{ x: number; y: number; }</code>. This is compatible with <code>Vector2D</code>, but it may be surprising to users of your code when they see <code>Vector2D</code> as a type of the input and not of the output:</p><img src="/images/efts_03in02.png" title="The parameters to the add function have named types, while the inferred return value does not." width="75%"><p>If you annotate the return type, the presentation is more straightforward. And if you&#39;ve written documentation on the type (Item 48: Use TSDoc for API Comments) then it will be associated with the returned value as well. As the complexity of the inferred return type increases, it becomes increasingly helpful to provide a name.</p><p>If you are using a linter, the eslint rule <code>no-inferrable-types</code> (note the variant spelling) can help ensure that all your type annotations are really necessary.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid writing type annotations when TypeScript can infer the same type.</li><li>Ideally your code has type annotations in function/method signatures but not on local variables in their bodies.</li><li>Consider using explicit annotations for object literals and function return types even when they can be inferred. This will help prevent implementation errors from surfacing in user code.</li></ul>]]></content>
    
    <summary type="html">
    
      The first thing that many new TypeScript developers do when they convert a codebase from JavaScript is fill it with type annotations. TypeScript is about &lt;i&gt;types&lt;/i&gt;, after all! But in TypeScript many annotations are unnecessary. Declaring types for all your variables is counterproductive and is considered poor style.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>What&#39;s the type of JSON.parse(â€‹JSON.stringify(x))?</title>
    <link href="https://effectivetypescript.com/2020/04/09/jsonify/"/>
    <id>https://effectivetypescript.com/2020/04/09/jsonify/</id>
    <published>2020-04-09T15:00:56.000Z</published>
    <updated>2021-02-21T15:48:49.729Z</updated>
    
    <content type="html"><![CDATA[<p>If you&#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:</p><!-- verifier:skip to avoid express dep --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> user = getCurrentUser();<br>  response.json(user);<br>&#125;);<br></code></pre></td></tr></table></figure><p>On the client, you might use the <code>fetch</code> API to hit this endpoint and deserialize (parse) the data:</p><!-- verifier:tsconfig:module=esnext --><!-- verifier:tsconfig:target=esnext --><!-- verifier:skip until top-level await works --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/user&#x27;</span>);<br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> response.json();<br></code></pre></td></tr></table></figure><p>What&#39;s the relationship between the <code>user</code> object in the server and the corresponding <code>user</code> object in the client? And how would you model this in TypeScript?</p><span id="more"></span><p>Because the serialization and deserialization <a href="https://github.com/expressjs/express/blob/67e64ca4c1c5b26cf971e6d6c35278d6357dc6bb/lib/response.js#L1122">ultimately happens</a> via JavaScript&#39;s built-in <code>JSON.stringify</code> and <code>JSON.parse</code> functions, we can alternatively ask: what&#39;s the return type of this function?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>If you mouse over <code>jsonRoundTrip</code> on the <a href="https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=10&pc=1#code/GYVwdgxgLglg9mABAKwM4IEp3AEwCoBOMADgDx4B8AFAB4BcieAlIgN4BQiiBAplCASQApAMoB5AHIA6YgEMCqHlVGSpqKETABzGMACetJkwDc7AL7sgA">TypeScript playground</a>, you&#39;ll see that its inferred return type is <code>any</code>. That&#39;s not very satisfying!</p><p>It&#39;s tempting to make the return type <code>T</code>, so that this is like an identity function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure><p>But this isn&#39;t quite right. First of all, there are many objects which can&#39;t be directly represented in JSON. A regular expression, for instance:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; JSON.stringify(&#x2F;foo&#x2F;)<br>&#39;&#123;&#125;&#39;<br></code></pre></td></tr></table></figure><p>Second, there are some values that get transformed in the conversion process. For example, <code>undefined</code> in an array becomes <code>null</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; arr &#x3D; [undefined]<br>&gt; jsonRoundTrip(arr)<br>[ null ]<br></code></pre></td></tr></table></figure><p>With <code>strictNullChecks</code> in TypeScript, <code>null</code> and <code>undefined</code> have distinct types.</p><p>If an object has a <code>toJSON</code> method, it will get called by <code>JSON.stringify</code>. This is implemented by some of the standard types in JavaScript, notably <code>Date</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; jsonRoundTrip(d)<br>&#39;2020-04-09T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure><p>So <code>Date</code>s get converted to <code>string</code>s. Who knew? You can read the full details of how this works <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify">on MDN</a>.</p><p>How to model this in TypeScript? Let&#39;s just focus on the behavior around Dates. For a complex mapping like this, we&#39;re going to want a <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/">conditional type</a>:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span> ? <span class="hljs-built_in">string</span> : T;<br></code></pre></td></tr></table></figure><p>This is already doing something sensible:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T1 = Jsonify&lt;<span class="hljs-built_in">string</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;<span class="hljs-built_in">Date</span>&gt;; <span class="hljs-comment">// Type is string</span><br><span class="hljs-keyword">type</span> T3 = Jsonify&lt;<span class="hljs-built_in">boolean</span>&gt;; <span class="hljs-comment">// Type is boolean</span><br></code></pre></td></tr></table></figure><p>We even get support for union types because conditional types distribute over unions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Jsonify&lt;<span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>&gt;;  <span class="hljs-comment">// Type is string | null</span><br></code></pre></td></tr></table></figure><p>But what about object types? Usually the <code>Date</code>s are buried somehwere in a larger type. So we&#39;ll need to make <code>Jsonify</code> recursive. This is possible <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases">as of TypeScript 3.7</a>:</p><!-- verifier:reset --><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Date</span><br>  ? <span class="hljs-built_in">string</span><br>  : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span><br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br></code></pre></td></tr></table></figure><p>In the case that we have an object type, we use a <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types">mapped type</a> to recursively apply the <code>Jsonify</code> transformation. This is already starting to make some interesting new types!</p><!-- verifier:prepend-subset-to-following:1-5 --><!-- #student --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">interface</span> Class &#123;<br>  valedictorian: Student;<br>  salutatorian?: Student;<br>&#125;<br><span class="hljs-keyword">type</span> T2 = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   valedictorian: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;;</span><br><span class="hljs-comment">//   salutatorian?: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125; | undefined;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>What if there&#39;s an array involved? Does that work?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Class &#123;<br>    teacher: <span class="hljs-built_in">string</span>;<br>    start: <span class="hljs-built_in">Date</span>;<br>    stop: <span class="hljs-built_in">Date</span>;<br>    students: Student[];<br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Class&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   teacher: string;</span><br><span class="hljs-comment">//   start: string;</span><br><span class="hljs-comment">//   stop: string;</span><br><span class="hljs-comment">//   students: &#123;</span><br><span class="hljs-comment">//     id: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     birthday: string | null;</span><br><span class="hljs-comment">//   &#125;[];</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>It does! How was TypeScript able to figure that out?</p><p>First of all, Arrays are objects, so <code>T extends object</code> is true for any array type. And <code>keyof T[]</code> includes <code>number</code>, since you can index into an array with a <code>number</code>. But it also includes methods like <code>length</code> and <code>toString</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = keyof Student[];  <span class="hljs-comment">// type is number | &quot;length&quot; | &quot;toString&quot; | ...</span><br></code></pre></td></tr></table></figure><p>So it&#39;s a bit of a surprise <code>Jsonify</code> produces such a clean type for the array. Perhaps mapped types over arrays are special cased.</p><p>But regardless, this is great! We can even loosen the definition slightly to handle any object with a <code>toJSON()</code> method (including Dates):</p><!-- verifier:reset --><!-- verifier:prepend-id-to-following:student --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span><br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">327</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">birthday</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2007-10-10&#x27;</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-keyword">const</span> objWithToJSON = &#123;<br>  x: <span class="hljs-number">5</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">6</span>, <span class="hljs-function"><span class="hljs-title">toJSON</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x + <span class="hljs-built_in">this</span>.y; &#125;<br>&#125;;<br><span class="hljs-keyword">const</span> objRT = jsonRoundTrip(objWithToJSON);<br><span class="hljs-comment">// type is number!</span><br></code></pre></td></tr></table></figure><p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types">infer keyword</a> to infer the return type of the <code>toJSON</code> method of the object. Try the last example out in <a href="https://www.typescriptlang.org/play/?ssl=25&ssc=11&pln=25&pc=62#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyQpSiaG2G0Cx11FTAVfIo1AJIMQC2OmIh8khtexACA0PDx1A6KKLAABbUbSACACJtlFAAPlC7AA2gJkskMyAGUAGMVWSGAAmWMLWhAYWwEAEYAEwAZgANACzhcoAByABCuh0IGJ+Pujxebx2EAA7lAvpQuMTMQAGLkAdgAtOiuYKucSeFIQuCkJDobDgGkSEQUsgMlkcnkuLK1pMZAB6XVQUCQQR0cz6yxogH7Q6iELmk6Ey6DIQ3PUG+S056vd5Q50jP5W4F2g2yGRSyEIFH0KDFKAAVnxPoAbPimL1eNGanUGoanig4M0yFAANS5-PNEBBMJhSUQ9YIBUo5XpTI0dVgLgIHXmo3QfNWg5iACEMiAA">the playground</a>. It really does return a <code>number</code>!</p><p>As TypeScript Development lead Ryan Cavanaugh once <a href="https://twitter.com/SeaRyanC/status/1029846761718702081">said</a>, it&#39;s remarkable how many problems are solved by conditional types. The types involved in JSON serialization are one of them! If you produce and consume JSON in a TypeScript project, consider using something like <code>Jsonify</code> to safely handle Dates in your objects.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If you&amp;#39;re writing a server in JavaScript, you might write an endpoint that converts an object to JSON:&lt;/p&gt;
&lt;!-- verifier:skip to avoid express dep --&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;app.get(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;/user&amp;#x27;&lt;/span&gt;, &lt;span class=&quot;hljs-function&quot;&gt;(&lt;span class=&quot;hljs-params&quot;&gt;request, response&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = getCurrentUser();&lt;br&gt;  response.json(user);&lt;br&gt;&amp;#125;);&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;On the client, you might use the &lt;code&gt;fetch&lt;/code&gt; API to hit this endpoint and deserialize (parse) the data:&lt;/p&gt;
&lt;!-- verifier:tsconfig:module=esnext --&gt;
&lt;!-- verifier:tsconfig:target=esnext --&gt;
&lt;!-- verifier:skip until top-level await works --&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; response = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; fetch(&lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;/user&amp;#x27;&lt;/span&gt;);&lt;br&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; user = &lt;span class=&quot;hljs-keyword&quot;&gt;await&lt;/span&gt; response.json();&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;What&amp;#39;s the relationship between the &lt;code&gt;user&lt;/code&gt; object in the server and the corresponding &lt;code&gt;user&lt;/code&gt; object in the client? And how would you model this in TypeScript?&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
