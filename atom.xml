<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2023-12-31T22:21:45.411Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Don&#39;t Write Traditional Getter and Setter Methods in JavaScript and TypeScript</title>
    <link href="https://effectivetypescript.com/2023/12/31/getters-setters/"/>
    <id>https://effectivetypescript.com/2023/12/31/getters-setters/</id>
    <published>2023-12-31T05:00:00.000Z</published>
    <updated>2023-12-31T22:21:45.411Z</updated>
    
    <content type="html"><![CDATA[<p>Say you want to create a class to represent a point in two-dimensional space. If you come from a <a href="https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">certain background</a>, your immediate instinct may be to create some private properties and <a href="https://dzone.com/articles/java-getter-and-setter-basics-common-mistakes-and">getter/setter methods</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point2D</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> x: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> y: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">getX</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setX</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getY</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setY</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This feels productive. You&#39;re writing code, after all! If you&#39;re feeling especially diligent, you might even write JSDoc comments for each of these methods. Your editor might even include shortcuts to write all these getters and setters for you.</p><p>Here&#39;s some code that uses that class:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> Point2D();<br>pt.setX(<span class="hljs-number">3</span>);<br>pt.setY(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(pt.getX(), pt.getY());  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>The downside is that this is a lot of boilerplate code that doesn&#39;t do very much. Why write the getters and setters rather than this?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectPoint2D</span> </span>&#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> DirectPoint2D();<br>pt.x = <span class="hljs-number">3</span>;<br>pt.y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(pt.x, pt.y);  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>At least in Java, the answer is that getters and setters encapsulate the implementation of the class and give it much greater flexibility to evolve in the future.</p><p>For example, what if you realize that for some reason it&#39;s much better to use <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a> internally? With the getters and setters, it&#39;s no trouble to reimplement the old API using the new internal representation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point2D</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> r: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> theta: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">getX</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getY</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setX</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">this</span>.getY();<br>    <span class="hljs-built_in">this</span>.r = <span class="hljs-built_in">Math</span>.sqrt(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">this</span>.theta = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setY</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-comment">// ... similar</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Users of the <code>Point2D</code> class will be completely oblivious to this internal change. The code above works without change. Contrast this with <code>DirectPoint2D</code>. You can&#39;t make an analogous change to this version because the internals are exposed. You can&#39;t get rid of the <code>x</code> and <code>y</code> properties without making a breaking change to the API. You&#39;re stuck.</p><p>That&#39;s the story in Java, anyway, and it was also the story for JavaScript in the 1990s and early 2000s. If you use <a href="https://github.com/google/closure-library/blob/7818ff7dc0b53555a7fb3c3427e6761e88bde3a2/closure/goog/ui/gauge.js#L473">very old JS libraries</a> (or libraries written by recent transplants from Javaland), you may still run across these sorts of getter and setter methods. After publishing my <a href="https://effectivetypescript.com/2023/09/27/closure-compiler/">post about Google&#39;s Closure Compiler</a> I <a href="https://news.ycombinator.com/item?id=37699258">learned</a> that one of its goals was to inline simple methods like these.</p><p>But getter and setter methods like these are <em>not</em> a good idea in modern JavaScript or TypeScript. The reason is that back in 2009, ES5 introduced a new syntax for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">get</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">set methods</a> that entirely eliminates this problem with direct property access.</p><p>Here&#39;s how you&#39;d migrate <code>DirectPoint2D</code> to a polar coordinates representation using getter and setter methods:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectPoint2D</span> </span>&#123;<br>  r = <span class="hljs-number">0</span>;<br>  theta = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">x</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">x</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">this</span>.y;<br>    <span class="hljs-built_in">this</span>.r = <span class="hljs-built_in">Math</span>.sqrt(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">this</span>.theta = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">y</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">y</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">// ... similar to set x</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Usage looks exactly as it did before:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> DirectPoint2D();<br>pt.x = <span class="hljs-number">3</span>;<br>pt.y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(pt.x, pt.y);  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>What were direct property accesses before have become method calls. But the syntax is character-for-character identical, so the caller need not be aware that anything has changed. The public properties are no longer a constraint on your class design.</p><p>The takeaway here is that it&#39;s OK to use a public property on a class in JavaScript and TypeScript. You may read warnings in books and online about how this is a bad practice, but this advice has more to do with specific limitations of Java and old-school JS than it does with modern JavaScript and TypeScript. When you write getter and setter methods in JavaScript, you&#39;re working around a problem that no longer exists.</p><p>Simple getter and setter methods are a code smell in JavaScript and TypeScript. Don&#39;t write them! If you see them in a code review, suggest replacing them with a public property and send your coworker here for an explanation of why.</p><p>One cautionary note: don&#39;t go too crazy with <code>get</code> and <code>set</code>. When you read code like <code>pt.x = 3</code>, you expect that this will do something like setting the <code>x</code> property of <code>pt</code> to <code>3</code>. Of course, with a <code>set</code> method, it <em>could</em> do anything. It could set <code>y</code> instead, or it could even issue a network request. But to avoid confusion and surprise, it&#39;s best if paired <code>get</code> and <code>set</code> methods get and set the same thing, at least conceptually.</p><p><em>Here&#39;s a complete <a href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAiCWAnApsALgBQPbwHZoCZZoBvAKGmkWgF5oAGAbgujQAtk0xaHmXgsuCGkQBXdFkQAKAB4AuaLlEBbAEbJEAGmgBPBUrUaAlKRaV28CADoZPGc0rm2lqzp46H0AL5kWAc05oGSkTckcqTlFEXFZna2oAKmgAWTB2KwEIKQtrdk4wI08fSghA4PlFFXVEULNoASE0XR4c108nF2o6VPSIAEdENFkEhIJoAGpdEYJCuta8rh4etis0sFwCKR1tGVnKH39AnRDTcJQ0KJjWxJS0lYg8bLirBYKi3xKjrf0q41PHBrCIItZ72ObPLq3XoDIYyaYTKajPaOeYcRbdO6rLgbLY7ZE+A6ApoAByadFwyAA7nAkKhMDh8EQpABmbQAFlmgKwIGQVhAWD8UlJNm0wp0syAA">playground link</a> for the last example if you want to give it a try.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Getter and setter methods (&lt;code&gt;getFoo&lt;/code&gt;, &lt;code&gt;setFoo&lt;/code&gt;) are common in Java and considered a best practice. But they&#39;re a code smell that&#39;s best avoided in JavaScript and TypeScript because the problem they solve in Java does not exist in JS/TS. This post looks at what that problem is and how you can solve it in TypeScript without imposing the boilerplate of getters and setters.&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Using infer to unpack nested types</title>
    <link href="https://effectivetypescript.com/2023/11/29/infer-deep/"/>
    <id>https://effectivetypescript.com/2023/11/29/infer-deep/</id>
    <published>2023-11-29T21:07:00.000Z</published>
    <updated>2023-11-29T21:08:33.435Z</updated>
    
    <content type="html"><![CDATA[<img src="https://effectivetypescript.com/images/magnifying-glass.png" width="128" height="128" alt="Inspecting a type with a magnifying glass" style="max-height: 100%; float: right"><p>In a <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">previous post</a> I suggested using intersections as a sort of type-level &quot;as any&quot;. I&#39;d personally found this technique useful on a few projects as a way of silencing type errors without losing type safety. Because you often needed to apply this trick two or three times for deeply nested types, it also led me to explore ways of <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">reducing repetition in type-level code</a>.</p><p>But when I started reworking that advice into an Item for the upcoming second edition of <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a>, I learned something interesting: there&#39;s usually a better way! TypeScript&#39;s <code>infer</code> keyword can infer quite a lot, and it offers a more direct way to achieve the same goals I talked about in those two posts without the repetition.</p><p>Those previous posts were motivated by my <a href="https://github.com/danvk/crosswalk">crosswalk</a> library, which helps you build and use type-safe REST APIs. Using <code>infer</code> works in that context, too, but the difference is even more dramatic when we look at an <a href="https://spec.openapis.org/oas/v3.1.0">OpenAPI Schema</a>.</p><p>Say your API lets you create a user. (It also lets you GET a user, but I&#39;ll only show the POST here since this is already verbose.) The OpenAPI Schema might look like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;openapi&quot;</span>: <span class="hljs-string">&quot;3.0.3&quot;</span>,<br>  <span class="hljs-string">&quot;info&quot;</span>: &#123; <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Users API&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1&quot;</span> &#125;,<br>  <span class="hljs-string">&quot;paths&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;/users&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;post&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;requestBody&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;content&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;application/json&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;schema&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;$ref&quot;</span>: <span class="hljs-string">&quot;#/components/schemas/CreateUserRequest&quot;</span><br>              &#125;<br>            &#125;<br>          &#125;,<br>          <span class="hljs-string">&quot;required&quot;</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;responses&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;200&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Newly-created User&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;application/json&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;schema&quot;</span>: &#123;<br>                  <span class="hljs-string">&quot;$ref&quot;</span>: <span class="hljs-string">&quot;#/components/schemas/User&quot;</span><br>                &#125;<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;components&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;schemas&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;CreateUserRequest&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span> &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;required&quot;</span>: [ <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span> ]<br>      &#125;,<br>      <span class="hljs-string">&quot;User&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;id&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span> &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;required&quot;</span>: [ <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span> ]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can run this through <a href="https://github.com/drwpow/openapi-typescript">openapi-typescript</a> to generate TypeScript types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** This file was auto-generated by openapi-typescript. */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> paths &#123;<br>  <span class="hljs-string">&quot;/users&quot;</span>: &#123;<br>    post: &#123;<br>      requestBody: &#123;<br>        content: &#123;<br>          <span class="hljs-string">&quot;application/json&quot;</span>: components[<span class="hljs-string">&quot;schemas&quot;</span>][<span class="hljs-string">&quot;CreateUserRequest&quot;</span>];<br>        &#125;;<br>      &#125;;<br>      responses: &#123;<br>        <span class="hljs-comment">/** <span class="hljs-doctag">@description <span class="hljs-variable">Newly</span></span>-created User */</span><br>        <span class="hljs-number">200</span>: &#123;<br>          content: &#123;<br>            <span class="hljs-string">&quot;application/json&quot;</span>: components[<span class="hljs-string">&quot;schemas&quot;</span>][<span class="hljs-string">&quot;User&quot;</span>];<br>          &#125;;<br>        &#125;;<br>      &#125;;<br>    &#125;;<br>    <span class="hljs-comment">// also get, etc.</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> components &#123;<br>  schemas: &#123;<br>    CreateUserRequest: &#123;<br>      name: <span class="hljs-built_in">string</span>;<br>      age: <span class="hljs-built_in">number</span>;<br>    &#125;;<br>    User: &#123;<br>      id: <span class="hljs-built_in">string</span>;<br>      name: <span class="hljs-built_in">string</span>;<br>      age: <span class="hljs-built_in">number</span>;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Accessing these types via the <code>path</code> structure involves a <a href="https://github.com/drwpow/openapi-typescript/tree/main/packages/openapi-typescript#basic-usage">whole bunch of indexing</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> UserResponse = paths[<span class="hljs-string">&quot;/users&quot;</span>][<span class="hljs-string">&quot;post&quot;</span>][<span class="hljs-string">&quot;responses&quot;</span>][<span class="hljs-number">200</span>][<span class="hljs-string">&quot;content&quot;</span>][<span class="hljs-string">&quot;application/json&quot;</span>];<br></code></pre></td></tr></table></figure><p>If you want to make a generic POST method, you&#39;ll quickly run into some errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>&lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">paths</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  endpoint: Path</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">paths</span>[<span class="hljs-title">Path</span>][&quot;<span class="hljs-title">post</span>&quot;][&quot;<span class="hljs-title">responses</span>&quot;][200][&quot;<span class="hljs-title">content</span>&quot;][&quot;<span class="hljs-title">application</span>/<span class="hljs-title">json</span>&quot;]&gt;</span>;<br><span class="hljs-comment">//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">// Type &#x27;&quot;application/json&quot;&#x27; cannot be used to index type &#x27;paths[Path][&quot;post&quot;][&quot;responses&quot;][200][&quot;content&quot;]&#x27;. (2536)</span><br></code></pre></td></tr></table></figure><p>This error makes sense: TypeScript has no reason to believe that this deep sequence of index operations will work on an arbitrary type.</p><p>You can use <code>infer</code> to extract just what you want out of this structure:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> HttpVerb = <span class="hljs-string">&#x27;get&#x27;</span> | <span class="hljs-string">&#x27;post&#x27;</span> | <span class="hljs-string">&#x27;patch&#x27;</span> | <span class="hljs-string">&#x27;delete&#x27;</span> | <span class="hljs-string">&#x27;update&#x27;</span>;<br><span class="hljs-keyword">type</span> ResponseForMethod&lt;Path <span class="hljs-keyword">extends</span> keyof paths, Verb <span class="hljs-keyword">extends</span> HttpVerb&gt; =<br>  paths[Path] <span class="hljs-keyword">extends</span> Record&lt;Verb, &#123;<br>    responses: &#123;<br>      <span class="hljs-number">200</span>: &#123;<br>        content: &#123;<br>          <span class="hljs-string">&#x27;application/json&#x27;</span>: infer ResponseType,  <span class="hljs-comment">// &lt;-- the &quot;infer&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;&gt; ? ResponseType : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>&lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">paths</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  endpoint: Path</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ResponseForMethod</span>&lt;<span class="hljs-title">Path</span>, &#x27;<span class="hljs-title">post</span>&#x27;&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> response = post(<span class="hljs-string">&#x27;/users&#x27;</span>);<br><span class="hljs-comment">//    ^? const response: Promise&lt;&#123; id: string; name: string; age: number; &#125;&gt;</span><br></code></pre></td></tr></table></figure><p>What surprised (and impressed me) was that <code>infer</code> can see right through the <code>Record</code> helper, which is a <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type">wrapper around a mapped type</a>.</p><p>If the endpoint doesn&#39;t support <code>POST</code> requests, you&#39;ll get a <code>never</code> type back. A type error would be better, but hopefully the <code>never</code> will be enough to alert the caller that something is amiss.</p><p>My <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">previous posts</a> would have suggested this <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">chain of helpers</a> instead:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><span class="hljs-keyword">type</span> LooseKey3&lt;T, K1, K2, K3&gt; = LooseKey&lt;LooseKey2&lt;T, K1, K2&gt;, K3&gt;;<br><span class="hljs-keyword">type</span> LooseKey4&lt;T, K1, K2, K3, K4&gt; = LooseKey&lt;LooseKey3&lt;T, K1, K2, K3&gt;, K4&gt;;<br><span class="hljs-keyword">type</span> LooseKey5&lt;T, K1, K2, K3, K4, K5&gt; = LooseKey&lt;LooseKey4&lt;T, K1, K2, K3, K4&gt;, K5&gt;;<br><br><span class="hljs-keyword">type</span> ResponseForMethod&lt;Path <span class="hljs-keyword">extends</span> keyof paths, Verb <span class="hljs-keyword">extends</span> HttpVerb&gt; =<br>  LooseKey5&lt;paths[Path], Verb, <span class="hljs-string">&#x27;responses&#x27;</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>&gt;;<br></code></pre></td></tr></table></figure><p>Yikes! Compared to this intersection form, the <code>infer</code> approach is more direct, easier to read and more closely matches the layout of the data. And if you need to extract multiple pieces of information from a type, it&#39;s clear how to do it. This is a nice win.</p><p>So is <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">&quot;intersect what you have with whatever TypeScript wants&quot;</a> still a useful technique? You sometimes need to write <code>&amp; string</code> when passing a type parameter to another generic type that expects a <code>string</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// see previous post</span><br><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ...;<br><span class="hljs-comment">// e.g. ExtractRouteParams&lt;&#x27;/users/:userId&#x27;&gt; = &#123;userId: string&#125;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiWrapper</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  apiGet&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path,<br>    queryParams: ExtractRouteParams&lt;Path&gt;,<br>    <span class="hljs-comment">//                              ~~~~</span><br>    <span class="hljs-comment">// Type &#x27;Path&#x27; does not satisfy the constraint &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//   Type &#x27;keyof API&#x27; is not assignable to type &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//     Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. (2344)</span><br>  ): <span class="hljs-built_in">Promise</span>&lt;GetResponseForMethod&lt;API, Path&gt;&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Check out <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> for a definition of <code>ExtractRouteParams</code>. The problem is that we expect <code>keyof API</code> to be a subtype of <code>string</code>, but strictly speaking all TypeScript knows is that it&#39;s a subtype of <code>PropertyKey</code>, aka <code>string | number | symbol</code>. There&#39;s nothing preventing <code>API</code> from being <code>string[]</code>, for example, in which case <code>keyof API = number</code>. Since <code>ExtractRouteParams</code> expects a <code>string</code>, this won&#39;t fly.</p><p>The best solution would be to tell TypeScript that <code>API</code> should only have <code>string</code> keys. But I&#39;m not aware of any way to do that: writing <code>ApiWrapper&lt;API extends Record&lt;string, any&gt;&gt;</code> results in the same error.</p><p>In this case, using an intersection to silence the error still makes sense:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiWrapper</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  apiGet&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path,<br>    queryParams: ExtractRouteParams&lt;Path &amp; <span class="hljs-built_in">string</span>&gt;,  <span class="hljs-comment">// ok</span><br>  ): <span class="hljs-built_in">Promise</span>&lt;GetResponseForMethod&lt;API, Path&gt;&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you&#39;re working with nested object types, remember that you can use <code>infer</code> to extract a particular type from deep inside them.</p><p><em>Image credit: <a href="https://commons.wikimedia.org/wiki/File:Magnifying_glass_icon_by_Manjiro5.svg">Wikimedia Commons</a></em></p>]]></content>
    
    <summary type="html">
    
      TypeScript&#39;s &lt;code&gt;infer&lt;/code&gt; keyword can infer quite a bit more than you might expect. It&#39;s extremely effective at extracting types from the sort of nested structures that you might get from codegen or an API specification.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Overload on the type of this to specialize generics (The Lost Item)</title>
    <link href="https://effectivetypescript.com/2023/10/27/specialize-this/"/>
    <id>https://effectivetypescript.com/2023/10/27/specialize-this/</id>
    <published>2023-10-27T14:50:00.000Z</published>
    <updated>2023-10-27T14:52:38.982Z</updated>
    
    <content type="html"><![CDATA[<p><em>I cut one item from <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> during the final stages of editing. Four years later, it&#39;s time for it to see the light of day! It&#39;s a trick for specializing generic types for certain subtypes of their type parameters. This post shows how it works, why it&#39;s indispensible for wrapper types, and also explains why I cut it from the book.</em></p><p>As you write type declarations for generic classes, you may find that you want to make some methods available only for particular values of the generic parameter. This often comes up with wrapper objects. In the lodash utility library, for example, you can rewrite a series of function calls:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_.sum(<br>  _.map(<br>    _.filter(<br>      _.split(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">Math</span>.PI, <span class="hljs-string">&#x27;&#x27;</span>),<br>      digit =&gt; digit !== <span class="hljs-string">&#x27;.&#x27;</span>),<br>    <span class="hljs-built_in">Number</span>));  <span class="hljs-comment">// result is 80</span><br></code></pre></td></tr></table></figure><p>into a <a href="https://lodash.com/docs/4.17.15#chain">chain</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_.chain(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">Math</span>.PI)<br>  .split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  .filter(<span class="hljs-function"><span class="hljs-params">digit</span> =&gt;</span> digit !== <span class="hljs-string">&#x27;.&#x27;</span>)<br>  .map(<span class="hljs-built_in">Number</span>)<br>  .sum()<br>  .value();  <span class="hljs-comment">// result is 80</span><br></code></pre></td></tr></table></figure><p>The call to <code>_.chain(val)</code> creates a wrapper object which is eventually unwrapped by a call to <code>.value()</code>. This reads more naturally since the execution order matches the code order: top to bottom, left to right.</p><p>Modeling this in TypeScript presents some challenges:</p><ul><li>The <code>split</code> method should only be available on wrapped strings.</li><li>The <code>filter</code> and <code>map</code> methods should only be available on arrays. (In the real lodash library they work on objects, too, but have different type signatures.)</li><li>The <code>sum</code> method should only be available on wrapped arrays of strings or numbers.</li></ul><p>For example, calling <code>map</code> on a wrapped number should be an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI)<br>  .map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~ map method not available</span><br></code></pre></td></tr></table></figure><p>You can start by defining the wrapper interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>(Since we&#39;re writing declarations here, we assume there&#39;s already an implementation defined elsewhere which may use different classes at runtime.)</p><p>You can verify that this wraps and unwraps values by writing a simple chain and inspecting the intermediate types in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI).value();<br>       <span class="hljs-comment">//  ----- (method) Wrapper&lt;number&gt;.value(): number</span><br></code></pre></td></tr></table></figure><p>As expected, this forms a <code>Wrapper&lt;number&gt;</code> and then unwraps it.</p><p>So what if you want to add a <code>map</code> method that&#39;s only available on arrays? If you add it directly to the <code>Wrapped</code> interface, it will be available on all wrapped objects, not just arrays. Perhaps a better approach is to create a specialized <code>ArrayWrapper</code> interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: T</span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T[]</span>): <span class="hljs-title">ArrayWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>You can verify that this gives the desired completions and errors in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI)  <span class="hljs-comment">// typing &quot;.&quot; offers &quot;value&quot; as the only completion</span><br>_(<span class="hljs-built_in">Math</span>.PI)<br>  .map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~ Property &#x27;map&#x27; does not exist on type &#x27;Wrapper&lt;number&gt;&#x27;.</span><br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">// typing &quot;.&quot; offers &quot;map&quot; and &quot;value&quot; completions</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v).value();  <span class="hljs-comment">// ok, type is string[]</span><br></code></pre></td></tr></table></figure><p>So far so good. Now let&#39;s add support for the <code>sum</code> method. You can add this to the <code>ArrayWrapper</code> interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  sum(): T;<br>&#125;<br></code></pre></td></tr></table></figure><p>and this will work, but it will also let you sum an array of <code>Date</code> objects to get a single <code>Date</code>, or an array of regular expressions to get a single regular expression. These should be errors.</p><p>You could try to model this out explicitly by creating more specialized interfaces:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: T</span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayOfNumbersWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;number&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayOfStringsWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;string&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-title">ArrayOfStringsWrapper</span></span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title">ArrayOfNumbersWrapper</span></span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T[]</span>): <span class="hljs-title">ArrayWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).sum().value();  <span class="hljs-comment">// ok, type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum();<br><span class="hljs-comment">//                           ~~~</span><br><span class="hljs-comment">//     Property &#x27;sum&#x27; does not exist on type &#x27;ArrayWrapper&lt;number&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>What went wrong? When you use <code>map</code> on an <code>ArrayOfNumbersWrapper</code>, the result reverts back to <code>ArrayWrapper&lt;number&gt;</code>, which doesn&#39;t have a <code>sum</code> method. You can patch this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ArrayOfNumbersWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;number&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>  map(mapFn: <span class="hljs-function">(<span class="hljs-params">v: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>): ArrayOfNumbersWrapper;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: <span class="hljs-built_in">number</span></span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum().value();  <span class="hljs-comment">// ok, type is number</span><br></code></pre></td></tr></table></figure><p>But this is a losing battle. There&#39;s always going to be some combination of method calls that your series of interfaces misses. This will be a frustrating experience for your users, since a TypeScript error will be only loosely correlated with a runtime error.</p><p>Taking a step back, this tracking of types through function calls is exactly what the TypeScript compiler does and is good at. It would be better to let it figure out that the wrapped type is <code>number[]</code> and provide the <code>sum</code> method in that case, rather than having to think of every possible way you could get a wrapped number array.</p><p>The trick to doing this is to specialize methods on the type of <code>this</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  <span class="hljs-comment">// Methods available for all types:</span><br>  value(): T;<br><br>  <span class="hljs-comment">// Methods available on arrays:</span><br>  map&lt;U, V&gt;(<span class="hljs-built_in">this</span>: Wrapper&lt;U[]&gt;, mapFn: <span class="hljs-function">(<span class="hljs-params">v: U</span>) =&gt;</span> V): Wrapper&lt;V[]&gt;;<br><br>  <span class="hljs-comment">// Methods available on specific types of arrays:</span><br>  sum(<span class="hljs-built_in">this</span>: Wrapper&lt;<span class="hljs-built_in">number</span>[]&gt;): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>  sum(<span class="hljs-built_in">this</span>: Wrapper&lt;<span class="hljs-built_in">string</span>[]&gt;): Wrapper&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><br>_(<span class="hljs-built_in">Math</span>.PI).value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v * v).value();  <span class="hljs-comment">// type is string[]</span><br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).sum().value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum().value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v + v).sum().value();  <span class="hljs-comment">// type is string</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v + v).map(<span class="hljs-built_in">Number</span>).sum().value();  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>Everything works! The type checker is indeed quite good at tracking types: even trickier cases we didn&#39;t cover before, like mapping from strings to numbers and back, work as expected. What&#39;s more, this code is significantly clearer than our previous attempts. There&#39;s only a single <code>Wrapper</code> interface. As you add more and more specialized methods, the returns on this simplicity compound.</p><p>The only downside is that the error you get from calling an unavailable method is a bit cryptic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI).map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~~~~~ The &#x27;this&#x27; context of type &#x27;Wrapper&lt;number&gt;&#x27; is not assignable</span><br><span class="hljs-comment">//         to method&#x27;s &#x27;this&#x27; of type &#x27;Wrapper&lt;&#123;&#125;[]&gt;&#x27;.</span><br><span class="hljs-comment">//         Type &#x27;number&#x27; is not assignable to type &#x27;&#123;&#125;[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>But at least there&#39;s an error. Hopefully there are enough details in it to make the user realize that the <code>map</code> method only applies to arrays.</p><p>If you ever find yourself building a complex series of interfaces to model behaviors in a type declarations file, ask whether you could model the same thing by specializing on a generic type parameter. Overloading on the type of <code>this</code> will let TypeScript do the hard work for you. It&#39;ll be more accurate and a whole lot simpler!</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Specify a narrower type for <code>this</code> to specialize generic methods in interfaces.</li><li>Avoid building elaborate series of wrapper types. TypeScript is better at this!</li></ul><h3 id="Why-was-this-cut-from-the-book"><a href="#Why-was-this-cut-from-the-book" class="headerlink" title="Why was this cut from the book?"></a>Why was this cut from the book?</h3><p>This item was inspired by Daniel Rossenwasser&#39;s <a href="https://www.reddit.com/r/javascript/comments/62f531/a_typed_chain_exploring_the_limits_of_typescript/dfn411v/">comment</a> on my 2017 blog post <a href="https://medium.com/@danvdk/a-typed-chain-exploring-the-limits-of-typescript-b50153be53d8">A typed chain: exploring the limits of TypeScript</a>. The technique is perfect for typing <code>_.chain</code> and other generic wrappers. So why did I cut it? It&#39;s a complex technique to motivate, and I struggled to think of any <em>other</em> situation where it would be useful. Complex and not that useful? Sounded like a good one to drop!</p><p>I don&#39;t think the technique of specializing on <code>this</code> is widely-known, so perhaps this blog post can inspire some creative new use cases! Have you every run across this trick? Do you have a use case? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      I cut one item from Effective TypeScript during the final stages of editing. Four years later, it&#39;s time for it to see the light of day! It&#39;s a trick for specializing generic types for certain subtypes of their type parameters. This post shows how it works, why it&#39;s indispensible for wrapper types, and also explains why I cut it from the book.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Saga of the Closure Compiler, and Why TypeScript Won</title>
    <link href="https://effectivetypescript.com/2023/09/27/closure-compiler/"/>
    <id>https://effectivetypescript.com/2023/09/27/closure-compiler/</id>
    <published>2023-09-27T20:45:00.000Z</published>
    <updated>2023-10-27T14:24:44.101Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/240px-Closure_logo.svg.png" title="Closure Tools Logo" width="100" height="100" style="float: right; margin-left: 10px;">Here&#39;s something that makes me feel old: in just six months, Gmail will celebrate its 20th anniversary. If you weren&#39;t actively developing web sites at the time, it&#39;s hard to capture just how revolutionary it was. This was a time when JavaScript was held in almost universally low regard. The idea that you could build a sophisticated web app using it was mind-boggling. But it clearly worked and it heralded the dawn of the single-page web app (SPA).</p><p>Behind this application was an exciting new tool that Google had built for creating large JavaScript applications: the <a href="https://github.com/google/closure-compiler">Closure Tools</a> (that&#39;s Closure with an &#39;s&#39;, not Clojure with a &#39;j&#39;, which is a different thing). This included the <a href="https://developers.google.com/closure/compiler/">Closure Compiler</a> (CC), a JavaScript source-to-source compiler that did type checking. Sound familiar?</p><p>Unless you&#39;ve worked on frontend at Google at some point in the past 20 years, it&#39;s unlikely that you&#39;ve ever encountered the Closure Compiler. It occupied a similar niche to TypeScript, but TypeScript has absolutely, definitively won.</p><p>Still, it&#39;s interesting to revisit CC for a few reasons:</p><ol><li>By looking at a system that made different high-level design decisions than TypeScript, we can gain a deeper appreciation of TypeScript&#39;s design.</li><li>It shows us missing features from TypeScript that it might not have even occurred to us to want.</li><li>It&#39;s an interesting case study in the history of JavaScript.</li></ol><p>In other words, the saga of the Closure Compiler gives us some perspective. TypeScript has become so ubiquitous that it&#39;s sometimes hard to imagine any other way of adding a type checker to JavaScript. The Closure Compiler shows us that the design space was larger than it looks in retrospect.</p><p>I wrote Closure-style JavaScript at Google most heavily from 2012–14. This post reflects Closure as it existed at that point. I&#39;m much less familiar with how it&#39;s evolved since then.</p><h2 id="What-is-the-Closure-Compiler"><a href="#What-is-the-Closure-Compiler" class="headerlink" title="What is the Closure Compiler?"></a>What is the Closure Compiler?</h2><p>TypeScript&#39;s motto is &quot;TypeScript is a superset of JavaScript&quot;. Closure code, on the other hand, <em>is</em> JavaScript. It doesn&#39;t add any new syntax to the language.</p><p>If you&#39;ve ever used <a href="https://www.typescriptlang.org/tsconfig#checkJs">TypeScript with <code>--checkJs</code></a>, it&#39;s a similar idea. Rather than adding types to JavaScript through new syntax, you add them via JSDoc-style comments.</p><p>Compare this TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>to the equivalent Closurized JavaScript:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">a</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">b</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>An invalid invocation of <code>max</code> will result in an error:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;max.js&quot;<br><br>max.js:12:16: WARNING - [JSC_TYPE_MISMATCH] actual parameter 1 of max does not match formal parameter<br>found   : string<br>required: number<br>  12| console.log(max(&#39;foo&#39;, &#39;bar&#39;));<br>                      ^^^^^<br><br>max.js:12:23: WARNING - [JSC_TYPE_MISMATCH] actual parameter 2 of max does not match formal parameter<br>found   : string<br>required: number<br>  12| console.log(max(&#39;foo&#39;, &#39;bar&#39;));<br>                             ^^^^^<br><br>0 error(s), 2 warning(s), 100.0% typed<br>function max(a,b)&#123;return a&gt;b?a:b&#125;console.log(max(&quot;foo&quot;,&quot;bar&quot;));<br></code></pre></td></tr></table></figure><p>This is similar to what <code>tsc</code> does in some ways but different in others. Just like <code>tsc</code>, it reports type errors in your code. And just like <code>tsc</code>, it outputs JavaScript (the last line). At a high level, type checking and JS emit are also the two things that TypeScript does.</p><p>There are some interesting differences, too. The Closure Compiler reports that our code is &quot;100.0% typed&quot;. Using TypeScript terminology, this is a measure of how many <code>any</code> types you have. (<a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> discusses using the <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> tool to get this information in Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety.)</p><p>The other interesting difference is that the output is minified. This gets us the fundamental design goal of the Closure Compiler: producing the smallest JavaScript possible.</p><h2 id="Minification-as-Design-Goal"><a href="#Minification-as-Design-Goal" class="headerlink" title="Minification as Design Goal"></a>Minification as Design Goal</h2><p>When Gmail came out back in 2004, network speeds were much, much slower than they are today. The Gmail team found that runtime JavaScript performance was almost irrelevant compared to download times (<em>Update: this isn&#39;t quite right, <a href="#updates">see below</a></em>). If you wanted to make your page load faster, you needed to make your JavaScript bundle smaller. So this is the central goal of the Closure Compiler and its &quot;advanced optimizations&quot; mode.</p><p>To see how this works, let&#39;s look at some code to fetch and process data from the network.</p><p>Here&#39;s an &quot;externs&quot; file (the CC equivalent of a type declarations file) that defines a type and declares a function:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api-externs.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typedef <span class="hljs-type">&#123;&#123;</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   foo: string,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   bar: number,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> * &#125;</span></span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> APIResponse;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@return <span class="hljs-type">&#123;APIResponse&#125;</span> </span>*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Some interesting things to note here:</p><ul><li>Types are introduced via <code>@typedef</code> in a JSDoc comment. The <code>APIResponse</code> symbol exists at runtime but is not particularly useful. Just because CC is JavaScript doesn&#39;t mean that the JavaScript always makes sense.</li><li>The declaration of <code>fetchData</code> includes an empty implementation. TypeScript would use <code>declare function</code> here, but this is not JS syntax. So CC uses an empty function body.</li></ul><p>Here&#39;s some more code that fetches data and processes it:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typedef <span class="hljs-type">&#123;&#123;</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   longPropertyName: string,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   anotherLongName: number</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> * &#125;</span></span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> ProcessedData;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;APIResponse&#125;</span> <span class="hljs-variable">data</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ProcessedData&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processData</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    longPropertyName: data.foo,<br>    anotherLongName: data.bar,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> apiData = fetchData();<br><span class="hljs-keyword">const</span> processedData = processData(apiData);<br><span class="hljs-built_in">console</span>.log(processedData.longPropertyName, processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Because it&#39;s just JavaScript, this code can be executed directly, presumably via a <code>&lt;script&gt;</code> tag (CC predates Node.js). No build step is required and your iteration cycle is very tight.</p><p>Let&#39;s look at what happens when you compile this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;--externs&quot; &quot;api-externs.js&quot; &quot;api.js&quot;<br><br>let ProcessedData;function processData(a)&#123;return&#123;longPropertyName:a.foo,anotherLongName:a.bar&#125;&#125;const apiData&#x3D;fetchData(),processedData&#x3D;processData(apiData);console.log(processedData.longPropertyName,processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Here&#39;s what that looks like when we unminify it:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ProcessedData;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processData</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        longPropertyName: a.foo,<br>        anotherLongName: a.bar<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> apiData = fetchData(), processedData = processData(apiData);<br><br><span class="hljs-built_in">console</span>.log(processedData.longPropertyName, processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Just like TypeScript, compilation here mostly consists of stripping out type information (in this case JSDoc comments).</p><p>Now look at what happens when we turn on &quot;advanced optimizations&quot;:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--compilation_level&quot; &quot;ADVANCED&quot; &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;--externs&quot; &quot;api-externs.js&quot; &quot;api.js&quot;<br><br>var a,b&#x3D;fetchData();a&#x3D;&#123;h:b.foo,g:b.bar&#125;;console.log(a.h,a.g);<br></code></pre></td></tr></table></figure><p>The output is <em>much</em> shorter. Here&#39;s what it looks like unminified:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b = fetchData();<br><br>a = &#123;<br>    h: b.foo,<br>    g: b.bar<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(a.h, a.g);<br></code></pre></td></tr></table></figure><p>This is a radical transformation of our original code. In addition to mangling our variable names (<code>apiData</code> became <code>b</code>, <code>processedData</code> became <code>a</code>), the Closure Compiler has mangled property names on <code>ProcessedData</code> (<code>longPropertyName</code>→<code>h</code>, <code>anotherLongName</code>→<code>g</code>) and inlined the call to <code>processData</code>, which let it remove that function entirely.</p><p>The results are dramatic. Whereas the minified code with simple optimizations was 231 bytes, the code with advanced optimizations is only 62 bytes!</p><p>Notice that CC has preserved some symbols: the <code>fetchData</code> function and the <code>foo</code> and <code>bar</code> property names. The rule is that symbols in an &quot;externs&quot; file are externally visible and cannot be changed, whereas the symbols elsewhere are internal and can be mangled or inlined as CC sees fit.</p><p>This is fundamentally unlike anything that TypeScript does. TypeScript does not rename symbols when it emits JavaScript nor does it attempt to minify your code. Even if you run your generated JavaScript through a minifier, it won&#39;t do anything nearly this radical. It&#39;s hard (or impossible) for a minifier to know which symbols or property names are part of an external API. So mangling property names is generally unsafe. You&#39;re unlikely to get anything smaller than the 231 byte &quot;simple optimizations&quot; output with TypeScript.</p><p>These results generally hold up well after gzip compression, and in larger projects as well. I <a href="https://github.com/danvk/dygraphs/pull/267">ported a JavaScript library to Closure</a> in 2013 and shrank my bundle by 40% vs. uglifyjs.</p><p>This is great stuff! So why didn&#39;t the Closure Compiler take off?</p><h2 id="The-Problems-with-Minification-as-a-Design-Goal"><a href="#The-Problems-with-Minification-as-a-Design-Goal" class="headerlink" title="The Problems with Minification as a Design Goal"></a>The Problems with Minification as a Design Goal</h2><p>The externs file was critical to correct minification. Without it, CC would have mangled the <code>fetchData</code> function name and the <code>foo</code> and <code>bar</code> properties, too, which would have resulted in runtime errors. Omitting a symbol from an externs file would result in incorrect runtime behavior that could be extremely difficult to track down. In other words, this was a really bad developer experience (DX).</p><p>CC introduced some extralinguistic conventions to deal with this. For example, in JS (and TS) there&#39;s no distinction between using dot notation and square braces to access a property on an object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> a = obj.property;<br><span class="hljs-keyword">const</span> b = obj[<span class="hljs-string">&#x27;property&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(a, b);  <span class="hljs-comment">// exact same</span><br></code></pre></td></tr></table></figure><p>This is not true with the Closure Compiler. Its convention is that quoted property access is preserved whereas dotted can be mangled. Here&#39;s how that code comes through the minifier with advanced optimizations:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(obj.g,obj.property);<br></code></pre></td></tr></table></figure><p>Note how the property names have diverged. In other words, while Closurized JavaScript is just JavaScript, it also kind of isn&#39;t.</p><p>There&#39;s another big problem with advanced optimizations: in order to consistently mangle a property name, CC needs to have access to all the source code that might use it. For this to be maximally effective, all the code you import must also be written with the Closure Compiler in mind, as must all the code that <em>that</em> code imports, etc.</p><p>In the context of npm in 2023, this would be impossible. In most projects, at least 90+% of the lines of code are third-party. For this style of minification to be effective, all of that code would have to be written with the Closure Compiler in mind and compiled by it as a unit.</p><p>On the other hand at Google in 2004, or 2012, or perhaps even today, that <em>is</em> quite realistic. At huge companies, the first- to third-party code ratio tends to be flipped. Using third-party code is more painful because there are legal and security concerns that come with it, as well as a loss of control. TypeScript&#39;s <a href="https://yarnpkg.com/package?name=typescript&file=%2Fpackage.json">zero runtime dependencies</a> are a good example of this.</p><p>All of Google&#39;s JavaScript was written with the Closure Compiler in mind and the vast majority of it is first-party. So advanced optimizations works beautifully. But the rest of the JS world doesn&#39;t operate that way. As soon as you pull in any dependencies like React or Lodash that aren&#39;t written with Closure Compiler in mind, it starts to lose its value.</p><p>Contrast this with TypeScript. It only needs to know about the <em>types</em> of existing libraries. This is all that&#39;s needed for type checking. The DefinitelyTyped project has been a monumental undertaking but it does mean that, generally speaking, you can get TypeScript types for almost any JS library. (There&#39;s a similar, though much smaller, set of <a href="https://github.com/google/closure-compiler/blob/929ba03a950b1dfcd60762f954e4833f433cc1d4/contrib/externs/jquery-1.12_and_2.2.js#L184">externs</a> to get type checking for popular JS libraries for the Closure Compiler.)</p><p>Stating it more directly: advanced optimizations requires that the compiler understand a library&#39;s implementation, not just its types, and that&#39;s simply infeasible given the enormous diversity of the JavaScript ecosystem.</p><!-- Mention my desire to use D3? --><h2 id="Timing-Is-Everything"><a href="#Timing-Is-Everything" class="headerlink" title="Timing Is Everything"></a>Timing Is Everything</h2><img src="https://effectivetypescript.com/images/closure-definitive-guide.jpg" title="Cover of Closure: The Definitive Guide (2010)" width="133" height="174" style="float: right; margin-left: 10px;"><p>Google developed Closure c. 2004 but it wasn&#39;t open sourced until <a href="http://googlecode.blogspot.com/2009/11/introducing-closure-tools.html">late 2009</a>. An O&#39;Reilly book on it, <a href="https://www.amazon.com/Closure-Definitive-Guide-Google-JavaScript/dp/1449381871">Closure: The Definitive Guide</a>, came out in 2010.</p><p>In retrospect this timing was terrible. In 2010, JavaScript was just entering its period of maximum churn. <a href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742"><em>JavaScript: The Good Parts</em></a> came out in 2008 and ES5 codified many of its recommendations in a new &quot;strict&quot; mode in 2009. Node.js was first released in 2009 and npm followed hot on its heels in 2010, creating the ecosystem of JavaScript packages we know today. npm grew significantly more powerful and useful when <a href="https://browserify.org/">browserify</a> made it applicable to client-side code starting in 2011.</p><p>And finally, <a href="https://coffeescript.org/">CoffeeScript</a> was released in 2010. It normalized the idea of compiling an &quot;improved&quot; JavaScript down to regular JavaScript, as well having a build step. All of these influenced the direction of JavaScript, with ES2015 bringing some of the best elements of CoffeeScript into the language itself.</p><p>The Closure Compiler was developed in the era when JavaScript was a &quot;bad&quot; language that was to be avoided. CC itself is implemented in Java, which made it harder to integrate into an all-JS toolchain. And it attempted to add missing parts to JavaScript. Since it couldn&#39;t add new syntax, it used special functions: <code>goog.provide</code> and <code>goog.require</code> provided a module system and <code>goog.inherits</code> <a href="https://developers.google.com/closure/library/docs/introduction#oop">smoothed out the process</a> of creating class hierarchies. These were real JavaScript functions that did something at runtime. If memory serves, <code>goog.require</code> might inject a <code>&lt;script&gt;</code> tag!</p><p>There were a few problems with this. One was that all the <code>goog</code> functions reinforced the idea that this was a tool primarily built for Google. Putting company names in your packages is common in Java, so presumably it felt natural for the Closure developers. But it&#39;s not in JavaScript. We just <code>import &#39;react&#39;</code>, not &quot;facebook/react&quot;.</p><p>Second, it made it awkward when JavaScript itself gained a module system and <code>class</code> keyword. TypeScript faced some of these problems in its early days, too. It used to have its own module system and class system, but in the interests of ecosystem coherence it deprecated them in favor of the native solutions. TypeScript now lets JavaScript be JavaScript and innovates only in the type system.</p><p>This transition happened early in TypeScript&#39;s history, but late in the Closure Compiler&#39;s. Presumably adaptation was harder.</p><h2 id="Why-TypeScript-won"><a href="#Why-TypeScript-won" class="headerlink" title="Why TypeScript won"></a>Why TypeScript won</h2><p>TypeScript came along at a better time and has been able to adapt to the changes in JavaScript and its ecosystem over the past decade. It&#39;s self-hosted (<code>tsc</code> is written in TypeScript) and distributed with npm.</p><p>TypeScript also won by focusing more on developer tooling. The Closure Compiler is an offline system: you run a command, it checks your program for errors, then you edit and repeat. I&#39;m not aware of any standard Closure language service. There&#39;s no equivalent of inspecting a symbol in your editor to see what CC thinks its type is. TypeScript, on the other hand, places as much emphasis on <code>tsserver</code> as <code>tsc</code>. Especially with Visual Studio Code, which is written in TypeScript and came out in 2015, TypeScript is a joy to use. TypeScript uses types to make you more productive whereas Closure used them to point out your mistakes. No wonder developers preferred TypeScript!</p><p>(Google engineers are no exception to this. In the past decade they&#39;ve <a href="https://neugierig.org/software/blog/2018/09/typescript-at-google.html">adopted TypeScript</a> and migrated to it en masse. You can read about one team&#39;s experience <a href="https://developer.chrome.com/blog/migrating-to-typescript/">porting Chrome Devtools from Closure to TypeScript</a>).</p><p>TypeScript did a better job of engaging the JavaScript community. TypeScript is developed and planned in the open on GitHub. They respond to bug reports from anyone and treat non-Microsoft users as important customers. The Closure Tools, on the other hand, were very much an open source release of an internal Google tool. Google was always the primary consumer and external users were mostly on their own. The <code>goog</code> namespacing reinforced this.</p><p>Closure&#39;s idea of &quot;it&#39;s just JavaScript&quot; was appealing because it let you avoid a build step. This remains appealing in 2023: some TypeScript users still prefer to use JSDoc-style type annotations and <code>--checkJs</code>. But using JSDoc for all types is awkward and noisy. Ergonomics do matter and TypeScript&#39;s are undeniably better.</p><p>Finally, TypeScript&#39;s central idea of &quot;JavaScript + Types&quot; has held up better than the Closure Tools&#39; idea of &quot;minification&quot; and &quot;it&#39;s just JavaScript&quot;. While shaving bytes off your bundle was all the rage in 2008, our connections are much faster now and, while bundle size still matters, it is not as critical as it was back then. Closure forced a uniform system on you and all your dependencies in order to achieve extreme minification. We&#39;ve given up that goal in exchange for more flexibility.</p><p>There&#39;s a general principle here. I&#39;m reminded of Michael Feathers&#39;s 2009 blog post <a href="https://michaelfeathers.silvrback.com/10-papers-every-developer-should-read-at-least-twice">10 Papers Every Developer Should Read at Least Twice</a> which discusses D.L. Parnas&#39;s classic 1972 paper &quot;On the criteria to be used in decomposing systems into modules&quot;:</p><blockquote><p>Another thing I really like in the paper is his comment on the KWIC system which he used as an example. He mentioned that it would take a good programmer a week or two to code. Today, it would take practically no time at all. Thumbs up for improved skills and better tools. We have made progress.</p></blockquote><p>The KWIC system basically sorts a text file. So are we correct to laud our progress as software developers? This would be a one-liner today:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">console</span>.log(<br>  fs.readFileSync(<span class="hljs-string">&#x27;input.txt&#x27;</span>)<br>  .split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>  .toSorted(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b))<br>  .join(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>But think about what makes this possible:</p><ul><li>We&#39;re assuming that the entire file fits in memory, which almost certainly would not have been true in 1972.</li><li>We&#39;re using a garbage collected language, which would have been a rarity back then.</li><li>We have an enormous library at our fingertips via node built-ins and npm.</li><li>We have great text editors and operating systems.</li><li>We have the web and StackOverflow: no need to consult a reference manual!</li></ul><p>All of these things are thanks to advances in hardware. The hardware people give us extra transistors and the software people take most of those for ourselves to get a nicer development process. So it is with faster network speeds and the Closure Compiler. We&#39;ve taken back some of that bandwidth in exchange for a more flexible development process and ecosystem.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>There were discussions of <a href="https://github.com/microsoft/TypeScript/issues/8">adding minification to TypeScript</a> in the early days but now optimized output is an explicit <a href="https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">non-goal</a> for the language. If you&#39;ve ever thought that type-driven minification would be a beautiful thing, the Closure Compiler is a fascinating data point. It can be tremendously effective, but it also comes at an enormous cost to the ecosystem.</p><p>The Closure Compiler as a standalone external tool seems mostly dead (the <a href="https://closure-compiler.appspot.com/home">closure playground</a> is badly broken and says &quot;Copyright 2009&quot;!). But it still lives on at Google. Since they&#39;ve adopted TypeScript, they can use the Closure Compiler for just what it does best: minification. To make this work, Google has built a tool, <a href="https://github.com/angular/tsickle">tsickle</a>, that makes TypeScript produce Closurized JavaScript. True to form, this tool is open source but pretty inscrutable to an outsider. It may be used by Angular but I couldn&#39;t tell.</p><p>Hopefully this was an interesting lesson in JavaScript history! The Closure Compiler represents an alternative path that the JavaScript ecosystem could have taken, with different principles and different tradeoffs.</p><p><a name="updates"></a><em>There&#39;s a <a href="https://news.ycombinator.com/item?id=37686633#37697339">lively discussion</a> of this article on Hacker News. In particular Paul Buchheit (the creator of Gmail!) <a href="https://news.ycombinator.com/item?id=37699258">points out</a> that runtime performance was very much a goal of the Closure Compiler and inlining/dead code removal was a way to achieve this. It&#39;s hard to get back in the pre-JIT IE6 mindset where every getter comes with a cost! I don&#39;t think this changes the conclusions of the article. Also, the Closure Compiler is not the <a href="https://en.wikipedia.org/wiki/Google_Web_Toolkit">Google Web Toolkit</a> (GWT).</em></p>]]></content>
    
    <summary type="html">
    
      This post looks at the Closure Compiler, Google&#39;s tool from the mid-2000s for adding types to JavaScript. It looks at how its focus on minification led to very different design choices than TypeScript, and how this and a few other factors led to TypeScript becoming the ubiquitous solution for JavaScript + types. The Closure Compiler represents an alternative path that JavaScript could have taken, and it gives us perspective on TypeScript as it exists today.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript and SQL: Six Ways to Bridge the Divide</title>
    <link href="https://effectivetypescript.com/2023/08/29/sql/"/>
    <id>https://effectivetypescript.com/2023/08/29/sql/</id>
    <published>2023-08-29T21:30:00.000Z</published>
    <updated>2023-09-27T20:31:36.483Z</updated>
    
    <content type="html"><![CDATA[<p>If you develop server code with TypeScript, you&#39;ll inevitably come up against the question of how to interact with your database. There&#39;s lots of type information in your database (the structure of the tables) and it&#39;s not immediately clear how to share that type information between the DB and TypeScript.</p><p>Over many years of working with TypeScript and <a href="https://www.postgresql.org/">Postgres</a>, one of the most popular open source databases, I&#39;ve developed some opinions and hard-earned knowledge. This post lays out the decision tree you face as you work with TypeScript and a database and presents my preferred techniques.</p><p>If you&#39;d like to watch in video form, I gave a <a href="https://portal.gitnation.org/contents/typescript-and-the-database-who-owns-the-types">30 minute talk on this</a> at last year&#39;s TS Congress. Watching it again 16 months later, I have to say that it&#39;s pretty good! It goes into more detail on each option than this post does. You can follow along with the <a href="https://docs.google.com/presentation/d/1OsLdyLMtJ79fvuylYgmjlCrPNS_NK9xIAXKqoAyW3SI/edit#slide=id.p">slides</a> and <a href="https://github.com/danvk/ts-sql-tscongress2022">sample repo</a> if you like.</p><p><a href="https://portal.gitnation.org/contents/typescript-and-the-database-who-owns-the-types"><img src="https://effectivetypescript.com/images/tscongress-talk.jpg" alt="Dan speaking at TS Congress April 22, 2022" style="max-height: 458px; max-width: 100%"></a></p><p>The DB Schema looks something like this:</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> book(<br>  id uuid <span class="hljs-keyword">DEFAULT</span> gen_random_uuid() <span class="hljs-keyword">PRIMARY</span> KEY,<br>  title <span class="hljs-type">varchar</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  publication_year <span class="hljs-type">integer</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>);<br></code></pre></td></tr></table></figure><h2 id="Raw-SQL-Hand-coded-types"><a href="#Raw-SQL-Hand-coded-types" class="headerlink" title="Raw SQL + Hand-coded types"></a>Raw SQL + Hand-coded types</h2><p>Say you write a query to fetch all the books in your database using <a href="https://node-postgres.com/">node-postgres</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: any[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.year);<br>&#125;<br></code></pre></td></tr></table></figure><p>This code has a bug: it should be <code>book.publication_year</code>, not <code>book.year</code>. But because the the query returns an <code>any</code> type, TypeScript hasn&#39;t been able to flag it. No problem, we&#39;ll just write out an <code>interface</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Book &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query&lt;Book&gt;(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.year);<br>  <span class="hljs-comment">//                           ~~~~ Property &#x27;year&#x27; does not exist on type &#x27;Book&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Voila! TypeScript flags the error and we can easily fix it by changing <code>year</code> to <code>publication_year</code>.</p><p>This <em>is</em> a big improvement over untyped code, and this tends to be the approach that developers fall into by default if they don&#39;t step back back and think about the problem of TypeScript and SQL.</p><p>But this approach also has a big problem: there&#39;s no <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">single source of truth</a>. If the database changes (say because of a migration) then our TypeScript types won&#39;t update. And nothing ensures that they types are accurate to begin with.</p><p>On the other hand, this approach has some strengths: it doesn&#39;t introduce any abstractions (you&#39;re just writing TypeScript and SQL) and it doesn&#39;t introduce any sort of build step into your project.</p><p><strong>Pros and Cons of Raw SQL and Hand-Coded Types</strong></p><ul><li>Pros<ul><li>Zero abstraction</li><li>You do get some type safety</li></ul></li><li>Cons<ul><li>Repetition between DB + TS</li><li>Types don&#39;t stay in sync:</li><li>No Single Source of Truth</li></ul></li></ul><h2 id="ORMs-TypeORM-Sequelize-Waterline-Prisma-…"><a href="#ORMs-TypeORM-Sequelize-Waterline-Prisma-…" class="headerlink" title="ORMs (TypeORM, Sequelize, Waterline, Prisma, …)"></a>ORMs (TypeORM, Sequelize, Waterline, Prisma, …)</h2><p>So you want a single source of truth. The first big question you have to ask is &quot;where is the source of truth?&quot; Since we&#39;re dealing with TypeScript and SQL, the two obvious choices are… TypeScript and SQL. If you want to make TypeScript your source of truth, then you&#39;ll be using an <a href="https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one">ORM</a>, aka an Object-Relational Mapper.</p><p>Here&#39;s how we might define a <code>Book</code> table using <a href="https://typeorm.io/">TypeORM</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Entity, PrimaryGeneratedColumn, Column &#125; form <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><br><span class="hljs-meta">@Entity</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>  id!: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  title!: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>(<span class="hljs-string">&#x27;integer&#x27;</span>, &#123;<span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span>&#125;)<br>  publication_year!: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeORM handles the messy business of converting this class to SQL for us. And now we can use the <code>Book</code> class in our code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> entityManager.find(Book);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.publication_year);<br>&#125;<br></code></pre></td></tr></table></figure><p>And we have types! There&#39;s a single source of truth. Another nice property of ORMs is that they can often generate migrations for you, so that you don&#39;t have to write the SQL out by hand.</p><p>On the downside, ORMs are the classic example of a <a href="https://en.wikipedia.org/wiki/Leaky_abstraction">&quot;leaky abstraction&quot;</a>. The theory with an ORM is that you can treat the database as an implementation detail and you can just work in TypeScript. But in practice, that doesn&#39;t really work. To use an ORM effectively, you need to know SQL, you need to know TypeScript, and you need to know how to use the ORM. If you want to fine tune the performance of a query, say, you&#39;ll wind up working with your ORM to try to produce a really specific SQL query, which is just adding overhead over writing the SQL query directly. And if you work in an environment where there are multiple users of your database, perhaps working with other languages, then they&#39;ll feel like second class citizens since the database certainly won&#39;t be an implementation detail for them.</p><p>Using an ORM <a href="https://www.reddit.com/r/typescript/comments/jcw28f/typeorm_sucks_something_i_wanted_to_talk_about/">won&#39;t make you popular</a> on Hacker News, but they are undeniably popular. You probably already know how you feel about them. Personally I&#39;m not a fan, but they are ubiquitous and you&#39;ll eventually find yourself working on a project that uses one.</p><p><strong>Pros and Cons of ORMs</strong></p><ul><li>Pros<ul><li>Keep your types &amp; DB in sync: single source of truth!</li><li>Generate migrations for you</li><li>Low boilerplate for simple queries</li><li>ORMs are undeniably popular</li></ul></li><li>Cons<ul><li>The classic &quot;leaky abstraction&quot;: You need to know SQL, TypeScript, <em>and</em> your ORM</li><li>Performance is confusing</li><li>They make other users of your DB second-class citizens</li><li>Lots more churn in ORMs than in databases</li></ul></li></ul><h2 id="Schema-Generator-e-g-pg-to-ts"><a href="#Schema-Generator-e-g-pg-to-ts" class="headerlink" title="Schema Generator (e.g. pg-to-ts)"></a>Schema Generator (e.g. pg-to-ts)</h2><p>So what if you&#39;re not going to use an ORM? Then your database will be the source of truth. But it&#39;s undeniably useful to have a TypeScript version of your database schema. So you can generate TypeScript from your live database. A tool that does this is called a Schema Generator, and they&#39;re an essential part of any system that uses the database as the source of truth.</p><p>The granddaddy in this space is <a href="https://github.com/PSYT/schemats">SchemaTS</a>, which got a lot of GitHub stars but was abandoned in 2018. So lots of people forked it. One popular one was <a href="https://github.com/SweetIQ/schemats">PyST/SchemaTS</a>, but that was abandoned in 2020. I needed to add some Postgres-specific features so I forked that one, updated it and re-released it as <a href="https://github.com/danvk/pg-to-ts">pg-to-ts</a>. Give it a star! 😊</p><p>The idea with pg-to-ts (or any other Schema Generator) is that you point it to your live database and it outputs a <code>dbschema.ts</code> file:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npx pg-to-ts generate -c <span class="hljs-string">&#x27;postgres://dbhost/database&#x27;</span> --output dbschema.ts<br></code></pre></td></tr></table></figure><p>Here&#39;s what the <code>dbschema.ts</code> file looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Table book</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Book &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BookInput &#123;<br>  id?: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>For each table in your database you get two types: one for a complete row (i.e. the result of a <code>SELECT</code> statement) and one with just the properties you need to insert a new row (note the optional fields).</p><p>You can use this to adapt the &quot;Raw SQL + Hand-coded types&quot; example code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Book &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query&lt;Book&gt;(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.publication_year);<br>&#125;<br></code></pre></td></tr></table></figure><p>This is exactly the same as the hand-coded version, except that we don&#39;t have to write the types by hand. Superficially this doesn&#39;t seem like a big change, but it&#39;s actually a huge win! In practice you&#39;d generate <code>dbschema.ts</code> on your CI to make sure it stays in sync with the database.</p><p>This does add a build step. But schemas tend to change less frequently than code, so in practice most changes don&#39;t require this step.</p><p>Another issue is that we still had to manually add the <code>Book</code> annotation to our query to get the desired type out. For a more complex query, you may wind up writing duplicating logic with complicated <code>Pick</code> expressions or new <code>interfaces</code> based on your <code>dbschema</code>.</p><p>Schema Generators are a key building block for other tools (more on that below), so if you&#39;re not using an ORM then you should absolutely use a Schema Generator.</p><p><strong>Pros and Cons of Schema Generators</strong></p><ul><li>Pros<ul><li>Keep your types &amp; DB in sync</li><li>Key building block (more on this later!)</li></ul></li><li>Cons<ul><li>Add a build step</li><li>Still have to manually add types to queries</li><li>Some DB types are hard to model in TS (e.g. integers)</li></ul></li></ul><h2 id="Query-Builder-e-g-knex-js"><a href="#Query-Builder-e-g-knex-js" class="headerlink" title="Query Builder (e.g. knex.js)"></a>Query Builder (e.g. knex.js)</h2><p>The next question to ask is whether you want to write raw SQL or use a query builder. Probably the most popular query builder for TypeScript is <a href="https://knexjs.org/">knex.js</a>. Here&#39;s what it looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; knex &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;knex&#x27;</span>;<br><span class="hljs-keyword">const</span> knexDb = knex(&#123; <span class="hljs-attr">client</span>: <span class="hljs-string">&#x27;pg&#x27;</span>, <span class="hljs-attr">connection</span>: <span class="hljs-string">&#x27;postgres://...&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> knexDb(<span class="hljs-string">&#x27;book&#x27;</span>).select();<br><span class="hljs-comment">//    ^? const books: Book[]</span><br></code></pre></td></tr></table></figure><p>A type! How does this work? Assuming you&#39;ve run <code>pg-to-ts</code> to generate a schema, you can tell Knex about it using a type declaration:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; knex &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;knex&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Book &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;knex/types/tables&#x27;</span> &#123;<br>  <span class="hljs-keyword">interface</span> Tables &#123;<br>    book: Book;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is the bridge between the Schema Generator and the Query Builder and it powers the type generation.</p><p>It&#39;s great that we get accurate types without having to write them out ourselves. You can generate much more complex queries using Knex.js and generally it will do a good job of inferring accurate types.</p><p>So what&#39;s the downside? Just as with ORMs, Query Builders are a classic example of a leaky abstraction. As your queries get more and more complicated, it becomes less clear that writing them with a query builder is any simpler than it would be to write them as raw SQL.</p><p><strong>Pros and Cons of Query Builders</strong></p><ul><li>Pros<ul><li>With schema generation, they get you accurate types for your queries.</li><li>Less context-switching between languages.</li><li>No added build step (beyond schema generation)</li></ul></li><li>Cons<ul><li>Another &quot;leaky abstraction&quot;: You need to know TS, SQL, <em>and</em> your Query Builder</li></ul></li></ul><h2 id="SQL-→-TS-e-g-PgTyped"><a href="#SQL-→-TS-e-g-PgTyped" class="headerlink" title="SQL → TS (e.g. PgTyped)"></a>SQL → TS (e.g. PgTyped)</h2><p>If you&#39;re not going to use a Query Builder, then you have another option: a tool reads your raw SQL queries, tests them against your live database and outputs types. This like a Schema Generator, but for your individual queries, not your database as a whole. The best example of this is <a href="https://github.com/adelsz/pgtyped">PgTyped</a>.</p><p>Here&#39;s what a query looks like with PgTyped:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; sql &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@pgtyped/query&#x27;</span>;<br><br><span class="hljs-keyword">const</span> getBooks = sql<span class="hljs-string">`SELECT * FROM book;`</span>;<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks.run(<span class="hljs-comment">/* query parameters */</span> <span class="hljs-literal">undefined</span>, dbPool);<br><span class="hljs-comment">//    ^? const books: any</span><br></code></pre></td></tr></table></figure><p>What? <code>any</code>!? What&#39;s the point of that?</p><p>With PgTyped you have another step: you need to run the <code>pgtyped</code> command to get types for your query:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ yarn run pgtyped -c config.json<br>Processing src/index.ts<br>Saved 1 query to src/index.types.ts<br></code></pre></td></tr></table></figure><p>PgTyped read our tagged SQL query, inspected it against our live database (configured in <code>config.json</code>) and produced a types file:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** Types generated for queries found in &quot;src/index.ts&quot; */</span><br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; parameters type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IGetBooksParams = <span class="hljs-built_in">void</span>;<br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; return type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IGetBooksResult &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; query type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IGetBooksQuery &#123;<br>  params: IGetBooksParams;<br>  result: IGetBooksResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>PgTyped has produced two <code>interface</code>s: one for query parameters (we have none, so this is <code>void</code>) and one for the results of our query. The third <code>interface</code> bundles these up for us. We can plug these back into our original code to get types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; sql &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@pgtyped/query&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; IGetBooksQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.types&#x27;</span>;<br><br><span class="hljs-keyword">const</span> getBooks = sql&lt;IGetBooksQuery&gt;<span class="hljs-string">`SELECT * FROM book;`</span>;<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks.run(<span class="hljs-comment">/* query parameters */</span> <span class="hljs-literal">undefined</span>, dbPool);<br><span class="hljs-comment">//    ^? const books: IGetBooksResult[]</span><br></code></pre></td></tr></table></figure><p>Since it runs against your live database, PgTyped doesn&#39;t require a DB Schema. But with TypeScript&#39;s structural typing system, the <code>IGetBooksResult</code> interface is compatible with <code>Book</code>, so you can freely interchange them. You may wish to wrap your query to consistently use the DB Schema type.</p><p>PgTyped shines with more complex queries. You can use any features of PostgreSQL and PgTyped will follow along. There&#39;s no abstraction here, you&#39;re just writing SQL.</p><p>What are the downsides? As with other non-ORM tools, PgTyped does add a build step that you&#39;ll need to run as part of your development flow and on your CI (to make sure your types and queries stay in sync). Sometimes the types you get back aren&#39;t perfect, there are some <a href="https://github.com/adelsz/pgtyped/issues/375">issues around nullability</a>. While the types are usually accurate, it can feel a little &quot;duck typey&quot; to have so many distinct but compatible types floating around. And finally, it&#39;s a lot of ceremony for simple queries like <code>SELECT * FROM book</code>.</p><p><strong>Pros and Cons of PgTyped</strong></p><ul><li>Pros<ul><li>You get types for your queries, however complex they are</li><li>Zero abstraction: you&#39;re just writing SQL</li></ul></li><li>Cons<ul><li>Not all types can be accurately derived this way (nullability issues)</li><li>Adds a build step</li><li>A little &quot;ducky&quot; w/o dbschema</li><li>Lots of fuss for simple queries</li></ul></li></ul><h2 id="SQL→TS-a-smidge-of-query-building-zapatos-databases-PgTyped-crudely-typed"><a href="#SQL→TS-a-smidge-of-query-building-zapatos-databases-PgTyped-crudely-typed" class="headerlink" title="SQL→TS + a smidge of query building (zapatos, @databases, PgTyped + crudely-typed)"></a>SQL→TS + a smidge of query building (zapatos, @databases, PgTyped + crudely-typed)</h2><p>Finally, we get to my preferred approach! A Schema Generator produces the best-looking types and a Query Builder works with that schema. PgTyped excels at complex queries where you&#39;d rather write raw SQL. So the idea here is to use a minimal, TypeScript-first query builder that won&#39;t tempt you into writing complex queries with it because it doesn&#39;t support them. You should be using PgTyped for those, anyway.</p><p>Enter: <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>!</p><p>crudely-typed (which I built at my <a href="https://www.sidewalklabs.com/">last job</a>) is a query builder that generates only relatively simple queries with a focus on working with your dbschema to get perfect types. Here&#39;s what it looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;TypedSQL&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crudely-typed&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;tables&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;  <span class="hljs-comment">// &lt;-- output of pg-to-ts</span><br><br><span class="hljs-keyword">const</span> typedSql = <span class="hljs-keyword">new</span> TypedSQL(tables);<br><span class="hljs-keyword">const</span> booksTable = typedSql.table(<span class="hljs-string">&#x27;book&#x27;</span>);<br><span class="hljs-keyword">const</span> getBooks = booksTable.select();<br><span class="hljs-comment">//    ^? const getBooks: (db: Queryable) =&gt; Promise&lt;Book[]&gt;</span><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks(dbPool);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br></code></pre></td></tr></table></figure><p>You still have to regenerate <code>dbschema.ts</code> when your DB Schema changes, but there&#39;s no build step or overhead for the simple queries that crudely-typed supports. These include the basic CRUD (Create, Read, Update, Delete) queries as well as some very minimal support for 1-1 joins. Because it knows about your DB Schema, you&#39;ll get nice-looking type signatures on your functions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> updateBook = bookTable.updateByPrimaryKey();<br><span class="hljs-comment">//    ^? const updateBook:</span><br><span class="hljs-comment">//          (db: Queryable, where: &#123; id: string; &#125;, update: Partial&lt;Book&gt;)</span><br><span class="hljs-comment">//          =&gt; Promise&lt;Book | null&gt;</span><br></code></pre></td></tr></table></figure><p>In practice this covers 90+% of the SQL queries that you run in most applications. For the remaining 10% you can fall back to using PgTyped. The net effect is that you have a single source of truth (your database) and you get accurate TypeScript types with relatively minimal fuss.</p><p>While I&#39;ve never personally used them, I believe <a href="https://jawj.github.io/zapatos/">zapatos</a> and <a href="https://www.atdatabases.org/">@databases</a> follow a similar approach.</p><p><strong>Pros and Cons of hybrid Schema Generator + Query Builder / PgTyped</strong></p><ul><li>Pros<ul><li>Zero abstraction/overhead for complex SQL queries (PgTyped)</li><li>Minimum fuss, dbschema types for simple queries (crudely-typed)</li></ul></li><li>Cons<ul><li>Adds a build step</li><li>You might be tempted to put logic in JS instead of SQL, i.e. run 10 crudely-typed queries instead of one SQL query.</li></ul></li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Here&#39;s the final decision tree from my <a href="https://docs.google.com/presentation/d/1OsLdyLMtJ79fvuylYgmjlCrPNS_NK9xIAXKqoAyW3SI/edit#slide=id.p">slides</a>:</p><img src="https://effectivetypescript.com/images/ts-sql-decision-tree.png" alt="Decision Tree for using TypeScript and SQL" style="max-height: 300px; max-width: 100%"><p>There are no perfect choices here. Depending on how you feel about ORMs and Query Builders, you&#39;ll wind up in a different place. Regardless, the key thing is to make a conscious, informed decision about how you want to combine TypeScript and SQL. However you do it, try to have a single source of truth.</p><p>The final, hybrid option is where I&#39;ve wound up after years of dealing with this problem. How do you like to work with databases in TypeScript? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      If you develop server code with TypeScript, you&#39;ll inevitably come up against the question of how to interact with your database. There&#39;s lots of type information in your database (the structure of the tables) and it&#39;s not immediately clear how to share that type information between the DB and TypeScript.

This post and its accompanying video present six ways to solve this problem and offer some advice gleaned from years of experience combining Postgres and TypeScript.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Recommendation Update: ✂️ Use knip to detect dead code and types</title>
    <link href="https://effectivetypescript.com/2023/07/29/knip/"/>
    <id>https://effectivetypescript.com/2023/07/29/knip/</id>
    <published>2023-07-29T14:20:00.000Z</published>
    <updated>2023-07-29T14:23:45.043Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR: Use <a href="https://github.com/nadeesha/ts-prune">ts-prune</a> is in maintenance mode. Use <a href="https://github.com/webpro/knip">knip</a> to find dead code instead. It&#39;s great!</p><span id="more"></span><p>Three years ago I <a href="https://effectivetypescript.com/2020/10/20/tsprune/">recommended</a> using <code>--noUnusedLocals</code> and <a href="https://github.com/nadeesha/ts-prune"><code>ts-prune</code></a> to find dead code and dead types in your projects. <code>ts-prune</code> worked well enough, but it&#39;s now in maintenance mode and won&#39;t be receiving updates. This is a fine decision and it&#39;s the responsible thing to do when you no longer plan to maintain an open source project (I sometimes <a href="https://github.com/danvk/dygraphs/issues/727">struggle</a> with this!).</p><p>While <code>ts-prune</code> was effective at its core job, it always had a few shortcomings: it couldn&#39;t detect <a href="https://github.com/nadeesha/ts-prune/issues/96">unused dependencies</a> or <a href="https://github.com/nadeesha/ts-prune/issues/97">mutually recursive dead code</a>. It also made no attempts to understand whether your test code was alive or dead. So when I noticed that <a href="https://www.joshuakgoldberg.com/">Josh&#39;s</a> <a href="https://github.com/JoshuaKGoldberg/template-typescript-node-package">template-typescript-node-package</a> was using a new tool called <a href="https://github.com/webpro/knip">Knip</a>, I was intrigued. Could this be the dead code removal tool of my dreams?</p><p>Basically, yes! <code>knip</code> uses the same sort of mark-and-sweep algorithm as <code>ts-prune</code> to find dead code (see my <a href="https://effectivetypescript.com/2020/10/20/tsprune/">previous post</a> for why this is what you want). But it&#39;s much more ambitious in the sorts of issues it tries to find:</p><ul><li>It will report unused <code>dependencies</code> and even <code>devDependencies</code> from your <code>package.json</code>. Removing these can be a huge win since it reduces your package size and eases the burden of keeping up to date with the latest versions.</li><li>It will report files that are never imported by non-test code.</li><li>It will report missing dependencies. This can happen if you depend on <code>A</code> which depends on <code>B</code>. You import something from <code>B</code> and it works, but you didn&#39;t list it in your dependencies. If you ever remove the dependency on <code>A</code>, this will be a problem. Best to depend on <code>B</code> directly if you use it directly.</li><li>It will report duplicate exports.</li><li>It will report unused class members and enum members.</li></ul><p>Because of the enormous diversity of JS/TS libraries and tools, you&#39;d expect that explaining your project setup to a tool like <code>knip</code> would involve writing a complicated configuration file. But that&#39;s usually not the case. knip&#39;s models this enormous diversity with an enormous collection of <a href="https://github.com/webpro/knip#plugins">plugins</a>. Chances are that your test runner and framework are already on the list.</p><p>Give <code>knip</code> a try! You might be surprised at the dead code you&#39;ve accumulated. You can use <a href="https://github.com/refstudio/refstudio/pull/225">this PR</a> as a template for setting it up in a project. Once you get down to zero errors, add <code>knip</code> to your CI to ensure that you never have dead code again!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL;DR: Use &lt;a href=&quot;https://github.com/nadeesha/ts-prune&quot;&gt;ts-prune&lt;/a&gt; is in maintenance mode. Use &lt;a href=&quot;https://github.com/webpro/knip&quot;&gt;knip&lt;/a&gt; to find dead code instead. It&amp;#39;s great!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Notes on TypeScript 5.1</title>
    <link href="https://effectivetypescript.com/2023/06/27/ts-51/"/>
    <id>https://effectivetypescript.com/2023/06/27/ts-51/</id>
    <published>2023-06-27T20:40:00.000Z</published>
    <updated>2023-06-27T20:41:34.046Z</updated>
    
    <content type="html"><![CDATA[<p>Every three months we get a new TypeScript release and <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/">TypeScript 5.1</a> landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&#39;s take a look!</p><span id="more"></span><h2 id="Performance-Improvements"><a href="#Performance-Improvements" class="headerlink" title="Performance Improvements"></a>Performance Improvements</h2><p>When you hear &quot;new TypeScript version&quot;, the natural tendency is to think about new language features. But what would you be more excited about: an exciting new feature like <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">template literal types</a> or a 10% faster compiler? Sorry, you can&#39;t have both!</p><p>The TypeScript team takes compiler performance incredibly seriously and every single set of release notes includes a few performance optimizations. A recent theme has been improving build times for projects that use complex libraries like Material-UI. The 5.1 release includes several <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#optimizations">optimizations</a> that add up to a big win.</p><p>As readers of this blog may recall, <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> is itself type-checked using <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. The idea is that when new versions of TypeScript come out, I can quickly check whether any of the hundreds of code samples in the book produce new and unexpected errors. This is a great confidence booster that my book still matches reality, but it also means that <em>Effective TypeScript</em> can serve as a good gauge of what&#39;s changed between releases.</p><p>First let&#39;s look at performance:</p><ul><li>Checking Effective TypeScript (TS 5.0.4): 180.6s average</li><li>Checking Effective TypeScript (TS 5.1.3): 170.9s average</li></ul><p>That&#39;s about a 5% speedup. Not bad!</p><h2 id="Improved-Error-Messages"><a href="#Improved-Error-Messages" class="headerlink" title="Improved Error Messages"></a>Improved Error Messages</h2><p>literate-ts is very sensitive to how error messages and types <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a>. TypeScript 5.1 includes a <a href="https://github.com/microsoft/TypeScript/issues/52934">nice change</a> in how type errors on <code>return</code> statements are displayed that didn&#39;t make it into the release notes. In previous versions of TypeScript, if you returned an expression of the wrong type, you&#39;d get the dreaded red squiggles under both the <code>return</code> keyword and the entire expression. For multiline expressions, this could be a lot of red!</p><img src="/images/red-return.png" alt="Code sample showing lots of red"><p>With TypeScript 5.1, the red squiggles only appear under the <code>return</code> keyword:</p><img src="/images/red-return-less-red.png" alt="Code sample showing much less red"><p>This is less distracting and makes it easier for you to inspect your code to find the source of the error. Not a huge change, but a nice win nonetheless. Next time you&#39;re debugging a type error in a <code>return</code> statement, thank Mateusz Burzyński for the <a href="https://github.com/microsoft/TypeScript/pull/52943">change</a>!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Upgrading TypeScript often uncovers existing mistakes in your code and TS 5.1 was no exception. There was one new error that came up in a few of my projects.</p><p>TypeScript has long flagged duplicate keys in object literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>    foo: <span class="hljs-number">12</span>,<br>    bar: <span class="hljs-number">34</span>,<br>    foo: <span class="hljs-number">56</span>,<br><span class="hljs-comment">//  ~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>But if you used <em>computed</em> keys, this error would go away:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> FOO = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">const</span> BAR = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,  <span class="hljs-comment">// (not an error in TS 5.0)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>With TS 5.1, this is an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,<br><span class="hljs-comment">// ~~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>This check only occurs for single-valued literal types.</p><!-- Error messages for `Expression4` have improved! --><!--Performance stats- TS 5.1.3:  - yarn verify  170.84s user 13.34s system 151% cpu 2:01.52 total (7/601 failed)  - yarn verify  171.54s user 13.09s system 151% cpu 2:01.72 total (4/601 failed)  - yarn verify  170.26s user 13.19s system 151% cpu 2:01.19 total (3/601 failed)- TS 5.0.4:  - yarn verify  180.57s user 13.05s system 145% cpu 2:12.67 total (3/601 failed)  - yarn verify  181.27s user 12.56s system 144% cpu 2:13.70 total (3/601 failed)  - yarn verify  180.83s user 13.00s system 145% cpu 2:12.92 total (3/601 failed)--><h2 id="Notes-on-other-changes"><a href="#Notes-on-other-changes" class="headerlink" title="Notes on other changes"></a>Notes on other changes</h2><p>The &quot;headline&quot; features in the official release notes for TS 5.1 are mostly niche changes that won&#39;t affect many users immediately. Here&#39;s a quick rundown:</p><ul><li><strong>Easier Implicit Returns for undefined-Returning Functions</strong> I&#39;ve never personally run across a function that was declared to return <code>undefined</code> rather than <code>void</code>. But if you work with such functions, your life gets easier with TS 5.1.</li><li><strong>Unrelated Types for Getters and Setters</strong> This <em>seems</em> like a bad idea though as the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#unrelated-types-for-getters-and-setters">CSS example</a> in the release notes makes clear, this is an established pattern in the wild that TypeScript needs to model. I tend to avoid getters and setters (and classes in general). This relates to <em>Effective TypeScript</em>&#39;s Item 29: Be Liberal in What You Accept and Strict in What You Produce.</li><li><strong>Decoupled Type-Checking Between JSX Elements and JSX Tag Types</strong> This seems quite in the weeds, but the gist is that it&#39;s future-proofing for async React components, which may land sometime in the future. When these eventually land, we&#39;ll be happy that TypeScript supports them out of the box.</li></ul><p>I was extremely excited about one other change in the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/#move-declarations-to-existing-files">TypeScript 5.1 RC</a> that sadly got cut for the release: a &quot;move to existing file&quot; refactor. There&#39;s a nice video of this in action in the RC release notes. This has been a long-standing and much-upvoted <a href="https://github.com/microsoft/TypeScript/issues/29988">feature request</a>. You can move a symbol to a <em>new</em> file, but not to an existing file.</p><p>I have a workaround, but it&#39;s a bit gross. Say you want to move a symbol to an existing file <code>src/utils/my-utils.ts</code>. Instead, move it to a new file <code>src/utils/new-file.ts</code>. This will update all the imports for the symbol to point to the new file. Then cut/paste the definition of your symbol into <code>my-utils.ts</code>, delete <code>new-file.ts</code> and run a big Find/Replace to update all the imports:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git ls-files | xargs perl -i -pe <span class="hljs-string">&#x27;s,new-file.ts,my-utils.ts,`</span><br></code></pre></td></tr></table></figure><p>Like I said, gross! Hopefully this feature lands more permanently in TypeScript 5.2.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>TypeScript 5.1 is not a major release when it comes to new language features, but it does include some performance wins, it may catch some new errors in your project, and it lays the groundwork for more changes in the future. Keep your eyes out for the TypeScript 5.2 beta which should be landing <a href="https://github.com/microsoft/TypeScript/issues/54298">any day now</a> and looks to have some <a href="https://www.totaltypescript.com/type-argument-placeholders-typescript-5-2-most-discussed-feature">exciting new features</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Every three months we get a new TypeScript release and &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/&quot;&gt;TypeScript 5.1&lt;/a&gt; landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&amp;#39;s take a look!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 30: Don’t Repeat Type Information in Documentation</title>
    <link href="https://effectivetypescript.com/2023/05/31/jsdoc-repeat/"/>
    <id>https://effectivetypescript.com/2023/05/31/jsdoc-repeat/</id>
    <published>2023-05-31T15:36:00.000Z</published>
    <updated>2023-06-26T16:02:57.861Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!</em></p><p>What’s wrong with this code?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string with the foreground color.</span><br><span class="hljs-comment"> * Takes zero or one arguments. With no arguments, returns the</span><br><span class="hljs-comment"> * standard foreground color. With one argument, returns the foreground color</span><br><span class="hljs-comment"> * for a particular page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> page === <span class="hljs-string">&#x27;login&#x27;</span> ? &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">127</span>&#125; : &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>The code and the comment disagree! Without more context it’s hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &quot;when your code and your comments disagree, they’re both wrong!&quot;</p><span id="more"></span><p>Let’s assume that the code represents the desired behavior. There are a few issues with this comment:</p><ul><li>It says that the function returns the color as a <code>string</code> when it actually returns an <code>&#123;r, g, b&#125;</code> object.</li><li>It explains that the function takes zero or one arguments, which is already clear from the type signature.</li><li>It’s needlessly wordy: the comment is longer than the function declaration <em>and</em> implementation!</li></ul><p>TypeScript’s type annotation system is designed to be compact, descriptive, and readable. Its developers are language experts with decades of experience. It’s almost certainly a better way to express the types of your function’s inputs and outputs than your prose!</p><p>And because your type annotations are checked by the TypeScript compiler, they&#39;ll never get out of sync with the implementation. Perhaps <code>getForegroundColor</code> used to return a string but was later changed to return an object. The person who made the change might have forgotten to update the long comment.</p><p>Nothing stays in sync unless it&#39;s forced to. With type annotations, TypeScript&#39;s type checker is that force! If you put type information in annotations and not in documentation, you greatly increase your confidence that it will remain correct as the code evolves.</p><p>A better declaration and comment might look like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123;<br>  r: <span class="hljs-built_in">number</span>;<br>  g: <span class="hljs-built_in">number</span>;<br>  b: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">/** Get the foreground color for the application or a specific page. */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Color</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>If you want to describe a particular parameter, use an <code>@param</code> JSDoc annotation. For more on this, see Item 48: Use TSDoc for API Comments.</p><p>Comments about a lack of mutation are also suspect. Don&#39;t just say that you don&#39;t modify a parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** Does not modify nums */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Instead, declare it <code>readonly</code> (See Item 17: Use readonly to Avoid Errors Associated with Mutation) and let TypeScript enforce the contract:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>What&#39;s true for comments is also true for variable names. Avoid putting types in them: rather than naming a variable <code>ageNum</code>, name it <code>age</code> and make sure it&#39;s really a <code>number</code>.</p><p>An exception to this is for numbers with units. If it&#39;s not clear what the units are, you may want to include them in a variable or property name. For instance, <code>timeMs</code> is a much clearer name than just <code>time</code>, and <code>temperatureC</code> is a much clearer name than <code>temperature</code>. Item 37 describes &quot;brands,&quot; which provide a more type-safe approach to modeling units.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst it will lead to conflicting information.</li><li>Consider including units in variable names if they aren&#39;t clear from the type (e.g., <code>timeMs</code> or <code>temperatureC</code>).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Chapter 4 of &lt;a href=&quot;https://amzn.to/3HIrQN6&quot;&gt;Effective TypeScript&lt;/a&gt; covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What’s wrong with this code?&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Returns a string with the foreground color.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Takes zero or one arguments. With no arguments, returns the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * standard foreground color. With one argument, returns the foreground color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * for a particular page.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getForegroundColor&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;page?: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; page === &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;login&amp;#x27;&lt;/span&gt; ? &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;&amp;#125; : &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;The code and the comment disagree! Without more context it’s hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &amp;quot;when your code and your comments disagree, they’re both wrong!&amp;quot;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A first look at Deno through the Advent of Code 2022</title>
    <link href="https://effectivetypescript.com/2023/04/27/aoc2022/"/>
    <id>https://effectivetypescript.com/2023/04/27/aoc2022/</id>
    <published>2023-04-27T21:00:00.000Z</published>
    <updated>2023-04-27T21:16:24.172Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">Every year I do the <a href="https://adventofcode.com/">Advent of Code</a> in a different programming language. If you aren&#39;t familiar, it&#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&#39;s a great way to learn a language and bond over coding. In <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">2019</a> I used Python, in <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">2020</a> I used Rust and in <a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/">2021</a> I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&#39;s 2022! (As a partial excuse, I have been writing on a <a href="https://danvk.org/catskills/">very different blog</a>!)</p><p>This past December I chose TypeScript, specifically <a href="https://deno.land">Deno</a>, which <a href="https://www.youtube.com/watch?v=1gIiZfSbEAE">brands itself</a> as &quot;a new way to TypeScript&quot;. While TypeScript certainly isn&#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.</p><p>This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&#39;s Advent of Code.</p><span id="more"></span><p>My code and more notes on each day&#39;s puzzles can be found on GitHub at <a href="https://github.com/danvk/aoc2022">danvk/aoc2022</a>.</p><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><p>Deno brands itself as a more secure JavaScript runtime that&#39;s more standards-compliant and easier to use. The comparison here is obviously Node.js. Deno was created by <a href="https://en.wikipedia.org/wiki/Ryan_Dahl">Ryan Dahl</a>, who also created Node.js, and it&#39;s fair to think of it as a &quot;take two&quot; on Node that avoids some of its questionable decisions.</p><p>Overall these claims hold up well. Deno is much easier to set up than Node: it already uses TypeScript, it has a built-in linter and formatter, and it comes with a system for unit tests. These are all things you <em>can</em> set up with Node, but it takes an extra step. That&#39;s a hurdle for beginners, and an opportunity for mistakes for all of us. For the most part, writing code in Deno feels just like writing TypeScript in any other environment, only with much less configuration.</p><p>(Just like a browser, Deno <a href="https://deno.com/manual@v1.32.1/advanced/typescript/overview">doesn&#39;t run your TypeScript directly</a>. It translates it to JavaScript first using <a href="https://swc.rs/">swc</a> and then runs that.)</p><p>Deno&#39;s sandboxing is a great security feature. Unless you specifically allow a capability (such as reading or writing to the file system), Deno won&#39;t allow it. This makes it safer to run programs that you download from the internet. Since I was running mostly my own code for the Advent of Code, in practice this meant that every solution started with this <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang line</a>:</p><pre><code>#!/usr/bin/env -S deno run --allow-read --allow-write</code></pre><p>Deno tries to embrace web standards to the extent that it makes sense. Rather than using a library to make HTTP requests, you use <code>fetch</code>, just like you would in a web browser. Perhaps the most notable example of this comes with dependencies. Rather than a <code>require</code> statement or running <code>npm install</code>, you depend on third-party libraries by using a standard ES <code>import</code> statement from a URL:</p><pre><code>import &#123; assert &#125; from &quot;https://deno.land/std@0.166.0/testing/asserts.ts&quot;;</code></pre><p>The version goes right there in the import URL. If you&#39;re used to npm, you probably have a few objections in your head right now! Rest assured, the Deno folks have thought through them:</p><ul><li>What if someone takes over deno.land and swaps in a malicious version of the library? You can use a <a href="https://deno.com/manual@v1.32.5/basics/modules/integrity_checking">lock file</a> for integrity checking.</li><li>Won&#39;t this be unwieldy? In practice, the Deno team recommends <a href="https://deno.com/manual@v1.32.5/basics/modules#it-seems-unwieldy-to-import-urls-everywhere">creating a <code>deps.ts</code> file</a> that consolidates all these imports in one place. This replaces <code>package.json</code>. It&#39;s a good example of Deno&#39;s preference using JS standards. I have some misgivings about this, though, see below.</li><li>What about dev dependencies? I haven&#39;t seen anything written about this explicitly, but I assume the suggestion is to have a <code>dev-deps.ts</code> file or some such.</li><li>Won&#39;t this cause an explosion of versions in transitive dependencies?</li></ul><p>To see why this might happen, imagine that module A depends on <code>lodash@4.17.20</code> and module B depends on <code>lodash@4.17.21</code>. With deno imports, you wind up with two versions of lodash:</p><p><img src="/images/aoc2022/deps-deno.png" alt="Dependencies in Deno yield two copies of lodash"></p><p>When you import from a URL that includes the full version, all your (transitive) dependencies are pinned. Node.js avoids this by specifying compatible ranges in dependencies. Perhaps A just requires <code>lodash&gt;=4</code> and B requires <code>lodash&gt;=4.10</code>. In that case, we can get down to a single version:</p><p><img src="/images/aoc2022/deps-node.png" alt="Dependencies in Node.js yield one copy of lodash"></p><p>The Deno answer to this dilemma is an <a href="https://deno.com/manual@v1.32.5/basics/import_maps">import map</a>, which lets you reach in and tweak the versions. Again, this is a <a href="https://github.com/WICG/import-maps">JavaScript standard</a>, but it feels a bit unwieldy. Would you actually do this to reduce the number of dependencies in your code? And how would you know which versions of <code>lodash</code> a module is compatible with unless it specifies.</p><p>I didn&#39;t personally run into any issues with this in the Advent of Code since I only had one or two dependencies. But projects I&#39;ve worked on professionally have had thousands, and I&#39;m nervous about any patterns that would lead to an even greater proliferation of dependencies. If you have experience building larger projects in Deno and have run into this (or not), I&#39;d love to hear about it in the comments.</p><p>I also have some concerns about the <code>deps.ts</code> system. It&#39;s clever to use a plain old TypeScript file as a <code>package.json</code> replacement in this way. But because it&#39;s a TypeScript file, my concern is that you&#39;ll be tempted to write real code in it, i.e. logic. Why is this a problem? Just look at the mess that is <code>setup.py</code> in Python land. In general it&#39;s impossible to know how a package is configured without executing <code>setup.py</code>, which could cause any number of side effects. This makes analysis harder, for example writing tools like dependabot. Simpler configuration enables more accurate, powerful tools. (<a href="https://deno.com/blog/v1.31#packagejson-support">Deno 1.31</a> added support for <code>package.json</code> to ease transitioning from Node but still recommends using import maps.)</p><p>While Deno works best when you import other Deno modules (from <code>deno.land</code>), the headline feature of <a href="https://deno.com/blog/v1.28">Deno 1.28</a> was support for npm modules. Here&#39;s what this looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; chalk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:chalk@5&quot;</span>;<br></code></pre></td></tr></table></figure><p>Easy, right? But what about TypeScript? Often the type declarations for npm libraries are hosted in a different package via DefinitelyTyped. I struggled mightily to get typings for lodash (see some <a href="https://stackoverflow.com/questions/64979829/deno-import-lodash-from-deno-land-x/66073607#66073607">crazy solutions</a> on Stack Overflow) before asking for help <a href="https://twitter.com/danvdk/status/1598502672319057925">on Twitter</a>. Here&#39;s where I wound up:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// @deno-types=&quot;npm:@types/lodash&quot;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> ld&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:lodash&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> _ = ld;<br></code></pre></td></tr></table></figure><p>So much for standards! But in fairness to Deno, once I had this magic in place I never had to think about it again.</p><p>Another pain point: I ran into <a href="https://github.com/denoland/deno/issues/17055">several</a> different <a href="https://github.com/denoland/deno/issues/17056">issues</a> with the VS Code extension, including one that changed my code to give me a wrong answer! To the Deno team&#39;s credit, they fixed both issues that I reported quickly, before Christmas. Deno is a relatively new project that is moving fast, but this also means you&#39;re more likely to run into glitches like this.</p><p>In the end, Deno is pretty nice to work with. If we were starting from scratch, it would be a much better choice than Node.js. But the Node/npm ecosystem has a ten year headstart on Deno, and I&#39;d like to give the npm integration story a bit more time to play out before I commit to using Deno on a larger project.</p><p>For a more glowing endorsement of Deno, see <a href="https://matklad.github.io/2023/02/12/a-love-letter-to-deno.html">A Love Letter to Deno</a> by <a href="https://matklad.github.io/">Alex Kladov</a>.</p><h2 id="TypeScript-JavaScript-for-Coding-Competitions"><a href="#TypeScript-JavaScript-for-Coding-Competitions" class="headerlink" title="TypeScript/JavaScript for Coding Competitions"></a>TypeScript/JavaScript for Coding Competitions</h2><p>TypeScript is a more natural fit for web programming and servers than for coding competitions, which are more the home turf for Python. So I was curious to see how doing AoC in TypeScript would feel.</p><p>JavaScript is famous for its <a href="https://en.wiktionary.org/wiki/footgun">footguns</a> and TypeScript/Deno inherit many of these. One of them got me on the <a href="https://adventofcode.com/2022/day/1">very first problem</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> sums = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>];<br>sums.sort();<br><span class="hljs-built_in">console</span>.log(sums);<br><span class="hljs-comment">// logs [1, 10, 2] -- the sort is lexicographic!</span><br></code></pre></td></tr></table></figure><p>Yes, this is one of many reasons why we always use lodash!</p><p>I&#39;d hoped that this year&#39;s Advent of Code would force me to play around more with <code>BigInt</code> (for huge numbers) and web workers (for parallelism), but neither of these proved to be necessary this year.</p><p>I did make extensive use of ES2015&#39;s <code>Set</code> and <code>Map</code> classes. These make amends for the &quot;original sin of JavaScript&quot;, namely the conflation of objects and associative arrays. While <code>Set</code> and <code>Map</code> do fix many of the issues with objects (accessing <code>prototype</code>, supporting non-<code>string</code> keys), they have some footguns of their own.</p><p>For example, I learned back in 2019 that a map with (x, y) tuples as keys is often a <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">more convenient way</a> to represent a grid than a 2D array. Python handles this pattern nicely with its built-in tuple type:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">grid = &#123;&#125;<br>grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">3</span><br>print(grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)])<br><span class="hljs-comment"># prints 3</span><br></code></pre></td></tr></table></figure><p>The equivalent in JS/TS doesn&#39;t work as you&#39;d hope:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], <span class="hljs-built_in">number</span>&gt;();<br>grid.set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs undefined</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>Map</code> and <code>Set</code> keys are (<a href="https://stackoverflow.com/questions/56195369/how-does-same-value-zero-algorithm-works">roughly</a>) compared using <code>===</code>, which tests for reference equality, not value equality:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br></code></pre></td></tr></table></figure><p>This situation will be improved greatly if the <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a> is ratified by TC39 (<a href="https://rickbutton.github.io/record-tuple-playground/#eyJjb250ZW50IjoiY29uc29sZS5sb2coI1sxLCAyXSA9PT0gI1sxLCAyXSk7XG5cbmNvbnN0IGdyaWQgPSBuZXcgTWFwKCk7XG5ncmlkLnNldCgjWzEsIDJdLCAzKTtcbmNvbnNvbGUubG9nKGdyaWQuZ2V0KCNbMSwgMl0pKTtcbiIsInN5bnRheCI6Imhhc2giLCJkb21Nb2RlIjpmYWxzZX0=">playground link</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">console</span>.log(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] === #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-comment">// logs true</span><br><br><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>grid.set(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs 3</span><br></code></pre></td></tr></table></figure><p>Here&#39;s hoping! Without this, my implementations of standard algorithms like <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">shortest path</a> required lots of <a href="https://github.com/danvk/aoc2022/blob/da3b5af9aef99cff8c1f739d07958d7c75a5794a/dijkstra.ts#L18-L19">serialization and deserialization code</a>.</p><p>Another JS/TS feature that I really embraced was Iterators and Generators. Say you have a <code>sum</code> function that takes an array of numbers:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>What if you want this to accept the output of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">squares</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">yield</span> n ** <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript will give you an error if you try to compose these:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));<br><span class="hljs-comment">//                 ~~~~~~~~~~ Argument of type &#x27;Generator&lt;number, void, unknown&gt;&#x27;</span><br><span class="hljs-comment">//                            is not assignable to parameter of type &#x27;number[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>Interestingly, though, this works at runtime and gives the correct answer (125)! To make it type check, we just need to loosen the parameter type for <code>sum</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: Iterable&lt;<span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Whenever I write functions that accept arrays now, I&#39;m going to ask &quot;could this take an Iterable instead?&quot; Often the answer is yes, and this gives you more flexibility in how you call the function. I found this particularly nice for callbacks that returned arrays, which are often cleaner to write as generators. See <a href="https://github.com/danvk/aoc2022/commit/c81b90e25db7617f42f8e78d6b76276f9c8a039c">this commit</a>.</p><p>Iterators are a great feature, but they are somewhat held back by their <a href="https://github.com/lodash/lodash/issues/737">lack of support</a> in lodash. There&#39;s a TC39 proposal to add <a href="https://2ality.com/2022/12/iterator-helpers.html">iterator helpers</a> to the standard library.</p><p>Because JavaScript doesn&#39;t have a built-in <a href="https://immutable-js.com/docs/v4.2.2/List/">deque</a> structure, I just used an <code>Array</code> in a very suboptimal way when I implemented <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. After wrapping up the whole competition, I tried <a href="https://github.com/danvk/aoc2022/compare/57c04a892ca52a1909d872e674984d557a59c86e...08f25f52ef4d018094a08df92c38dd8f15a87aae">plugging in</a> a priority queue. Suddenly some of my code ran 100x faster! Asymptotic performance: sometimes it matters!</p><p>Overall using TypeScript for the Advent of Code was OK but not great. It was a good excuse to try out a few new features of JavaScript, but it left me really wanting a few other proposals to get adopted!</p><h2 id="Advent-of-Code-2022"><a href="#Advent-of-Code-2022" class="headerlink" title="Advent of Code 2022"></a>Advent of Code 2022</h2><p>This was probably the easiest Advent of Code I&#39;ve done (easier than 2018, 2019, 2020, 2021). Again, there were no dependencies between days. There was also no matrix math, which was a change from previous years.</p><p>I usually do some kind of warmup project in a new language before day 1, traditionally implementing a <a href="https://github.com/danvk/rusty-boggle">Boggle Solver</a>. Since I&#39;d already implemented <a href="https://github.com/danvk/bogglets">Boggle in TypeScript</a>, I decided to do the first few puzzles of the 2018 Advent of Code instead. This was fun and very effective at preparing me for the 2022 Advent of Code. But it was a dangerous decision! Once I started the 2018 puzzles, I couldn&#39;t stop. So I wound up doing two Advents of Code simultaneously. This really highlighted that the 2018 Advent of Code was more difficult than 2022.</p><p>I tend to solve AoC problems in the morning: I&#39;m usually asleep well before midnight when they&#39;re posted on the east coast. But I&#39;d always been curious to try solving one at midnight to see what my global rank would be. I finally did it on day 15 this year. It was a roller coaster experience. Debugging while sleepy was unpleasant and really took me back to college. But I did manage to finish both parts before 1 AM and got my first-ever top 1000 finish:</p><p><img src="/images/aoc2022/rank-831.png" alt="Rank #831 on Day 15 part 2"></p><p>I was lucky -- had I tried this on day 16, which was much harder, I would have been up until 3 AM! Falling asleep after racing to solve a puzzle isn&#39;t easy.</p><p>I&#39;d hoped to stay up late enough to solve the final puzzle live. I was in Costa Rica at that point so it only would have been 11 PM and the Christmas is usually an easy puzzle. But by 10 PM I was in bed and couldn&#39;t keep my eyes open, so I just wrapped things up the next morning. I was finisher #5127 overall.</p><p>There were a few standout problems this year:</p><p><img src="/images/aoc2022/dans-cube.jpg" alt="My cube for day 222"></p><ul><li><a href="https://github.com/danvk/aoc2022#day-22-8786--4298">Day 22</a>: The Cube. Not hard, just very annoying. Though I did enjoy seeing photos of everyone&#39;s <a href="https://www.reddit.com/r/adventofcode/comments/zsct8w/2022_day_22_solutions/">cubes</a>.</li><li><a href="https://github.com/danvk/aoc2022#day-24-6284--6073">Day 24</a>: Blizzards, a fun application of Dijkstra where the state space isn&#39;t just your coordinate.</li><li><a href="https://github.com/danvk/aoc2022#day-20-7780--6961">Day 20</a>: Memorable for a pernicious off-by-one error.</li><li><a href="https://github.com/danvk/aoc2022#day-19-7649--6570">Day 19</a>: Robot Factories. This was the hardest one of the year for me. I never produced a fully correct solution, but I did discover <a href="https://en.wikipedia.org/wiki/Beam_search">beam search</a> which is something that will stick with me.</li><li><a href="https://github.com/danvk/aoc2022#day-16-6564--4162">Day 16</a>: Valves; this was probably the second hardest problem.</li><li><a href="https://github.com/danvk/aoc2022#day-9-31369--23800">Day 9</a>: Snake; really have to trust your implementation on this one. I was very glad to not have a bug!</li></ul><p>Overall, though, my favorite problem was probably <a href="https://adventofcode.com/2018/day/23">2018 day 23</a>.</p><p>So there you have it, Advent of Code 2022 in Deno. See you next December (or maybe April!).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;Every year I do the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt; in a different programming language. If you aren&amp;#39;t familiar, it&amp;#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&amp;#39;s a great way to learn a language and bond over coding. In &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;2019&lt;/a&gt; I used Python, in &lt;a href=&quot;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&quot;&gt;2020&lt;/a&gt; I used Rust and in &lt;a href=&quot;https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/&quot;&gt;2021&lt;/a&gt; I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&amp;#39;s 2022! (As a partial excuse, I have been writing on a &lt;a href=&quot;https://danvk.org/catskills/&quot;&gt;very different blog&lt;/a&gt;!)&lt;/p&gt;
&lt;p&gt;This past December I chose TypeScript, specifically &lt;a href=&quot;https://deno.land&quot;&gt;Deno&lt;/a&gt;, which &lt;a href=&quot;https://www.youtube.com/watch?v=1gIiZfSbEAE&quot;&gt;brands itself&lt;/a&gt; as &amp;quot;a new way to TypeScript&amp;quot;. While TypeScript certainly isn&amp;#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&amp;#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.&lt;/p&gt;
&lt;p&gt;This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&amp;#39;s Advent of Code.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Notes on TypeScript 5.0 beta</title>
    <link href="https://effectivetypescript.com/2023/02/07/ts-50-beta/"/>
    <id>https://effectivetypescript.com/2023/02/07/ts-50-beta/</id>
    <published>2023-02-08T01:50:00.000Z</published>
    <updated>2023-06-27T19:46:20.403Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">TypeScript 5.0 beta</a> came out on January 26, 2023. Let&#39;s take a look at what&#39;s new!</p><span id="more"></span><h2 id="Why-not-TypeScript-4-10"><a href="#Why-not-TypeScript-4-10" class="headerlink" title="Why not TypeScript 4.10?"></a>Why not TypeScript 4.10?</h2><p>First, a note on version numbers. With <a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning</a>, a change in the major version typically means breaking changes. And the number after 4.9 is 4.10, not 5.0. TypeScript doesn&#39;t really do semantic versioning. The whole <em>point</em> of new TypeScript releases is to find (existing) issues in your code. So in that sense, each release contains breaking changes.</p><p>Microsoft also counts in decimal. The version after 4.9 is 5.0, not 4.10. This causes some pain every tenth release since many packages on npm declare that they require <code>typescript@4.x</code>. This can either hold you back on an old version of TypeScript or lead to fragmentation, as I noticed with TypeScript 4.0 back in 2020:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">TIL I have five copies of <a href="https://twitter.com/typescript?ref_src=twsrc%5Etfw">@typescript</a> in node_modules! <a href="https://twitter.com/orta?ref_src=twsrc%5Etfw">@orta</a> was there much debate about whether the version after 3.9 was 3.10 or 4.0? In terms of branding and math, I agree it&#39;s 4.0. But since so many packages pin tsc@~3, this seems unnecessarily disruptive… <a href="https://t.co/FBiAxZBM15">pic.twitter.com/FBiAxZBM15</a></p>&mdash; Dan Vanderkam (@danvdk) <a href="https://twitter.com/danvdk/status/1319652924050595841?ref_src=twsrc%5Etfw">October 23, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>Why doesn&#39;t TypeScript do versioning in the usual way? The <a href="https://github.com/Microsoft/TypeScript/issues/14116">definitive answer</a> comes from TypeScript Tech Lead Ryan Cavanaugh:</p><blockquote><p>The trade-off for getting millions of dollars of engineering investment in the TypeScript project is that marketing gets to control version numbers to a certain extent.</p></blockquote><p>So there you go. Every 2.5 years we have to deal with this extra pain. At least marketing didn&#39;t decide that the version after 3.1 was 95!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Every new version of TypeScript has the potential to surface new errors in your code. As long-time readers of this blog know, the code samples in <em>Effective TypeScript</em> <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">are all type-checked</a>. One of the benefits of this is that when new TS versions come out, I can type-check my book against them. Sometimes I learn that <a href="https://twitter.com/danvdk/status/1414343269522227207">my book is out of date</a> and sometimes I <a href="https://twitter.com/danvdk/status/1513629136790634497">find new bugs in TypeScript</a>.</p><p>TypeScript 5.0 didn&#39;t surface any new errors in <em>Effective TypeScript</em>. Huzzah! 🎉</p><p>There <em>were</em> a few new errors in my work project. All of them involved <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#forbidden-implicit-coercions-in-relational-operators">comparing <code>string|number</code> to <code>number</code></a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">error TS2365: Operator &#39;&gt;&#x3D;&#39; cannot be applied to types &#39;string | number&#39; and &#39;number&#39;.<br><br>96       (val &gt;&#x3D; minVal) &amp;&amp;<br>          ~~~~~~~~~~~~~<br></code></pre></td></tr></table></figure><p>The full code looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (val &gt;= minVal &amp;&amp; val &lt;= maxVal) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here <code>val</code> has type <code>string | number</code> while <code>minVal</code> and <code>maxVal</code> have type <code>number</code>. JavaScript is notoriously eager to coerce types so that operations make sense:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; 10 &gt; &quot;9&quot;<br>true<br>&gt; 10 &gt; &quot;x&quot;<br>false<br></code></pre></td></tr></table></figure><p>Not helpful, JS! TypeScript has always barred comparisons between strings and numbers. Now the noose has tightened just a bit more and you may have to be more explicit about conversions.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>The TypeScript team claims a <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">10-20% speedup in build times</a> with TypeScript 5.0 beta. I was able to confirm this both on my work project (<a href="https://delve.sidewalklabs.com">Delve</a>) and in running literate-ts against <em>Effective TypeScript</em>:</p><ul><li>literate-ts / Effective TypeScript:<ul><li>TS 4.9.5: 194.12s</li><li>TS 5.0-beta: 181.31s (6.6% speedup)</li></ul></li><li>Delve:<ul><li>TS 4.9.5: 46.36s</li><li>TS 5.0-beta: 38.27s (17.5% speedup)</li></ul></li></ul><p>Compiler speed is <a href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/">important</a> and these are both welcome improvements! You can read the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">release notes</a> for more details on how these speedups were achieved.</p><h2 id="const-type-parameters"><a href="#const-type-parameters" class="headerlink" title="const type parameters"></a><code>const</code> type parameters</h2><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#const-type-parameters"><code>const</code> type parameters</a> are the one new language feature in this release. These are like <code>as const</code> but applied on the function declaration, rather than at the call site.</p><p>The applications I see for this in my own code are mostly small quality of life wins. For example, my work project has a <code>DropdownList</code> component that takes a list of options and a selected option. The list of options should be a tuple of string literals, and the selected option should be one of those literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    dropdownOptions=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>With TypeScript 5.0 we can move the <code>const</code> into the declaration of <code>DropdownList</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> DropdownList = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">const</span> <span class="hljs-attr">DropdownOption</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">string</span>&gt;</span>(</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    options: readonly DropdownOption[];</span><br><span class="xml">    selectedOption: DropdownOption;</span><br><span class="xml">  &#125;</span><br><span class="xml">) =&gt; &#123;</span><br><span class="xml">  // ...</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>And drop the <code>as const</code> at the callsite:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    options=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>]&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you inspect <code>options</code> here, you can see that its type is inferred as <code>readonly (&quot;Option A&quot; | &quot;Option B&quot; | &quot;Option C&quot;)[]</code> whereas before it would have been inferred as <code>readonly string[]</code>. Nice! If you factor the list of options out into a variable, though, the context will be lost and you&#39;ll be back to using <code>as const</code>.</p><p>What else is this useful for? Back in 2020 I talked about the <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/"><code>tuple</code> helper function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>[]&gt;</span>(...args: T): T =&gt; args;</span><br><br><span class="xml">const p1 = [1, 2];  // type is number[]</span><br><span class="xml">const p1 = tuple(3, 4);  // type is [number, number]</span><br></code></pre></td></tr></table></figure><p>What if we use a <code>const</code> type parameter on <code>tuple</code>? Interestingly, it becomes a sort of &quot;deep tuple&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tuple</span>&lt;<span class="hljs-title">const</span> <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">unknown</span>[]&gt;(<span class="hljs-params">...x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">const</span> coords1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br><span class="hljs-comment">//    ^? number[][]</span><br><br><span class="hljs-keyword">const</span> coords2 = tuple([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><span class="hljs-comment">//    ^? readonly [readonly [1, 2], readonly [3, 4], readonly [5, 6]]</span><br></code></pre></td></tr></table></figure><p>Is this useful? Maybe. There are always compelling applications of new language features and I&#39;m sure I&#39;m missing some here. Do you have a use for <code>const</code> type parameters? Let me know in the comments!</p><h2 id="Enums-are-unions"><a href="#Enums-are-unions" class="headerlink" title="Enums are unions"></a>Enums are unions</h2><p>In <em>Effective TypeScript</em> Item 53 (&quot;Prefer ECMAScript Features to TypeScript Features&quot;) I discourage using enums since they&#39;re not an ECMAScript feature and generally break the mold of how TypeScript relates to JavaScript (&quot;JavaScript + Types&quot;).</p><p>With TypeScript 5.0, enums become a little more sane. Whereas this <a href="https://www.typescriptlang.org/play?ts=4.9.5#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">was OK</a> in TypeScript 4.9:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> E &#123;<br>  a = <span class="hljs-number">1</span>,<br>  b = <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>It&#39;s <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">an error</a> in TypeScript 5.0:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;<br><span class="hljs-comment">//    ~ Type &#x27;30&#x27; is not assignable to type &#x27;E&#x27;. (2322)</span><br></code></pre></td></tr></table></figure><p>So are enums OK now? As it turns out, the newfound sanity is <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iiANsAC5QikDMADANyIDGA9iADOTYAC5YpEJxQB6GVD4BrKKIAUiIA">only surface deep</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> n = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> e: E = n;  <span class="hljs-comment">// ok :(</span><br></code></pre></td></tr></table></figure><p>TypeScript enums are complicated and problematic. While they become slightly saner with TypeScript 5.0, I still say &quot;avoid them.&quot;</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>There are more changes in the new release than what I&#39;ve written about here. Check out the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">release notes</a> for full details. With any luck, a release candidate (RC) will arrive on February 28th and the final cut of TypeScript 5.0 will be out on March 14th.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/&quot;&gt;TypeScript 5.0 beta&lt;/a&gt; came out on January 26, 2023. Let&amp;#39;s take a look at what&amp;#39;s new!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>All I Want for Christmas Is… These Seven TypeScript Improvements</title>
    <link href="https://effectivetypescript.com/2022/12/25/christmas/"/>
    <id>https://effectivetypescript.com/2022/12/25/christmas/</id>
    <published>2022-12-25T19:00:00.000Z</published>
    <updated>2022-12-25T20:26:56.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://freesvg.org/vector-clip-art-of-cartoon-presents-under-christmas-tree"><img src="https://effectivetypescript.com/images/christmas-tree.png" width="200" height="200" style="float: right" alt="Christmas tree with presents"></a> It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s <a href="https://adventofcode.com">Advent of Code</a> in Deno (look forward to a blog post in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?</p><h2 id="A-faster-language-service"><a href="#A-faster-language-service" class="headerlink" title="A faster language service"></a>A faster language service</h2><p>When you install TypeScript, you get two executables:</p><ul><li><code>tsc</code>, which checks your code for type errors and converts it to executable JavaScript</li><li><code>tsserver</code>, which provides language services for your editor.</li></ul><p>(This is discussed in Item 6 of <em>Effective TypeScript</em>: Use Your Editor to Interrogate and Explore the Type System.)</p><p>The faster these two programs can do their job, the happier you&#39;ll be as a developer. The TypeScript team is acutely aware of this: the release notes for new versions of TypeScript always talk about performance improvements in addition to new language features. The sluggishness of <code>tsc</code> remains a pain point for many developers, though. One of them even got so frustrated that he <a href="https://www.totaltypescript.com/rewriting-typescript-in-rust">decided to rewrite <code>tsc</code> in Rust!</a>.</p><p>Personally, I don&#39;t care much about the performance of <code>tsc</code>. I only tend to run as part of a continuous integration service or in &quot;watch&quot; mode without type checking via <code>webpack</code> or <code>ts-node</code>. The performance there is good enough for me.</p><p>What I <em>do</em> care about is the performance of <code>tsserver</code>. When you apply a refactor or change a type and have to wait for the red squiggly lines to catch up, that&#39;s <code>tsserver</code> being slow. Here&#39;s a GIF showing the language service having trouble keeping up:</p><img src="https://effectivetypescript.com/images/sluggish-ts-comment-with-user.gif" with=636 height=488 alt="A type error appearing and disappearing slowly after changing an import" style="max-height: 488px"><p>These performance issues impact your moment-to-moment experience of TypeScript: did that red squiggle go away because I fixed the error, or because I&#39;m waiting for <code>tsserver</code> to catch up? They&#39;re also hard to isolate for a bug report. If <code>tsc</code> is slow, I can point the TS team at my repo and report how long <code>tsc</code> takes to run. But to reproduce language server issues, you have to open a repo in your editor and then perform a particular action. It&#39;s not automated. And performance is inconsistent since it depends on caching.</p><p>So for 2023, I&#39;d love to see a faster <code>tsserver</code>. Maybe we should rewrite that in Rust, too!</p><h2 id="A-typed-pipe"><a href="#A-typed-pipe" class="headerlink" title="A typed pipe"></a>A typed <code>pipe</code></h2><p>When you compose several functions:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">f(g(h(x)))<br></code></pre></td></tr></table></figure><p>the functions are run in the right-to-left order: first <code>h</code> then <code>g</code> then <code>f</code>. This is counter to how code typically executes: top to bottom, left to right.</p><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">pipeline proposal</a> aims to offer a more readable alternative by introducing a new operator, <code>|&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">x<br>|&gt; h<br>|&gt; g<br>|&gt; f<br></code></pre></td></tr></table></figure><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">proposal page</a> has lots of great material about why this is a good idea and is well worth reading. Unfortunately, though, there are two competing operator proposals and I don&#39;t anticipate this making it into JavaScript (and hence TypeScript) anytime soon. Axel Rauschmayer&#39;s blog has a good writeup on the <a href="https://2ality.com/2022/01/pipe-operator.html">current state of things</a>.</p><p>There&#39;s an alternative, though: we can implement a function (commonly called <a href="https://ramdajs.com/docs/#pipe"><code>pipe</code></a>, or <a href="https://lodash.com/docs/4.17.15#flow"><code>flow</code></a> in lodash) that composes the functions in the order we expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n ** <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> add1 = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> halve = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> f = pipe(square, add1, halve, <span class="hljs-built_in">String</span>);<br><span class="hljs-comment">//    ^? (arg: number) =&gt; string</span><br><span class="hljs-keyword">const</span> x = f(<span class="hljs-number">2</span>);  <span class="hljs-comment">// &quot;2.5&quot;</span><br></code></pre></td></tr></table></figure><p>Here <code>square</code> is applied first, then <code>add1</code>, then <code>halve</code> and finally <code>String</code> to convert the number to a <code>string</code>.</p><p>This solves the pipelining problem nicely but it has a problem: it&#39;s impossible to type. For details, see this <a href="https://github.com/microsoft/TypeScript/pull/39094#issuecomment-647042984">Anders comment</a>. The issue is that there needs to be a relationship between each of the arguments to <code>pipe</code>: the parameter type of each argument needs to match the return type of the previous one. And this just can&#39;t be modeled with TS.</p><p>The lodash and Ramda typings resort to the classic <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#:~:text=like%20to%20call%20%E2%80%9C-,death%20by%20a%20thousand%20overloads,-%E2%80%9D%2C%20and%20it%20doesn%E2%80%99t">&quot;death by a thousand overloads&quot;</a> solution: define safe versions for a small number of arguments (<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/266cf9b006800a1de3836257443920b828c2e589/types/lodash/common/util.d.ts#L169-L204">seven</a> in lodash&#39;s case, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/76ebb1cce06b08cc5ef2f31d718fd84cb9df7cc6/types/ramda/index.d.ts#L1458-L1513">ten in Ramda&#39;s</a>) and give up on typing larger invocations.</p><p>This probably works fine in 99% of cases, but it doesn&#39;t feel right! I&#39;d love to see the TypeScript type system expand to be able to type <code>pipe</code>, or see some form of the pipeline operator proposal adopted.</p><h2 id="Records-and-Tuples"><a href="#Records-and-Tuples" class="headerlink" title="Records and Tuples"></a>Records and Tuples</h2><p>I&#39;m cheating here since this is more of a JavaScript Christmas wish. But JS is TS, right? The <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a>, currently at Stage 2, seeks to add two new data structures to JavaScript. As the proposal puts it:</p><blockquote><p>This proposal introduces two new deeply immutable data structures to JavaScript:</p><ul><li><code>Record</code>, a deeply immutable Object-like structure #{ x: 1, y: 2 }</li><li><code>Tuple</code>, a deeply immutable Array-like structure #[1, 2, 3, 4]</li></ul></blockquote><p>TypeScript already has a notion of tuple <em>types</em> (<code>[number, number]</code>). This proposal would add tuple values, which would neatly resolve a number of ambiguities in type inference.</p><p>For example, if you write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>then what should the type of <code>pt</code> be? It could be:</p><ul><li>a tuple type (<code>[number, number]</code>)</li><li>a readonly type (<code>readonly [number, number]</code>)</li><li>a mutable list (<code>number[]</code>)</li><li>an immutable list (<code>readonly number[]</code>)</li></ul><p>Without more information, TypeScript has to guess. In this case it infers the mutable list, <code>number[]</code>. You can use a <a href="https://stackoverflow.com/questions/66993264/what-does-the-as-const-mean-in-typescript-and-what-is-its-use-case">const assertion</a> (<code>as const</code>) to get (<code>readonly [number, number]</code>) or a <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/">typed identity function</a> to get one of the others.</p><p>With this proposal, you&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>and it would be unambiguous that you want a tuple type. This is just the tip of the iceberg: functional programming and static typing work much better when you don&#39;t have to worry about mutability (see Item 27 of <em>Effective TypeScript</em>: Use Functional Constructs and Libraries to Help Types Flow).</p><p>The other great thing about this proposal is that we&#39;d be able to use <code>===</code> to do structural comparisons between tuples and records:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br>&gt; #[1, 2] &#x3D;&#x3D;&#x3D; #[1, 2]<br>true<br></code></pre></td></tr></table></figure><p>The first comparison is <code>false</code> because the two arrays aren&#39;t the same object. Tuples have a more intuitive behavior. There is some risk of the Array / Tuple distinction being confusing, but Python has this and generally it works great.</p><p>We&#39;d also be able to use tuples as keys in <code>Set</code> and <code>Map</code> structures. This is top of mind because tuples would have been wildly useful in the Advent of Code this year (see my <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">2020 post</a> about using tuples as <code>dict</code> keys in Python).</p><h2 id="Optional-generics"><a href="#Optional-generics" class="headerlink" title="Optional generics"></a>Optional generics</h2><p>While building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> and <a href="https://github.com/danvk/crudely-typed">crudely-typed</a> libraries, I frequently ran into this situation: you have a function that takes several generic arguments, you want the user to provide one of them explicitly, but you want TypeScript to infer the others.</p><p>Here&#39;s an example of what this would like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeLookup</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">k: K</span>): (<span class="hljs-params">obj: T</span>) =&gt; <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">obj: T</span>) =&gt;</span> obj[k];<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> lookupName = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupName: (obj: Student) =&gt; string;</span><br><span class="hljs-keyword">const</span> lookupAge = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupAge: (obj: Student) =&gt; number;</span><br></code></pre></td></tr></table></figure><p>TypeScript doesn&#39;t let you do this. If you <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYGsCmAZOd0gAOAPACoA0iA0opgB5SZgAmAzolgJ5zCKkB8ACnQAuagEoxguACMAVmNLjEAXn58A2lQC6iAN4BYAFCJEAJ0xQQZpNPmLlaxLLkb02gNzGAvseMwwRjNgVAhMRABlK2YmKH1jUzBUZEwxVigzAIBzLxNEVCzUxDAQZBlMM1zfI2MIBHTEABs8AkIAOWTwlRQMHBaiYiiQGMChAHIklLHxXIB6WdNTAD0AfkQ6sAbm-CIOlKkXMSGRqEd1dMywHNr6uO3WgEFC1R6sXB2SY9jxgsxpuYWi1W61uTX6hCeRTsCki0ViZ2KpXKlSAA">try it on the TypeScript playground</a> you&#39;ll get this error: &quot;Expected 2 type arguments, but got 1.&quot; Generics are all or nothing.</p><p>I wrote about two workarounds back in 2020: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a>. But these are workarounds. I&#39;d really love to have a way to do this without having to change my API!</p><p>The canonical issue for this feature request is <a href="https://github.com/microsoft/TypeScript/issues/10571">#10571</a>. There was <a href="https://github.com/microsoft/TypeScript/pull/26349">some work on it in 2018</a> and I put up a <a href="https://github.com/microsoft/TypeScript/issues/42388">proposal</a> two years ago, but it hasn&#39;t seen much attention recently.</p><h2 id="quot-Evolving-quot-function-types"><a href="#quot-Evolving-quot-function-types" class="headerlink" title="&quot;Evolving&quot; function types"></a>&quot;Evolving&quot; function types</h2><p>TypeScript typically does a great job of inferring function parameter types from whatever context it has:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">//                            ^? (parameter) x: number</span><br></code></pre></td></tr></table></figure><p>The key point here is that you don&#39;t need to write <code>(x: number) =&gt; x ** 2</code>: TypeScript is able to infer that <code>x</code> is of type <code>number</code> from the types of <code>[1, 2, 3]</code> and the type of <code>Array.prototype.map</code>.</p><p>Now try factoring out a <code>square</code> function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Parameter &#x27;x&#x27; implicitly has an &#x27;any&#x27; type. (7006)</span><br><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(square);<br></code></pre></td></tr></table></figure><p>What worked so well in the first example completely fails here. This code is correct and is a simple refactor of the other code, but TypeScript demands a type annotation here. This is a frequent source of frustration in React components, where factoring out a callback can require writing out some very complex types. I wrote a blog post about this in 2019: <a href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/">How TypeScript breaks referential transparency…and what to do about it</a>.</p><p>Why doesn&#39;t TypeScript infer the type of <code>square</code> (and hence <code>x</code>) from its usage on the next line? Anders is famously skeptical of &quot;spooky action at a distance&quot; where changing code in one place can cause a type to change and produce errors in other places that aren&#39;t obviously related.</p><p>But it does have one limited form of this: &quot;evolving <code>any</code>&quot;, which is discussed in <em>Effective TypeScript</em> Item 41: <a href="https://effectivetypescript.com/2020/03/09/evolving-any/">Understand Evolving any</a>. The gist is that TypeScript will sometimes let the type of a symbol change based on subsequent usage:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> out = [];<br>out.push(<span class="hljs-number">1</span>);<br>out.push(<span class="hljs-number">2</span>);<br> out<br><span class="hljs-comment">// ^? const out: number[]</span><br></code></pre></td></tr></table></figure><p>I have a <a href="https://github.com/microsoft/TypeScript/issues/38083">three year old proposal</a> to expand this behavior to local function variables and make the <code>square</code> example valid. React developers around the world don&#39;t know that they want this feature for Christmas, but they do!</p><h2 id="ES-Module-clarity"><a href="#ES-Module-clarity" class="headerlink" title="ES Module clarity"></a>ES Module clarity</h2><p>The JavaScript world is finally moving to ES modules (<code>import</code> and <code>export</code>). I&#39;ve been blissfully ignoring some of the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#control-over-module-detection">changes</a> that Node.js and TypeScript have been making to support them, but I get the <a href="https://github.com/microsoft/TypeScript/issues/51302">sense</a> that this is an awkward transition for both of them. Hopefully we&#39;ll be through this by the end of 2023!</p><h2 id="A-canonical-types-→-runtime-path"><a href="#A-canonical-types-→-runtime-path" class="headerlink" title="A canonical types → runtime path"></a>A canonical types → runtime path</h2><p>One of the keys to really understanding TypeScript is recognizing that TypeScript types don&#39;t exist at runtime. They are <em>erased</em>. This is so fundamental that it&#39;s Item 1 in <em>Effective TypeScript</em> (&quot;Understand the Relationship Between TypeScript and JavaScript&quot;).</p><p>But sometimes you really do want access to your TypeScript types at runtime, perhaps to do validation on untrusted inputs. There&#39;s a proliferation of libraries that let you define types in JavaScript and derive TypeScript types from them: <a href="https://github.com/colinhacks/zod">zod</a>, <a href="https://github.com/jquense/yup">yup</a>, <a href="https://github.com/gcanti/io-ts">io-ts</a> and <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">React PropTypes</a> are just a few. Here&#39;s how you&#39;d define a <code>Student</code> type with Zod, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Student = z.object(&#123;<br>  name: z.string(),<br>  age: z.number(),<br>&#125;);<br><br><span class="hljs-keyword">type</span> Student = z.infer&lt;<span class="hljs-keyword">typeof</span> Student&gt;;<br><span class="hljs-comment">// type Student = &#123; name: string; age: number; &#125;</span><br></code></pre></td></tr></table></figure><p>The advantage of defining a type in this way (rather than with a TypeScript <code>interface</code>) is that you can do runtime validation using the <code>Student</code> value (which you cannot do with the <code>Student</code> <em>type</em>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> missingAge = Student.parse(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bobby&quot;</span>&#125;);<br><span class="hljs-comment">// throws an error at runtime.</span><br></code></pre></td></tr></table></figure><p>I prefer a different approach, though. TypeScript already has a great language for defining types and the relationships between them. Why learn another one? In <a href="https://github.com/danvk/crosswalk">crosswalk</a>, I use <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a> to generate JSON Schema from my TypeScript type declarations. This JSON Schema is used to validate requests and generate Swagger/OpenAPI documentation.</p><p>But again, all these approaches are workarounds for the root issue: there&#39;s no way to get access to a TypeScript type at runtime. I&#39;d love it if there were a canonical solution to this problem, so that we could all use the same solution. Perhaps <a href="https://2ality.com/2022/10/javascript-decorators.html">decorators</a> can help.</p><p>This would be a big change for TypeScript, and would generally go against its design philosophy. So while I have some hope for my other wishes, I have very little hope for this last one.</p><hr><p>Would you be excited about any of these changes? What&#39;s on the top of your TypeScript Christmas list? Let me know in the comments or <a href="https://twitter.com/danvdk">on Twitter</a>.</p>]]></content>
    
    <summary type="html">
    
      It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s Advent of Code in Deno (look forward to a blog post in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>What&#39;s TypeScript compiling? Use a treemap to find out.</title>
    <link href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/"/>
    <id>https://effectivetypescript.com/2022/07/30/treemap-for-source-files/</id>
    <published>2022-07-30T18:30:00.000Z</published>
    <updated>2022-07-30T18:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>What would you be most excited to see in the next set of TypeScript <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/">release notes</a>? Perhaps a fancy new language feature that makes generic types <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">more powerful</a>? A new way to do <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">type inference</a>? Or maybe a <a href="https://github.com/microsoft/TypeScript/issues/29988">new refactor</a> in the language service?</p><p>Now would you rather have that shiny new feature, or would you rather have TypeScript build your code 20% faster? In terms of your daily happiness and productivity, the speedup will almost certainly be the bigger win.</p><p>TypeScript performance is an important and sometimes frustrating part of the developer experience. Projects tend to start small and fast, but as they grow, type checking (<code>tsc</code>) and editor interactions (<code>tsserver</code>) get slower and TypeScript becomes less of a joy to use.</p><p>How can you make TypeScript run faster? Microsoft has a <a href="https://github.com/microsoft/TypeScript/wiki/Performance">guide</a> to TypeScript performance, and that&#39;s a great place to start. This post will talk about one particularly easy and effective way to debug performance issues: looking at what TypeScript is compiling using a treemap visualization.</p><p>Before we get started, let&#39;s be clear what we mean by performance. This is <em>not</em> the runtime performance of your code. For the most part, TypeScript is compiled to JavaScript by stripping out all the type annotations. So it cannot affect the runtime performance of your code. (If you see claims that TS affects runtime performance, for example this <a href="https://hackaday.com/2021/11/18/c-is-the-greenest-programming-language/">notoriously shoddy</a> paper, be very skeptical!) When I say &quot;performance&quot;, I mean compiler performance and language service performance: How long does it take <code>tsc</code> to compile your code and report type errors? And how long does it take after you edit a source file for errors to appear and disapper in your editor? These affect developer experience (DX) directly, but not user experience (UX).</p><p>One of the best ways to be fast is to do less stuff. In the case of TypeScript, that means compiling fewer lines of code.</p><p>The <code>tsc</code> command has a handy <code>--listFiles</code> option that will show you exactly what it&#39;s looking at when it compiles your code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ tsc --listFiles<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2015.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2016.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2017.d.ts<br>...<br></code></pre></td></tr></table></figure><p>If TypeScript has gotten sluggish on your project, then you should look at this list! There might be source files that surprise you.</p><p>For a large project, this list can include thousands of source files, so you&#39;ll want some way to visualize it. My preferred approach is a <a href="https://en.wikipedia.org/wiki/Treemapping">treemap</a>, which you can quickly generate using the <a href="https://www.npmjs.com/package/webtreemap-cli">webtreemap-cli</a> package. Since <code>tsc</code> will spend more time on a large file than a small file, we&#39;ll want to visualize the number of bytes in each file being compiled.</p><p>Here&#39;s the magic incantation (see <a href="https://unix.stackexchange.com/a/22227/139786">here</a> for the &quot;stat&quot; syntax):</p><pre><code># macOS / BSDtsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli# Linux:tsc --noEmit --listFiles | xargs stat -c &quot;%s %n&quot; | npx webtreemap-cli</code></pre><p>For my project, here&#39;s what that looks like:</p><img src="https://effectivetypescript.com/images/googleapis-treemap.png" alt="Treemap visualization showing googleapis contribution 80MB of source" style="max-height: 458px; max-width: 100%" /><p>First off: that&#39;s a <em>lot</em> of code! Over 111 megabytes. With that much source to churn through, it&#39;s no wonder TypeScript has gotten sluggish.</p><p>Second: my project is mostly <code>googleapis</code>? That&#39;s surprising. We do use the Google Cloud Storage API and the Google Sheets API, but that&#39;s it. And yet <code>tsc</code> reports that it&#39;s pulling in 80+ MB of Google APIs, including multiple versions of APIs that I never use (e.g. compute alpha, beta, v1).</p><p>This is exactly the sort of insight that treemaps are good at producing! Before I saw that visualization, I hadn&#39;t thought much about my project&#39;s usage of <code>googleapis</code>. Now I can&#39;t think about anything else!</p><p>The root issue here is that Google distributes all 300+ of its APIs as a single npm package. This has been a <a href="https://github.com/googleapis/google-api-nodejs-client/issues/806">long-standing issue</a> with Google&#39;s Node.js APIs. Fortunately for us, the issue was <a href="https://github.com/googleapis/google-api-nodejs-client/pull/2557">recently fixed</a>! Google now publishes individual packages for each API. Instead of depending on all of <code>googleapis</code>, you can now depend on just <code>@googleapis/sheets</code>.</p><p>After this change, the treemap for my project looks substantially different:</p><img src="https://effectivetypescript.com/images/treemap-after.png" alt="Treemap showing many fewer googleapis" style="max-height: 459px; max-width: 100%"/><p>The most important change is the top-line number: there&#39;s 80MB (70%) less source code for <code>tsc</code> to churn through. It&#39;s interesting to note that many of the large blocks that remain (<code>@octokit</code>, <code>csstype</code>, <code>firestore</code>) have the same problem as <code>googleapis</code>, if less egregiously so: they ship a single giant source file containing every API you could ever depend on.</p><p>Now for the big question… did this make my build faster? At least in this case, the answer is a clear &quot;yes&quot;. I ran:</p><pre><code>time tsc --noEmit --incremental=false</code></pre><p>five times before and after my change. The average time went from 35.7s → 28.9s, a 20% speedup. Not bad! And while it&#39;s harder to measure language service (<code>tsserver</code>) performance, one hopes that this change will help there, too. It&#39;s notable that the 20% speedup doesn&#39;t match the 70% reduction in source code. Just reading all those unused type declarations doesn&#39;t take as much time as type checking the code that is used. Still, this is a nice win.</p><p>Try running the magic command to visualize your TypeScript code as a treemap. You might be surprised what&#39;s making it into your build!</p><pre><code>tsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli</code></pre><p>In a future post, we&#39;ll look at strategies for reducing how much code you have to import, both as a library author and a consumer.</p>]]></content>
    
    <summary type="html">
    
      Has TypeScript gotten slow for you? Run this one magic command to visualize what TypeScript is compiling, and maybe get to the root of the issue.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A new way to test types</title>
    <link href="https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/"/>
    <id>https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/</id>
    <published>2022-05-28T21:55:00.000Z</published>
    <updated>2022-05-28T23:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Readers of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> and followers of this blog will know that testing types is a long-standing interest of mine:</p><ul><li><a href="https://github.com/danvk/typings-checker">typings-checker</a> (2017) implemented <code>$ExpectType</code> and <code>$ExpectError</code> directives and helped to influence <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, which is used to test types on DefinitelyTyped.</li><li>I gave a talk at TSConf 2019 entitled <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">Testing Types: An Introduction to dtslint</a>.</li><li>I included Item 52: Be Aware of the Pitfalls of Testing Types in <em>Effective TypeScript</em> (2019)</li><li>I created <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a> (2020) to type check Effective TypeScript and this blog.</li></ul><p>There are many tools out there for testing types, from tricks with <code>tsc</code> to <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, <a href="https://github.com/SamVerschueren/tsd">tsd</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. But I can&#39;t say I really love any of them. I&#39;ve always felt like I was writing tests because I should do it, rather than because it was fun and I wanted to.</p><p>When I started working on <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>, I wondered whether there might be a better way. In the years since <em>Effective TypeScript</em> came out, largely thanks to Orta&#39;s advocacy, <a href="https://shikijs.github.io/twoslash/">twoslash</a> has become a widespread standard. You can <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBGCuBbCMC8MDaBGANDATHgMx4AsAugNwCwAUKJLAB5pxIQB0ATgKYAm8YDwAUwpngCeASjQA+GCwDUMaTVoB6dTG0wAegH46QA">see this</a> on the TypeScript playground: if you write a twoslash comment (<code>// ^?</code>) then the TypeScript language service&#39;s &quot;quick info&quot; appears next to it:</p><img src="https://effectivetypescript.com/images/twoslash-play.png" title="twoslash comment showing an inferred type on the TypeScript playground" width="364" height="69" /><p>This <a href="https://twitter.com/danvdk/status/1505209336414547968">got me thinking</a>: what if we used this same syntax to do type assertions?</p><p>So rather than <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y); <span class="hljs-comment">// $ExpectType number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://github.com/SamVerschueren/tsd">tsd</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br>expectType&lt;<span class="hljs-built_in">number</span>&gt;(x);<br></code></pre></td></tr></table></figure><p>you could just write a twoslash comment:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">//    ^? const x: number</span><br></code></pre></td></tr></table></figure><p>And have something enforce that this comment matched the real Quick Info.</p><p>This has a few nice properties:</p><ol><li>It&#39;s a syntax that&#39;s already widely used.</li><li>It&#39;s unambiguous which symbol the assertion refers to: it&#39;s the one one the caret (<code>^</code>) points at. (This is a source of ambiguity for dtslint and literate-ts.)</li><li>It&#39;s clearly distinct from runtime code and is making an assertion about the <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a> of the type, rather than its structure. (Structural checks will happily let you replace a nice-looking type with something cryptic but equivalent, or even with <code>any</code>.)</li></ol><p>There was an existing eslint plugin, <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type"><code>eslint-plugin-expect-type</code></a>, which did something similar. So I set about <a href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/">adding support for twoslash syntax</a>. One really nice thing came out of this: eslint makes it easy to write and test auto-fixers, so doing type assertions has some of the same feel as Jest&#39;s <a href="https://jestjs.io/docs/snapshot-testing">snapshot testing</a>.</p><p>Here&#39;s a GIF of the autofixing in action:</p><p><img src="https://user-images.githubusercontent.com/98301/162592605-184fe6e5-e069-4a63-aa87-387f4e1b85df.gif" alt="Animation of eslint-plugin-expect-type filling in the correct type assertion"></p><p>More than anything else, this autofixer is what&#39;s made writing type tests fun!</p><p>Here&#39;s an example of a type test from <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedDb = <span class="hljs-keyword">new</span> TypedSQL(tables);<br><span class="hljs-keyword">const</span> docTable = typedDb.table(<span class="hljs-string">&#x27;doc&#x27;</span>);<br><span class="hljs-keyword">const</span> update = docTable.update(&#123;<span class="hljs-attr">where</span>: [<span class="hljs-string">&#x27;title&#x27;</span>]&#125;);<br><span class="hljs-comment">//    ^? const update: (db: Queryable, where: &#123;</span><br><span class="hljs-comment">//           title: string | null;</span><br><span class="hljs-comment">//       &#125;, update: Partial&lt;Doc&gt;) =&gt; Promise&lt;Doc[]&gt;</span><br><span class="hljs-keyword">const</span> newDoc = <span class="hljs-keyword">await</span> update(<br>    mockDb,<br>    &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Great Expectations&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">created_by</span>: <span class="hljs-string">&#x27;Charles Dickens&#x27;</span>&#125;,<br>);<br>newDoc;<br><span class="hljs-comment">// ^? const newDoc: Doc[]</span><br></code></pre></td></tr></table></figure><p>crudely-typed uses <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">many</a> of the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">fancy types</a> that I&#39;ve <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">written about</a> on this blog. But users of the library should never be aware of any of this chicanery. The types that come out should make sense in the context of the types that go in. They shouldn&#39;t require you to understand the internals of the library. It&#39;s easy to <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">accidentally break</a> this property while refactoring, for example to make the type of <code>newDoc</code> display as something more complicated than <code>Doc[]</code> in the example above. Testing how types <em>display</em> gives you the freedom to refactor without the fear that you&#39;ll inadvertently worsen the experience of your library&#39;s users. And the autofixer makes it a delight to do so!</p><p>If you&#39;re writing a TypeScript library that makes use of any heavy type machinery, I&#39;d highly recommend writing tests with <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type">eslint-plugin-expect-type</a>. You&#39;re using eslint already (you are, aren&#39;t you?) so adding this plugin it doesn&#39;t require new tooling. You can see examples of how to wire it up on <a href="https://github.com/danvk/crudely-typed/pull/18/files#diff-46e9201b2cf8dec2bcf89b7b86965fdbfe1210504118198f3b33b2cb9b94dc27">crudely-typed</a> and <a href="https://github.com/danvk/crosswalk/pull/35">crosswalk</a>.</p>]]></content>
    
    <summary type="html">
    
      Readers of Effective TypeScript and followers of this blog will know that testing types is a long-standing interest of mine. In this post I show how eslint-plugin-expect-type provides new syntax and tooling to make testing types so easy and fun that you&#39;ll &lt;i&gt;want&lt;/i&gt; to do it!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>My Twitch Debut (eslint-plugin-expect-type with Josh Goldberg)</title>
    <link href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/"/>
    <id>https://effectivetypescript.com/2022/04/18/twitch-expect-type/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-05-28T21:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/twitch-screengrab.jpg" title="Screengrab from Twitch" width="320" height="180" style="float: right; margin-left: 10px;">I made my <a href="https://www.twitch.tv/videos/1455722291">Twitch debut</a> last week with <a href="https://twitter.com/JoshuaKGoldberg">Josh Goldberg</a>, who&#39;s writing O&#39;Reilly&#39;s upcoming <a href="https://learning.oreilly.com/library/view/learning-typescript/9781098110321/"><em>Learning TypeScript</em></a> title.</p><p>We talked through a <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47">recent PR</a> I created to add TwoSlash support for Josh&#39;s expect-type eslint plugin. That syntax looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> four = <span class="hljs-number">4</span>;<br><span class="hljs-comment">//  ^? let four: number</span><br></code></pre></td></tr></table></figure><span id="more"></span><p>The eslint plugin will then check that TypeScript reports <code>let four: number</code> when you get quickinfo for <code>four</code>. This lets you write tests for <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">the display of types</a>. The idea is similar to <a href="https://github.com/microsoft/dtslint">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, but with a few key advantages:</p><ol><li>It uses a widely-adopted syntax (TwoSlash is even supported on the TypeScript playground).</li><li>It&#39;s implemented through an eslint plugin, so you don&#39;t need another tool to make type assertions.</li><li>It has an autofixer, which makes this pleasant to use.</li></ol><p>Once the PR is merged, this will be my new preferred way to test types, and I&#39;ll have to update the recommendations from my <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">TSConf 2019 talk</a> as well as Item 52 in <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> (&quot;Be Aware of the Pitfalls of Testing Types&quot;). I&#39;m already using it on my latest open source project, <a href="https://github.com/danvk/crudely-typed/">crudely-typed</a> (more on that soon!).</p><p>I had a great time chatting with Josh, and I think we both learned a thing or two. Hopefully you will, too!</p><!-- Add a placeholder for the Twitch embed --><div id="twitch-embed"></div><!-- Load the Twitch embed script --><script src="https://player.twitch.tv/js/embed/v1.js"></script><!-- Create a Twitch.Player object. This will render within the placeholder div --><script type="text/javascript">  new Twitch.Player("twitch-embed", {    video: "1455722291",    width: 620,    height: 378,    autoplay: false,  });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/twitch-screengrab.jpg&quot; title=&quot;Screengrab from Twitch&quot; width=&quot;320&quot; height=&quot;180&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;I made my &lt;a href=&quot;https://www.twitch.tv/videos/1455722291&quot;&gt;Twitch debut&lt;/a&gt; last week with &lt;a href=&quot;https://twitter.com/JoshuaKGoldberg&quot;&gt;Josh Goldberg&lt;/a&gt;, who&amp;#39;s writing O&amp;#39;Reilly&amp;#39;s upcoming &lt;a href=&quot;https://learning.oreilly.com/library/view/learning-typescript/9781098110321/&quot;&gt;&lt;em&gt;Learning TypeScript&lt;/em&gt;&lt;/a&gt; title.&lt;/p&gt;
&lt;p&gt;We talked through a &lt;a href=&quot;https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47&quot;&gt;recent PR&lt;/a&gt; I created to add TwoSlash support for Josh&amp;#39;s expect-type eslint plugin. That syntax looks like this:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; four = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//  ^? let four: number&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The display of types</title>
    <link href="https://effectivetypescript.com/2022/02/25/gentips-4-display/"/>
    <id>https://effectivetypescript.com/2022/02/25/gentips-4-display/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2023-07-09T18:42:18.509Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: The display of types</li></ul><p>We talk all the time about how to define and use types in TypeScript, but we rarely talk about how TypeScript chooses to <em>display</em> our types. There are often several possible ways to display the same type, and the choice can have a big impact on the usability of your library. TypeScript tries to make good decisions on its own about type display, but it also gives us a few levers by which we can control it ourselves.</p><p>Let&#39;s dive in to the strange world of type display!</p><!-- more --><p>Suppose you have a <code>Comments</code> table in your database and you&#39;ve defined a <code>selectComments</code> function. As you prepare to call it, TypeScript shows you some type information:</p><img src="https://effectivetypescript.com/images/type-bad.png" width="579" height="98" title="Cryptic type display"><p>This leaves something to be desired. One issue is that it feels a bit &quot;implementation-y&quot;: why should I care that the parameter is constructed using <code>Pick</code> and an intersection (<code>&amp;</code>)? It&#39;s also a bit opaque. Is <code>author_id</code> nullable? What about <code>metadata</code> in the return type? What&#39;s its type? And is <em>it</em> nullable?</p><p>It&#39;s hard to answer these questions without wading through some type declarations or experimenting.</p><p>Here&#39;s an alternative display of exactly the same types:</p><img src="https://effectivetypescript.com/images/type-better.png" width="565" height="94" title="Clearer type display"><p>This is much better. All hints of the metaprogramming that went into deriving this type are gone, and you can see exactly what the type of each field is. <code>author_id</code> is not nullable, but <code>metadata</code> is. The type of <code>metadata</code> is <code>CommentMetadata | null</code>.</p><p>When you&#39;re writing code that works with types, you should consider safety and correctness first and foremost. But once you have those, you should <em>also</em> consider how your types display. The rest of this post walks through some of the techniques that you can use to change how TypeScript displays a type.</p><h2 id="Resolving-a-type"><a href="#Resolving-a-type" class="headerlink" title="Resolving a type"></a>Resolving a type</h2><p>This is the situation described above. TypeScript is showing a generic type expression (often involving <code>Pick</code>) and you&#39;d like it to do a little more work to resolve that type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;</span>;<br><br><span class="hljs-keyword">const</span> c: Color = &#123; <span class="hljs-attr">r</span>: <span class="hljs-number">255</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">0.5</span>&#125;;<br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: Pick&lt;Color, &quot;r&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>Here&#39;s the magic incantation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Resolve&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span> ? T : &#123;[K <span class="hljs-keyword">in</span> keyof T]: T[K]&#125;;<br></code></pre></td></tr></table></figure><p>(<code>Resolve</code> is my choice of name. This type alias also goes by <code>Simplify</code> or <code>NOP</code> or <code>NOOP</code>.)</p><p>This is an odd-looking type to be sure. Both cases of the conditional type are variations on the identity function. It doesn&#39;t look like it should do anything at all! But our goal isn&#39;t to change the type so much as to change how it&#39;s displayed, and, for whatever reason, this does the trick:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Resolve</span>&lt;<span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: &#123; r: number; &#125;</span><br></code></pre></td></tr></table></figure><p>(The conditional type <em>does</em> seem to be necessary: <code>type Resolve&lt;T&gt; = &#123;[K in keyof T]: T[K]&#125;</code> does not resolve this type in the same way.)</p><p>This trick is also helpful in resolving the intersection types like <code>T[K &amp; keyof T]</code> described in part 2 of this series: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a>. For example, here&#39;s the code from the start of this post:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Select&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>&gt; &#123;<br>  (<br>    where:<br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectComments: Select&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectComments()<br><span class="hljs-comment">// ^? let selectComments: Select</span><br><span class="hljs-comment">//    (where: Pick&lt;Comment, &quot;author_id&quot; | &quot;doc_id&quot;&gt; &amp; &#123;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>The <code>Select</code> function takes a table type and two sets of keys: one containing the columns that have to be set to a specific value and one containing the columns that may be any value in a set. The resulting function call has a parameter with that tell-tale implementation-y look.</p><p>As you&#39;d hope, <code>Resolve</code> makes short work of this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">interface</span> SelectResolved&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>  &gt; &#123;<br>  (<br>    where: Resolve&lt;        <span class="hljs-comment">// &lt;-- Resolve added here</span><br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>    &gt;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectCommentsResolved: SelectResolved&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectCommentsResolved()<br><span class="hljs-comment">// ^? let selectCommentsResolved: SelectResolved</span><br><span class="hljs-comment">//    (where: &#123;</span><br><span class="hljs-comment">//        author_id: string;</span><br><span class="hljs-comment">//        doc_id: string;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>All vestiges of the implementation of this type are gone and we&#39;re left with a clean display. Hooray! (Full example on the <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osE4EWANJ2XBwVXARDe4ol6LFedlnIWavIVCuiIZgAKAjQqtb4rnHYYcHPl+vcAXADJl6v12395MnC5UAAypowAjs2kilOUwDFKKkgAOpCg8HhyIMPZ4H2H5rgKEEKNBkhATASEoSAvaDCumElGUOFMB2oSsAAFJIrByghwCRIxrAPheV7YVB4rwVkwCER2r7sawM7zoucD4YRm5SYoraUVBEnvmR66KRuHZ5KwACU0SnlAWAesACmQe2uSWBoaByDwqBaDEwEjky+BENEQEKKBTkwOK3CnOcUCXJwUjqNsAXecsnDfkwGbuQRVTOXR2m1EUAB645MEAA">playground</a>.)</p><p>The <code>Resolve</code> alias can sometimes resolve <code>keyof</code> expressions. More on this below.</p><p><em>h/t to <a href="https://stackoverflow.com/users/5827215/tadhg-mcdonald-jensen">Tadhg McDonald-Jensen</a> on Stack Overflow for <a href="https://stackoverflow.com/a/69976234/388951">introducing</a> me to this helpful type alias!</em></p><h2 id="Special-casing-important-types"><a href="#Special-casing-important-types" class="headerlink" title="Special-casing important types"></a>Special-casing important types</h2><p>Sometimes the display of a type is bad for a specific, important case of your generic. In these situations it can be worthwhile to handle those cases specially using a conditional type.</p><p>For example, say you have a function that can either select all the columns from a table or just a few specific columns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Pick&lt;TableT, Cols&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br></code></pre></td></tr></table></figure><p>It makes sense that the <code>Cols</code> type parameter defaults to <code>keyof TableT</code> since that corresponds to selecting all the columns and <code>Pick&lt;T, keyof T&gt; = T</code>.</p><p>The type <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMSZOFyoADKmmAaBgAHlcMAADylcrAYrijxyQagXmiQaq4CIb09hTFRhwCdTgUzvsAPkWrFYAAo5UKHtFgntrodjDkAJTRAAKAjQqu7ZVnA4gQ9XuUsGjQch4qC0cGMiiZfAACFEAASSuRsFBbdsu0AmBX0sDBzXgbN4AYP8AKqYCwNELdDyuTgAEYACYAGZOHPCxCk3OAAD0AH4gA">doesn&#39;t display very cleanly</a> when we use the function, though:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Pick&lt;Comment, keyof Comment&gt;</span><br></code></pre></td></tr></table></figure><p>This is cryptic and quite implementation-y. And the <code>Resolve</code> trick doesn&#39;t quite do what we want here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- Resolve</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: &#123;id: string; doc_id: string; author_id: string, ...&#125;</span><br></code></pre></td></tr></table></figure><p><code>Resolve</code> has fully inlined this type. What it&#39;s displaying is exactly equivalent to <code>Comment</code>, but that&#39;s hard to tell without a careful comparison. It would be much nicer if it just said <code>Comment</code>!</p><p>You can improve the display here by explicitly checking for the default case:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>  (where: &#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> &#125;):<br>    keyof TableT <span class="hljs-keyword">extends</span> Cols       <span class="hljs-comment">// &lt;-- conditional type</span><br>    ? TableT                        <span class="hljs-comment">// &lt;-- special case</span><br>    : Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- default case</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Comment</span><br></code></pre></td></tr></table></figure><p>Much better! Here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osEiwBpOy4OCq4CIb3FEvRYpzks5CxMSZOFyoADKmmAI4A8rhgK2ygpiuKPHJBj28H2lyu13fgMVO8vVwKpTlD+HahKwrAABRykKDzTns1yHMYOQAJTRP+X7Ab+r4GIMT6DJOQH3nA0T1kQjYtgACgIaCqremGPo2RBtm2uSWBoaByDwqBaHAxiKEy+AAEKIAAklcp4KJe17NgJMAsZYGDmvA2bwAwvH8VUQmiaIEHBPBnAAIwAEwAMycChFiFOBcAAHrjmx56cQ8cA8XxMCyXh0QSeeMBXjesnipwyycFI6jbJcIVqHSrJkJF0g2jm9qcPJimeipx4oGgAhAmgeGdm5HmMbp+nGWZFm1EU4F2UwQA">full playground</a> for this example.</p><h2 id="Other-techniques-that-don-39-t-work-as-well"><a href="#Other-techniques-that-don-39-t-work-as-well" class="headerlink" title="Other techniques that don&#39;t work as well"></a>Other techniques that don&#39;t work as well</h2><p>There are a few other techniques I&#39;ve run across for simplifying type display that don&#39;t work as well as <code>Resolve</code>. They&#39;re included here for completeness. If you&#39;re using them, you may as well just use <code>Resolve</code> instead.</p><h3 id="Exclude-lt-keyof-T-never-gt"><a href="#Exclude-lt-keyof-T-never-gt" class="headerlink" title="Exclude&lt;keyof T, never&gt;"></a><code>Exclude&lt;keyof T, never&gt;</code></h3><p>This can be used to inline the display of <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> Chan = keyof Color;<br><span class="hljs-comment">//   ^? type Chan = keyof Color</span><br><span class="hljs-keyword">type</span> ChanInline = Exclude&lt;keyof Color, <span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">//   ^? type ChanInline = &quot;r&quot; | &quot;g&quot; | &quot;b&quot; | &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>The <code>Resolve</code> trick <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIHsA26rIN7JQBcyIArgLYBG0A3MgOYnnV3JXOU1T1yeu4AvrQBQIsAE8ADigBKEAM5YAbhAA8AFQB8yALzINyCAA9IIACYLkAMTIgEYYOhDIA-AeQk8AbQDSyUGQAawgJdBgDAF0SDT9I4XFpFFQACzgXfXklTFU1ELCIjGwoLVEAejLkKoA9d0kZNDSM5AAiKBbkAB9Whg7ulqo+1rgWsQRnBTBkBBIinD18QhIAJgBWVYAaRhIARmWADi2OZAAGLb5TgDpVhPMIBEw4KBQYOwcnFwYIMFT0kAhMAAKGZoLA4LYIJokLIqdT5cKg4paACU-G4ojGEymuH0Xx+TX+QIQGzEFWQAAUyFMwmRcAhaUpcHApmAUigIBZkAjWSgpM9lE4yFZMKAUOlzMgaQByTCYZAKCAQIgiMl434gQnA2ZgqAQqHBUIIuZQVGkLjQFVlS3IADubOecCsAEkpRKRSFkGB0PLFcrVd91ZqQca9ekSG0hi1el1WoMYy0RqaWNwREA">works just as well</a> in this case, and can resolve many types that excluding <code>never</code> cannot. So just use <code>Resolve</code>.</p><p>Side note: why does TypeScript display <code>keyof</code> types in this way? Prior to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">TypeScript 4.2</a>, TypeScript <em>always</em> inlined <code>keyof</code> display. This sometimes led to comical results:</p><img src="https://effectivetypescript.com/images/keyof-button.png" width="907" height="78" title="keyof HTMLButtonElement showing a union of 260 string literal types"><p>Count &#39;em, that&#39;s a union of 260 string literal types! Newer versions of TypeScript simply display this as <code>keyof HTMLButtonElement</code>, which seems like a win. But I think they <a href="https://github.com/microsoft/TypeScript/issues/42322">threw the baby out with the bathwater</a> here; for the common case of small unions (say less than 10 strings), it&#39;s clearer to <a href="https://twitter.com/danvdk/status/1414343269522227207">just show the type union</a>. This makes the behavior of <code>keyof</code> much easier to understand. Perhaps someday this will improve and we won&#39;t need to <code>Resolve</code> this type.</p><h3 id="unknown-amp-T"><a href="#unknown-amp-T" class="headerlink" title="unknown &amp; T"></a><code>unknown &amp; T</code></h3><p>I learned about this one from Titian&#39;s <a href="https://stackoverflow.com/a/56416192/388951">classic answer about typing <code>_.invert</code></a> on Stack Overflow. Sometimes you can replace <code>TypeExpr</code> with <code>&#123;&#125; &amp; TypeExpr</code> or <code>unknown &amp; TypeExpr</code> to force TypeScript to resolve a type.</p><p>You can see an example of this technique working in <a href="https://www.typescriptlang.org/play?#code/PTAEBUEsBdIQwHYHIDOpoE8AOBTNAzAJwHsBbUAC2mixQC4QVo4BjAa2IDcdD8AbYgHcAdCzLA4wAKwA2ACwBGGQoCcAJmABmABzaVUhQChMuUAEE+fAGpw+AVzwAecKBwAPaDgQATNACUcMUJvRwAFElxCTABpHAwAGlBw4kiYuIA+dNAAXlAAb0NQItAAbVDQSARQNjjifAgAXTp86rjm0MTOWwdm8DKG0ABfQ0GSmow6xoBuY2wcUABJBG4ogJQ7PmhnVw8vX1AAoJDk1IxYhKSInjSMTJz8wuKyiqqLa26ncHSSpC77HCQDSaoAAoh5CKwtm8bP8UM50ok8qA-j0kkNvkhxoCZoMZoYxAgmKBiPcCsVQHBmkg3Eh4o8igAjKkYWkjCloAlMPEmeYuXJLFbQNYbLY8ybEdIzEBFAB6AH5DLNTALrsLNgAhHDUHjbdyeHz+QLEYJhK5RM5xRIna4W25ZXJ2BBsBBCKoAMge5OelXMlhhDjhXx+KIBQOaYOgEJYUL9H0DCJaIfa6J+WIaOLx3kCfDghHm+Ed0cgxCqlUFut2BoORpN1vN5ytZpumQAFMQGQArXoASmaKtWeBF8JmWZYObzoALCCLJZegs12sIFf1+0OxuOTdtjZSNvOrfbXYgvcWy1Vg41Ws8S6+I+zufzhdgs7LZ5QxD43BCLj1e0NR1NO71palyAc26Rtp2PbNGs77cI4-ZCueWxfJKirSuAFCQGgFBwGgiCgAARJApBYHwOCkF4zBPggGAEegcygN4WGkXAGDCKAADqOHQKgJ6Cmq0AKpy0BzvcL5RG23ZSmAxTymhYBmN4TEIAA5hSoCCDglgALQsSwODeKAAAGjrOq6oBukZoCkHANRoDAjHMTmGDWca8xjjgiB8BgdD4iWRJlmoYmnlEC5XpJ0nknJhjSmY1Zvh+OCOFkrCYTg3BoNAFDzCgcAUaAebrJsvnCXOmjBfxeCwQZEUxTJsoKvJECYfZeFVLYV4IHAsDcBUJFkRRCBUcWVQoBQQiVGpWXzN4EKCAyrBsGgkwmU6LqCO6Vn4O+AiCJNdWUNQtAMMAOD4PggQ9VqcwoCwhCQFg0CiOIagAAxvcAr1SMACgaI6I2QAAXjg2kHpdkD4BgwCKjyoAAKoIADwPLr+xKdpd9qeqUbAvK0Ez1OAwJ5GwzRsFMyK9GMDTDKM4yTIT3IMdEVihHAkCEKSJMgac5zk5wzSmetCDDLDADy6NFpDKNVszrPs5jZLY7jfSYoCwIRlGyGIlzbCDBinCAiMjOmAAyoIcBYMz8I5I836VvsxPNJUF0c9EnROwgLugFYwxFHK+Rc1YfPNNE5ODEU0qONp2mgC6njoNloAoObWAAISPM0CDpTwxvzDBiXW7kdsrmgABij4jaA-suM0eQlNEuN0wTwJ9NE1MzLDCFw6L0v7GD0aY+LHbg1LZsW1bCNI0lKEWaAsts4QqFKvMXei-nn698tEvQJj69JUPI8YI4Y+W1YjiTyWQPT3cHrz-LS+juOD7TtRc7XN3m-Vv+dY3NuPMZOBA8UE+Lvx7jeQwj97yTgrs+EK0Bu57y-DsEuX91wAX-hcH+tp9yQSPH2OBCCqqJS-EvdCLUKR8DfJQXCFIqhEX6uRSi3URq0XoqYJiKAWI+T8oSESZY4YklyOJeBotarSlko1aUe9kqTkgG4PAFRoCJAZHYESEw7CgBYIgJAIk4BKWMoLcyllaEYEENlCc0ASTeBJDAYQPCArLAEUFIRBC15EM-GI+qoA5JAA">this playground</a>. I&#39;ll spare you the full details, but from hard-earned experience I&#39;ve learned that this trick is much more finnicky than <code>Resolve</code>. Just use <code>Resolve</code> instead.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While it may seem that you&#39;re stuck with however TypeScript chooses to display your type, that&#39;s not actually the case! You do have a few levers at your disposal. The <code>Resolve</code> alias is wonderful for removing implementation details from generic types. And where it doesn&#39;t work, you can sometimes add a special case to get the display that you want.</p><p>Remember that <a href="https://twitter.com/SeaRyanC/status/1414347018646921216">all representations are equally valid</a>, and that the TypeScript team might choose to change the display of your type at any time (as <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">happened</a> with <code>keyof</code> in TypeScript 4.2). So once you&#39;ve got your types displaying the way you like, it&#39;s worth writing some tests to make sure they stay that way. Tools like <a href="https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, which make assertions about the textual display of types, are the way to go here.</p><p>Do you have other tricks for controlling type display? Let me know <a href="https://twitter.com/danvdk">on Twitter</a> or in the comments below.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We talk all the time about how to define and use types in TypeScript, but we
rarely talk about how TypeScript chooses to &lt;i&gt;display&lt;/i&gt; our types. There
are often several possible ways to display the same type, and the choice can
have a big impact on the usability of your library. TypeScript tries to make
good decisions on its own about type display, but it also gives us a few very
obscure levers by which we can control it ourselves.&lt;/p&gt;
&lt;p&gt;Let&#39;s dive in to the strange world of type display!&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A TypeScript Perspective on Go: the 2021 Advent of Code</title>
    <link href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/"/>
    <id>https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/</id>
    <published>2022-02-06T23:00:00.000Z</published>
    <updated>2023-09-27T20:32:52.863Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">It&#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.</p><p>My favorite way to learn a new language is through the annual <a href="https://adventofcode.com">Advent of Code</a> (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. In 2019 I <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">did it in Python</a> (not a new language for me) and in 2020 I <a href="https://effectivetypescript.com/2021/03/24/advent-of-code/">did it in Rust</a> (which was a new language). This year, I did it in Go (aka Golang).</p><p>This post has three parts:</p><ul><li>My impressions of Go (coming from a TypeScript perspective)</li><li>My impressions of this year&#39;s Advent of Code</li><li>Notes and links for each day</li></ul><span id="more"></span><h2 id="My-Impressions-of-Go"><a href="#My-Impressions-of-Go" class="headerlink" title="My Impressions of Go"></a>My Impressions of Go</h2><p>I first used Go when I was working at Google in 2011. C++ was my main language at the time, so Go wasn&#39;t such a big shift. I remember finding it quite confusing until I really &quot;got&quot; the idea of duck typing: the consumer of an interface defines what it needs and the producer doesn&#39;t need to declare that it implements this interface. I didn&#39;t have much use for Go in my work or personal projects, so I mostly forgot about it.</p><p>Some parts of Go&#39;s design that seemed strange in 2011 have aged quite well: automatic formatting of source code is very standard now, and I certainly didn&#39;t mind Go complaining about unused symbols. One thing that I found confusing in 2011 and still found confusing today: Go&#39;s insistence on where you put your source code on disk. I usually put all my GitHub repos in <code>~/github/reponame</code>. But Go wants them under <code>$GOROOT</code>, which is <code>~/go</code> (or <code>~/gotip</code>) on my system. This made my setup experience a bit frustrating, but once I gave up and put my code in <code>$GOROOT</code> everything worked OK and I moved on.</p><p>Last year my pattern was to solve the puzzle, then look at how more experienced Rust developers solved it on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. I almost invariably learned something from this. That didn&#39;t work this year. In Go, the straightforward approach is usually the canonical one. There are just fewer surprises. Go takes pride in being a <a href="https://www.capitalone.com/tech/software-engineering/go-is-boring/">&quot;boring&quot; language</a>. I learned more about Go from having <a href="https://github.com/danvk/aoc2021/commit/a3b38546680c52e1c9c29365a712c834214082cf#r62160234">@derat review my code</a> and make more specific suggestions.</p><p>I&#39;m aware that the Advent of Code doesn&#39;t particularly play to Go&#39;s strengths: there&#39;s no concurrency, for example. But I still found it to be a good way to force myself to learn the basics of the language and use it to solve real problems.</p><p>Here are a few differences between Go and TypeScript that stood out to me.</p><h3 id="Implicit-copies"><a href="#Implicit-copies" class="headerlink" title="Implicit copies"></a>Implicit copies</h3><p>I&#39;m not aware of any situation in which JavaScript makes a copy of an object without your asking it to. In Go, however, this happens all the time. Building a mental model for when these copies happens is always relevant for performance, and sometimes relevant for correctness.</p><p>In TypeScript, we can create a <code>Student</code> type with a name and age, and <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMpgK4BMLmQbwFgAoZZEOAWwgC5kBnMKUAcwG4Sy4XbyNKARtA7EAviRIwMIBGGAB7EMgCCPZQE0IcKAAp6ddNlxgAlAU4MAdNxQBqALzIAjCXHESCRY2QD5AgQCeBpg4eI745FS8AOQAQn6B0QA0yDZ0TgBMyKIiqhAaWrq+-gEmIp4g9PIANhCW1fIsOsWB1jxlZAD0ncgACszg9M4AzCRAA">write a function</a> to make a student age by a year:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AgeAYear</span>(<span class="hljs-params">s: Student</span>) </span>&#123;<br>  s.age += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">const</span> bobby: Student = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;;<br>AgeAYear(bobby);<br><span class="hljs-built_in">console</span>.log(bobby.age);  <span class="hljs-comment">// Prints 13</span><br></code></pre></td></tr></table></figure><p>In JavaScript, objects are always passed by reference. There&#39;s only one <code>Student</code> floating around and <code>AgeAYear</code> modifies it, which is why this code logs 13. (Are primitive types like <code>string</code> are passed by value or by reference? It&#39;s irrelevant because they&#39;re immutable.)</p><p>In Go, <a href="https://go.dev/play/p/zhTqc1-SP1J">something very different happens</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AgeAYear</span><span class="hljs-params">(s Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)  <span class="hljs-comment">// prints 13</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bobby := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>AgeAYear(bobby)<br>fmt.Printf(<span class="hljs-string">&quot;Bobby&#x27;s age is %d\n&quot;</span>, bobby.age)  <span class="hljs-comment">// prints 12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go passes objects by <em>value</em>, not by reference, so <code>AgeAYear</code> is actually operating on a <em>copy</em> of <code>bobby</code>, not the original. This copy&#39;s <code>age</code> increases, but then the copy gets thrown away when the function returns. C++ has a similar behavior and calls this &quot;value semantics.&quot;</p><p>If you want to mutate <code>bobby</code>, you can use a pointer instead:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetOlder</span><span class="hljs-params">(s *Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bob := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>GetOlder(&amp;bob)<br>fmt.Printf(<span class="hljs-string">&quot;Bob&#x27;s age is %d\n&quot;</span>, bob.age)<br>&#125;<br></code></pre></td></tr></table></figure><p>Now this logs <code>13</code> twice. Working with pointers has some famous drawbacks, of course, but it&#39;s much easier in Go than it is in C or C++ because there&#39;s garbage collection.</p><p>Pointers in Go have a way of being contagious. Once you use a pointer to a structure in one place, you can get into trouble if you ever pass it by value someplace else. For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SelfReference <span class="hljs-keyword">struct</span> &#123;<br>  name <span class="hljs-keyword">string</span><br>  self *SelfReference<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeSelfReference</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">SelfReference</span></span> &#123;<br>  me := SelfReference &#123;name: name&#125;<br>  me.self = &amp;me<br>  fmt.Printf(<span class="hljs-string">&quot;References self? %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// true</span><br>  <span class="hljs-keyword">return</span> me<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  me := MakeSelfReference(<span class="hljs-string">&quot;me&quot;</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;References self?: %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/wCiNfPlX75W">This code</a> logs:</p><pre><code>References self? trueReferences self? false</code></pre><p>I scratched my head a good long time over an issue like this before realizing that when <code>MakeSelfReference</code> <em>returns</em>, it makes a copy of the object but of course doesn&#39;t update the <code>self</code> pointer. So the two get out of sync. If you want to keep them in sync, you want to return a <code>*SelfReference</code> instead.</p><p>It took me some time to build an intuition for this because the rules about what&#39;s copied can be surprising. An array (which always has a fixed size in Go) is copied by value, but passing a slice (which is like a small struct with a pointer, length and cap) does not make a copy of the underlying array. Another wrinkle (which I won&#39;t dive into here) is that depending on how a method is declared, invoking it can implicitly copy the object, too.</p><p>All these implicit copies are important and eventually this became intuitive, but it&#39;s quite a shift if you&#39;re coming from JS!</p><h3 id="Batteries-not-included"><a href="#Batteries-not-included" class="headerlink" title="Batteries not included"></a>Batteries not included</h3><p>Go is definitely not a &quot;batteries included&quot; language: there are many very common and familiar functions that are missing from its standard library, notably <a href="https://stackoverflow.com/questions/19239449/how-do-i-reverse-an-array-in-go/19239832">reversing a list</a>, the standard <code>map</code> / <code>filter</code> / <code>reduce</code> functions, taking the min/max of two numbers or <a href="https://stackoverflow.com/questions/57648933/why-doesnt-go-have-a-function-to-calculate-the-absolute-value-of-integers">taking the absolute value of an integer</a>. The argument is that these functions are easy to write, so if you want them, you should just write them. But that does lead to some strange interactions. This VS Code shortcut is a real gem:</p><p><img src="https://effectivetypescript.com/images/golang-reverse.gif" alt="VS Code Reverse"></p><p>I guess this beats copy/pasting from Stack Overflow? My old coworker Dan suggested that this was a way to push you towards reverse iteration, which is faster and requires less memory than allocating a new list. The Go team tends to have very strong opinions about things like this. If you agree with them, then it&#39;s fun to watch them take a stand. But if you don&#39;t, you wind up having to settle for weird workarounds like this one.</p><p>The omission of <code>map</code> / <code>filter</code> / <code>reduce</code> is likely because these functions aren&#39;t that useful without generics. And there is some exciting news on that front!</p><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>The Go team <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">accepted a propsal</a> to add generics to the language in mid-2021 and the Go 1.18 beta, which included support for them, came out in the middle of this year&#39;s AoC. Generics are a big part of TypeScript, so I was curious to see Go&#39;s take on them. I did most of the puzzles using <a href="https://pkg.go.dev/golang.org/dl/gotip">gotip</a> so that I could use generics before they were officially released. Overall this was a pretty smooth process. I found that Go with Generics is a much more pleasant language to use than Go without.</p><p>Here&#39;s what a <a href="https://github.com/danvk/aoc2021/blob/ba0936c804ff9c2a170472c77de029712baa069f/util/util.go#L159-L170">generic <code>min</code> function</a> looks like in Go:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;constraints&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(nums []T)</span> <span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(nums)<br>&#125;<br>min := nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure><p>Aside from some syntax differences, this is quite similar to how you&#39;d <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWRmAPAFQHwAoBuAhgDYDOAXIpgNoC6AlJZogN4CwAUIojMIgSVIA6YgFMwAcygALRAF4FiAAz1WnbtxkAnOAHdEYUfoCiWnVtwByAMKEwYOFERRCAa1GIAtmkRw+ozwAHKABPRGIYUihLegBudUQAXwSxJ28kOUQiMmolWniuRGA4LX4IBCis3z5s4VIIiFFcAEZ6VXZC7l5+fER0LzR2hI0BjKyCkeTCqe4tUSgQLSR0gsSgA">write this code</a> in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vals.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Cannot take min of empty list&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> min = vals[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> vals.slice(<span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (v &lt; min) &#123;<br>      min = v;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> min;<br>&#125;<br></code></pre></td></tr></table></figure><p>The most interesting bit in the Go code is the <code>[T constraints.Ordered]</code>, which would be similar to <code>T extends Ordered</code> in TypeScript. Go comes with a <code>constraints.go</code> module that <a href="https://cs.opensource.google/go/go/+/master:src/constraints/constraints.go;l=44-50?q=constraints.go&ss=go%2Fgo">defines <code>Ordered</code></a> and many other constraints that can be placed on type parameters:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Ordered is a constraint that permits any ordered type: any type</span><br><span class="hljs-comment">// that supports the operators &lt; &lt;= &gt;= &gt;.</span><br><span class="hljs-comment">// If future releases of Go add new ordered types,</span><br><span class="hljs-comment">// this constraint will be modified to include them.</span><br><span class="hljs-keyword">type</span> Ordered <span class="hljs-keyword">interface</span> &#123;<br>Integer | Float | ~<span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Both <code>Integer</code> and <code>Float</code> are themselves constraints (while JS/TS just has <code>number</code>, there are many numeric types in Go such as <code>uint32</code> or <code>float64</code>). The tilde in <code>~string</code> is also interesting. It matches any type whose &quot;underlying type&quot; is <code>string</code>. This confused me for a while until I realized that, unlike TypeScript, Go has nominal types! For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> EnglishWord <span class="hljs-keyword">string</span><br><span class="hljs-keyword">type</span> GermanWord <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>This would create two types that are not comparable or assignable to one another. But you can certainly take the min or max of a list of <code>EnglishWord</code>s. This is a feature that has been <a href="https://github.com/Microsoft/Typescript/issues/202">much discussed</a> in TypeScript but is not natively supported. I found nominal types less useful in the Advent of Code than I would have expected. (I only used them to create distinct types for <code>Digit</code> and <code>ScrambledDigit</code> on <a href="https://github.com/danvk/aoc2021#day-8-seven-segment-search-33759--24434">Day 8</a>).</p><p>So is the Go generic code equivalent to this TypeScript?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Orderable = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Orderable</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>Not quite. This TypeScript definition would allow you to take the min of a mixed list of <code>string</code>s and <code>number</code>s, which should be an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> mixedList = [<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;forty two&#x27;</span>];  <span class="hljs-comment">// type is (string | number)[]</span><br><span class="hljs-keyword">const</span> min = Min(mixedList);  <span class="hljs-comment">// T is string|number, returns a string|number</span><br></code></pre></td></tr></table></figure><p>There&#39;s no notion of a union type in Go (more on that in a moment), so <code>T</code> has to be exactly one of the types enumerated in the constraint (or a type with exactly one of those underlying types).</p><p>I found Go generics to mostly work as expected and be quite intuitive. They let me factor out some of the repetitive boilerplate that bothered me when I first started with the language.</p><p>For example, this is a very common pattern to map a function over a slice:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">var</span> squares []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>  squares = <span class="hljs-built_in">append</span>(squares, num * num)<br>&#125;<br></code></pre></td></tr></table></figure><p>With generics, you can factor out a <code>Map</code> function and <a href="https://go.dev/play/p/boWkZFquqck?v=gotip">rewrite this loop</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">U</span> <span class="hljs-title">any</span>]<span class="hljs-params">(vals []T, fn <span class="hljs-keyword">func</span>(T)</span> <span class="hljs-title">U</span>) []<span class="hljs-title">U</span></span> &#123;<br><span class="hljs-keyword">var</span> us []U<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> vals &#123;<br>us = <span class="hljs-built_in">append</span>(us, fn(v))<br>&#125;<br><span class="hljs-keyword">return</span> us<br>&#125;<br><br>squares := Map(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> num * num &#125;)<br></code></pre></td></tr></table></figure><p>This is quite verbose compared to how it would look in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">squares = nums.map(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num);<br></code></pre></td></tr></table></figure><p>The TypeScript version is so much shorter because:</p><ol><li>JavaScript&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> have a very compact syntax compared to Go&#39;s <code>func</code> and <code>return</code>.</li><li>TypeScript is able to infer two types: both a) the type of the function parameter (<code>num</code>), which it gets from the type of <code>nums</code> and the type of <code>Array.prototype.map</code>, and b) the return type of the arrow function, which it gets from the function body (<code>num * num</code>). Go infers neither of these, so you have to write out the types. It does infer the return type of the whole <code>Map</code> expression, though (<code>[]int</code>).</li></ol><p>I expect that having generics will greatly increase the demand for concise function definitions and better type inference. The Go team will either adopt them or declare that the users asking for them are misguided. It&#39;ll almost certainly be one of those two — they&#39;re quite opinionated!</p><p>There&#39;s a <a href="https://research.swtch.com/generic">famous quote</a> from one of the Go developers (Russ Cox) that when it comes to generics, you can either have:</p><ol><li>Slow programmers (i.e. no generics)</li><li>Slow compilers (by emitting a different version of a generic function for every type instantiation)</li><li>Slow programs (by boxing everything and doing runtime dispatch).</li></ol><p>In this scheme, JavaScript forces TypeScript to choose &quot;slow programs&quot; (though JS JITs are quite good!). And TypeScript has a complex enough type system that it&#39;s often a slow compiler, even without C++-style compile-time specialization.</p><p>Go tries to <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#implementation">escape this dilemma</a> by leaving it up to the compiler whether to specialize a function or box it. The whole <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">generics proposal</a> is interesting to read. It only occurred to me halfway through the doc that runtime performance was a consideration. Clearly I&#39;ve internalized the TypeScript approach to generics!</p><p>Overall I found Go generics easy to use and a great addition to the language. It will be interesting to see how they&#39;re adopted by the community, and whether they bifurcate libraries. I wanted a Graph library, for example, but there weren&#39;t any that used generics. So I just <a href="https://github.com/danvk/aoc2021/blob/master/graph/graph.go">wrote my own</a>.</p><h3 id="Other-bits"><a href="#Other-bits" class="headerlink" title="Other bits"></a>Other bits</h3><p>Here are a few other things I found interesting about Go:</p><ul><li><p>Go has some extremely error-prone constructs. Two examples:</p><ul><li>You write a for loop over a slice as <code>for idx, el := range vals</code>. So <code>range</code> gives you the index first and then the value. This means that if you write <code>for el := range vals</code>, you&#39;ll iterate over the indices, not the values. I much prefer the JS approach of value then index, e.g. for <code>map</code> and <code>forEach</code>. It seems much more common to only care about the value than to only care about the index.</li><li>Does <code>a, b := fn()</code> introduce two new variables? It depends. If both <code>a</code> and <code>b</code> exist, then it will create two new variables. But if only <code>a</code> exists, then it will create a new <code>a</code> variable but reassign <code>b</code>. I found this quite surprising!</li></ul></li><li><p>I really missed union types. Go has <a href="https://making.pusher.com/alternatives-to-sum-types-in-go/">nothing like them</a>, and the official stance from the Go team is that they <a href="https://github.com/golang/go/issues/19412#issuecomment-284301017">&quot;do not add very much&quot;</a> to untyped solutions. 🤮 Remember what I said about the Go team being opinionated?</p></li><li><p>You don&#39;t need regular expressions as much as you think for parsing. <code>fmt.Sscanf</code> woked great for most of the Advent of Code problems.</p></li><li><p>Like TS, Go has both <code>var</code> and <code>const</code> but <a href="https://go.dev/ref/spec#Package_initialization">they mean pretty different things</a>.</p></li><li><p>Go doesn&#39;t really have a C++-like notion of <code>const</code> or TypeScript&#39;s <code>readonly</code>.</p></li><li><p><a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">As in other years</a>, I found that using <code>map[Coord]T</code> instead of <code>[][]T</code> is almost always a good idea. It lets you create sparse arrays and accomodates unknown size or negative indices.</p></li><li><p>Go&#39;s type syntax is almost exactly backwards from TypeScript or C, which was a constant source of typos for me. For example, <code>[]T</code> instead of <code>T[]</code>. Or for function parameters, <code>min(a int, b int)</code> instead of <code>min(int a, int b)</code>. Or even <code>min(a, b int)</code>.</p></li><li><p>I still find Go&#39;s pickiness about where I put my code on disk to be weird, confusing and counterproductive. Why can&#39;t I <code>go build</code> something in a subdirectory?</p></li><li><p>Go types all have a meaningful zero value. I started to learn to work with this more and more as the month went on. For example, <code>nil</code> works perfectly well as an empty slice.</p></li><li><p>I&#39;ve always been a spaces person but Go uses tabs. It didn&#39;t bother me one bit.</p></li></ul><h2 id="My-impressions-of-this-year-39-s-Advent-of-Code"><a href="#My-impressions-of-this-year-39-s-Advent-of-Code" class="headerlink" title="My impressions of this year&#39;s Advent of Code"></a>My impressions of this year&#39;s Advent of Code</h2><p>The 2021 AoC was harder than 2020 but easier than 2019. As in 2020, none of the solutions built on one another. Each day was a completely independent puzzle. I&#39;m sure <a href="http://was.tl/">Eric Wastl</a> has his reasons for doing it this way, but I missed how 2019&#39;s puzzles encouraged you to improve the design of your previous day&#39;s solutions. With the independent puzzles, Advent of Code feels more like pure speed coding.</p><p>Days 8, 22 and 24 were the real standouts to me as a creative puzzles. For the other days, my first idea on how to solve the puzzle always turned out to be right, even if it took quite a while to implement it. Many, many of the puzzles this year could be solved with some variation on <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. It&#39;s always amazing to see how effective the standard algorithms are once you figure out how to map your problem onto them.</p><p>I continue to wish I were in a timezone where it was more reasonable for me to do the puzzles as soon as they came out. And I continue to think this is a great way to learn a language. AoC problems don&#39;t really play to Go&#39;s strengths (there&#39;s no concurrency) but I did feel much more confident writing Go by the end than I did at the start.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Once again, I had a great time doing Advent of Code this year and I enjoyed the opportunity to learn a new language. The days&#39; puzzles gave me something concrete and fun to cling to during a time of <a href="https://www.theverge.com/2021/12/16/22840028/sidewalk-labs-google-doctoroff-health-toronto-quayside">complete chaos</a> at my work.</p><p>Day 25 in particular stands out. I woke up early (6 AM) to watch the long-anticipated <a href="https://www.youtube.com/watch?v=9tXlqWldVVk">launch of the James Webb Space Telescope</a>, and I raced to collect my final stars before I had to drive off to the airport for a trip to the Dominican Republic, my first international vacation in ~2.5 years.</p><p>It&#39;s unlikely I&#39;ll use Go in my daily work, but I do enjoy the perspective on TypeScript that it gives. As always, TypeScript&#39;s relationship to JavaScript (types are erased at runtime) and its ability to infer types stand out. Which language will I try next year? I&#39;m not sure! Suggestions welcome.</p><p>If you&#39;ve made it this far and for some reason want even more, check out the <a href="https://github.com/danvk/aoc2021">notes and code</a> in my GitHub repo.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;It&amp;#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&amp;#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.&lt;/p&gt;
&lt;p&gt;My favorite way to learn a new language is through the annual &lt;a href=&quot;https://adventofcode.com&quot;&gt;Advent of Code&lt;/a&gt; (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on &lt;a href=&quot;https://reddit.com/r/adventofcode&quot;&gt;r/adventofcode&lt;/a&gt;. In 2019 I &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;did it in Python&lt;/a&gt; (not a new language for me) and in 2020 I &lt;a href=&quot;https://effectivetypescript.com/2021/03/24/advent-of-code/&quot;&gt;did it in Rust&lt;/a&gt; (which was a new language). This year, I did it in Go (aka Golang).&lt;/p&gt;
&lt;p&gt;This post has three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My impressions of Go (coming from a TypeScript perspective)&lt;/li&gt;
&lt;li&gt;My impressions of this year&amp;#39;s Advent of Code&lt;/li&gt;
&lt;li&gt;Notes and links for each day&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Types: The First 500 Years (tsconf 2021 talk)</title>
    <link href="https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/"/>
    <id>https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/</id>
    <published>2021-12-10T14:25:00.000Z</published>
    <updated>2021-12-10T14:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>My talk from tsconf 2021, <a href="https://www.youtube.com/watch?v=uN1zuV4DGRY&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe"><em>TypeScript Types: The First 500 Years</em></a>, is up on YouTube (<a href="https://docs.google.com/presentation/d/1HYknblfcAnbjbdDe4MYTyRQpCw_gV72n2cj88xH7z8c/edit?usp=sharing">slides here</a>). Check it out!</p><iframe width="560" height="315" src="https://www.youtube.com/embed/uN1zuV4DGRY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>The talk tries to answer the question &quot;what is a type?&quot; It seems simple but it&#39;s actually quite tricky! The talk explains how sets can be built constructively (<code>&quot;A&quot; | &quot;B&quot; | &quot;C&quot;</code>), but that the more common approach in TypeScript is best thought of as a subtractive process, where you start from the raw, undifferentiated <code>unknown</code> type and then whittle your way down:</p><img src="/images/unknown-marble.jpg" width="527" height="395" alt="Large block of marble with the word unknown on it" style="max-height: 395px"><p>It then talks about how TypeScript has given us the ability to &quot;carve&quot; out finer and finer details in our types over time, and how that lets us capture more and more errors in our code.</p><p>Overall I&#39;m happy with how the talk turned out. Let me know what you think! All the <a href="https://www.youtube.com/playlist?list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe">tsconf 2021</a> talks are online now. The Anders <a href="https://www.youtube.com/watch?v=V5OnAN63vls&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&index=2">keynote</a> is always a highlight.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;My talk from tsconf 2021, &lt;a href=&quot;https://www.youtube.com/watch?v=uN1zuV4DGRY&amp;list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&quot;&gt;&lt;em&gt;TypeScript Ty
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Exclusive Or and the Optional never Trick</title>
    <link href="https://effectivetypescript.com/2021/11/11/optional-never/"/>
    <id>https://effectivetypescript.com/2021/11/11/optional-never/</id>
    <published>2021-11-11T22:00:00.000Z</published>
    <updated>2021-11-11T14:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Apologies for the <a href="https://effectivetypescript.com/2021/06/03/interface/">long delay</a> between posts. I&#39;ve been busy <a href="https://www.instagram.com/p/CU8hUZwJ3be/">getting married</a> and <a href="https://www.instagram.com/p/CWBG_BGrl31/">climbing</a>. With winter setting in and the wedding behind me, I hope that I&#39;ll find more time for writing.</em></p><blockquote><p>&quot;Do you want coffee or tea?&quot;</p><p>&quot;Yes&quot;</p></blockquote><p>In ordinary speech, &quot;or&quot; means &quot;exclusive or.&quot; Only programmers and logicians use an <em>inclusive</em> or.</p><p>In TypeScript, it&#39;s easy to get mixed up between these two:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>We usually read the last line as &quot;Type <code>Thing</code> is a <code>ThingOne</code> or <code>ThingTwo</code>.&quot; But just like JavaScript&#39;s runtime or (<code>||</code>), TypeScript&#39;s type-level or (<code>|</code>) is an <em>inclusive</em> or. There&#39;s no reason a thing can&#39;t be both a <code>ThingOne</code> <em>and</em> a <code>ThingTwo</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> allThings: Thing = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Why does this work? It&#39;s because TypeScript has a structural type system. Both the <code>ThingOne</code> and <code>ThingTwo</code> types allow additional properties that aren&#39;t declared in their interface (this fact is sometimes obscured by <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks">excess property checking</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> bothThings = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> thing1: Thing1 = bothThings;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> thing2: Thing2 = bothThings;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>So what if you really do want an exclusive or? What if you want to keep your <code>ThingOne</code>s and <code>ThingTwo</code>s separate? How can you model that?</p><p>There&#39;s a standard trick, which is to use an <em>optional <code>never</code></em> type in your interface to disallow a property:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> OnlyThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>  hairColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> OnlyThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>  shirtColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">type</span> ExclusiveThing = OnlyThingOne | OnlyThingTwo;<br></code></pre></td></tr></table></figure><p>Now none of the assignments from before pass the type checker (see <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPIgDYE8AqALUAc3RQG8BYAKGWQGcCowBhAewxagC46woiBuKjTxxgUVuygB+biAgA3aIMoBfKqEixEKdNnxEcAdxbIK1ZCLESO3WrwFC6DZmw4zkcxVGVrKYLAAOKACiAB4IGACutMCK+iCEyAC8aJi4BAkkyAA+qXoZhEYsylQILCB2yABGLGB48YS0yaaO9GIuktwA5FAQACZdADSOluKuXMhdVVEQQ1QqJZRlFWDIdUQAjNy66URZKTV1DbTKAPSnNDQAfje3yDiBEE0sMMgBUCxBjFiTo9ZQXWQcF6yFAZQAtgE4GBgNMIAA6UrlSrrBIAJm2aQaRWah3qBROVHOl2QtzuDyCz1e70+0H8kzajH+gOBKDBLEh0NhGARSJWQIwGGO3DCEWisQgDWaZmJlzJ8vujypbw+X3pXUZHQ4LJB7M5MLhiPMmv+3V6A2G5j+42600is0tCyoQA">playground</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> thing1: OnlyThingOne = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;hairColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> thing2: OnlyThingTwo = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> allThings: ExclusiveThing = &#123;<br><span class="hljs-comment">//    ~~~~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>This works because no value is assignable to a <code>never</code> type. But because the property is <em>optional</em>, there&#39;s exactly one way out: not having that property.</p><p>This isn&#39;t just useful for unions. If you want to define a two dimensional vector type, for example, you might want to specifically disallow adding a third dimension:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>With this type, you&#39;ll get an error if you accidentally pass a three-dimensional vector to a function like <code>norm</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">norm</span>(<span class="hljs-params">v: Vector2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(v.x ** <span class="hljs-number">2</span> + v.y ** <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">const</span> v = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">const</span> d = norm(v);<br><span class="hljs-comment">//             ~ Types of property &#x27;z&#x27; are incompatible.</span><br></code></pre></td></tr></table></figure><p>This wouldn&#39;t be an error without the <code>z?: never</code> because the call is structurally valid, even though it&#39;s semantically incorrect.</p><p>&quot;Tags&quot; are another common way to make an or exclusive:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;one&#x27;</span>;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;two&#x27;</span>;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>A string can&#39;t be both &quot;one&quot; <em>and</em> &quot;two&quot;, so there&#39;s no overlap between these types. This means there&#39;s no distinction between inclusive and exclusive or. This is one of many great reasons to use tagged unions when you can.</p><p>It&#39;s a fun exercise to define an exclusive or generic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;A, B&gt; = <span class="hljs-comment">/* ??? */</span>;<br></code></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwEEA0UBCA+KBeKAegCooB+CqYwgbgFgAoRgSwDtgIAnAMwEMBjaHFYAbEABUAFmwDmw6AG9GUKAGdpnYAGEA9iJ2cAXGuCdZ9Bism9mnXfs5ljrCADcuFgL4t2XPoKhhMSlZcQB3HSglSyhrW3sDY1VTc2U1DW09AycoF3dOL0ZQSCgAUQAPfhEAV1VmdxDWGXxYRCQgiWkm+QwOxplwnWwLRn4dVmSoACMdYEl+1RbolXVbTIdjAHJOCAATTbQ0uLssoyhNqZqIA8ZPEYZCQigpCFVodR1qkV2oXhERabQLicAyqUbjSZzWQARmMfS6chcLRmcwWFkeKhUAD8cbjnuBXlAdNwoGAQZBNCBzscEpxNr8dlA2GMALZgXjAZiXCAAOnBE2AUChTQATHDRJ1QhFkbN5gjVOinpjcXjxATFsTSeSuKBzqtNLT6bxGcydGyOVyRLz+ZM-iIFsYKlVavUIP0lowMcqVSr8ZANSSyToKbrNvr1gYjSbWKz2ZzuXyYuHaVsdvtDjEaactpdqtcM3dGJ6ni83gyhABpG2C8bBBGwsqVGp1BoIj0xFYZFPnNM3BiFhhjAVEiX9MWN50tt1tgjLTFZjbnXP524WIA">Give it a try!</a></p><p>Here&#39;s <a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwBUCMAaKKBMA+KAXgFgAoKCqACnSgDIoBvAbQGsoBLAOygFEAPAMYAbAK4ATCElYQQAewBm2HFhnyl6PAF0A-AC4oXCADcIAJwC+ASigAfMpWq56TNpx4CREqWsXZMUL4a+LoGRqaWVgDcZGTcwOYKAIaC0HBcwiAoABbcAObp0IwOUADOuWbAAMJywnJmBqXAZvkx5FDZSRxmNXVm+oYm5m0WcVwJZsmpUOmZOfkoAO5yTCWd3b31jc2tJeXd1bX1A+HDZKOkoJB8QmKlHKbzXHlEsIhIs1m5z4VYn095JZyPBtMiCORcJpQABGcmA2QBpVexXa+0qmwaUAA5GYIOIsRg1l0ekdMVjoWIIATzqDSAB6OnYbIQUrQcpyUTCcRQJLCYQw6DmMz1UpgiFQ+H5NAGf7fApGV6w+GItoMxwAP01Wuw4BZUD8YGFkEqIGx6xJfSxPNx7nBAFswElgBwKRAAHRiyHAKCS544GUZL4LZaKuEIuWlVWMyha7UoXVIg1G8ygbFow6W63Qbj2x3O10e0jgr08vmIgyeO4PCAA5FkNUx2OxnWQRNKQ1yY2prHpjFWpI2nNyB1Ol3Cd17CoZrbY3H4wntc0YgzkynU0gWWlqnIs6ADtIAaU9UIhczl0puXnujzldfaFF7pJXc-Xm+P3tPQb9FduomvNdvQhVnvDpiWXbEKVEKkFzfUggA">what I came up with</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;T1, T2&gt; =<br>    (T1 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T2, keyof T1&gt;]?: <span class="hljs-built_in">never</span>&#125;) |<br>    (T2 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T1, keyof T2&gt;]?: <span class="hljs-built_in">never</span>&#125;);<br></code></pre></td></tr></table></figure><p>This is roughly the same as the <a href="https://github.com/krzkaczor/ts-essentials/blob/831ba8b6f3600872559c30e875ea74450953dc8a/lib/types.ts#L441-L445"><code>XOR</code> implementation</a> from the <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> library.</p><p>There&#39;s one caveat to the optional <code>never</code> trick that&#39;s worth knowing: unless you set the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/#exact-optional-property-types"><code>--exactOptionalPropertyTypes</code></a> compiler flag (added in TS 4.4), you&#39;re allowed to assign <code>undefined</code> to an optional never field:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br><br><span class="hljs-comment">// OK with just --strict</span><br><span class="hljs-keyword">const</span> v: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><br><span class="hljs-comment">// Error with --exactOptionalPropertyTypes</span><br><span class="hljs-keyword">const</span> w: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><span class="hljs-comment">//                              ~</span><br><span class="hljs-comment">//    Type &#x27;undefined&#x27; is not assignable to type &#x27;never&#x27;.</span><br></code></pre></td></tr></table></figure><p>So remember: in TypeScript, &quot;or&quot; is a union: <code>A | B</code> means either <code>A</code>, <code>B</code>, or both. Remember that &quot;both&quot; is a possibility, and you should either prevent it or handle it in your code.</p>]]></content>
    
    <summary type="html">
    
      This post looks at how TypeScript&#39;s type union operator (&lt;code&gt;|&lt;/code&gt; aka &quot;pipe&quot; or &quot;or&quot;) is really an &lt;i&gt;inclusive&lt;/i&gt; or, and how this can come as a surprise. It presents a few options for getting an &lt;i&gt;exclusive&lt;/i&gt; or if that&#39;s what you want, including the &quot;optional &lt;code&gt;never&lt;/code&gt;&quot; trick.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>In defense of interface: Using declaration merging to disable &quot;bad parts&quot;</title>
    <link href="https://effectivetypescript.com/2021/06/03/interface/"/>
    <id>https://effectivetypescript.com/2021/06/03/interface/</id>
    <published>2021-06-03T21:00:56.000Z</published>
    <updated>2021-06-03T20:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript&#39;s <code>interface</code> has gotten a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a> lately, largely because of <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>, a behavior of <code>interface</code> that&#39;s quite surprising when you first see it. This post explains what declaration merging is, <em>why</em> it is, and how you can use it to iron out some of JavaScript&#39;s and TypeScript&#39;s wrinkles in your own projects.</p><span id="more"></span><hr><p>I recently implemented a multiselect feature on my product at work. For the most part this involved changing my state from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureId: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureIds: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>and tracking down all the resulting errors. But I had a bug! Sometimes I&#39;d click on a feature and it wouldn&#39;t get selected. Or, weirder, it would select a random smattering of other, unrelated features.</p><p>I eventually realized that I&#39;d converted the existing code from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureId(featureId);<br></code></pre></td></tr></table></figure><p>to</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(featureId));<br></code></pre></td></tr></table></figure><p>In my case <code>featureId</code> was something like <code>&quot;357&quot;</code> and, as you can see:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; new Set(&quot;357&quot;)<br>&#123;&quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125;<br></code></pre></td></tr></table></figure><p>The <code>new Set</code> constructor takes an iterable, and JavaScript <code>string</code>s let you iterate over the sequence of their characters. Instead of selecting feature 357, I was selecting features 3, 5 and 7.</p><p>The solution was to change it to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([featureId]));  <span class="hljs-comment">// one element array</span><br></code></pre></td></tr></table></figure><p>Fixing one bug is fine, but it&#39;s better to find a way to make sure that same bug, or a whole class of bugs, never comes back. Since this is a blog about TypeScript, let&#39;s look at how we can use one of TypeScript&#39;s most head-scratching features to prevent ourselves (and our coworkers) from ever passing a <code>string</code> to the <code>Set</code> constructor again.</p><h2 id="What-is-Declaration-Merging"><a href="#What-is-Declaration-Merging" class="headerlink" title="What is Declaration Merging?"></a>What is Declaration Merging?</h2><p>One of TypeScript&#39;s most surprising behaviors is <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">interface</span> Product &#123;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> furby: Product;<br>furby.name;  <span class="hljs-comment">// ok, type is string</span><br>furby.price;  <span class="hljs-comment">// ok, type is number</span><br></code></pre></td></tr></table></figure><p>Even though they may be separated by thousands of lines of code or in entirely different modules, the two declarations of the <code>Product</code> interface are <em>merged</em> into a single type with both <code>name</code> and <code>price</code> properties.</p><p>Declaration merging is surprising and it&#39;s given <code>interface</code> a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a>. <em>Effective TypeScript</em> even suggests using <code>type</code> instead of <code>interface</code> to avoid it (type aliases are not merged; see Item 13: Know the Differences Between <code>type</code> and <code>interface</code>).</p><p>But it&#39;s not all bad! Let&#39;s look at why TypeScript merges declarations before we use this to ban the evil <code>Set</code> constructor.</p><h2 id="Why-Declaration-Merging"><a href="#Why-Declaration-Merging" class="headerlink" title="Why Declaration Merging?"></a>Why Declaration Merging?</h2><p>Declaration merging really shines when you look at the <a href="https://www.typescriptlang.org/tsconfig#lib"><code>lib</code> setting</a> in <code>tsconfig.json</code>, which models the ECMAScript version that will be available at runtime.</p><p>The file <code>lib.es5.core.d.ts</code> <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1220">contains declarations</a> for built-in methods on the <code>Array</code> type as of 2009 vintage ES5:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  length: <span class="hljs-built_in">number</span>;<br>  pop(): T | <span class="hljs-literal">undefined</span>;<br>  push(...items: T[]): <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES2015 added a few new methods, for example <code>Array.prototype.find</code>. When you add <code>es2015</code> to the <code>lib</code> setting in <code>tsconfig.json</code>, TypeScript pulls in <code>lib.es2015.core.d.ts</code>, which <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.core.d.ts#L21-L32">defines those methods</a>, too:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  find&lt;S <span class="hljs-keyword">extends</span> T&gt;(predicate: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">void</span>, value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> value is S, thisArg?: <span class="hljs-built_in">any</span>): S | <span class="hljs-literal">undefined</span>;<br>  find(predicate: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> unknown, thisArg?: <span class="hljs-built_in">any</span>): T | <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The net effect when these declarations are merged is that TypeScript will only know about <code>find</code> if your <code>lib</code> includes <code>es2015</code> (or later). Which is exactly what you want!</p><p>I assume that <code>lib</code> was the motivation behind declaration merging. But you can make use of it in your own code, too. Let&#39;s use it to ban the &quot;evil&quot; <code>Set</code> constructor.</p><h2 id="Banning-the-Evil-Set-Constructor"><a href="#Banning-the-Evil-Set-Constructor" class="headerlink" title="Banning the Evil Set Constructor"></a>Banning the Evil <code>Set</code> Constructor</h2><p>Recall that we want to disallow <code>new Set(&quot;string&quot;)</code> in our own code without affecting other invocations of the <code>Set</code> constructor.</p><p>Here&#39;s the <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.collection.d.ts#L58-L71">declaration of <code>Set</code></a> from <code>lib.es2015.collections.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Set&lt;T&gt; &#123;<br>    add(value: T): <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">delete</span>(value: T): <span class="hljs-built_in">boolean</span>;<br>    has(value: T): <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-keyword">readonly</span> size: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T = <span class="hljs-built_in">any</span>&gt;(values?: <span class="hljs-keyword">readonly</span> T[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>    <span class="hljs-keyword">readonly</span> prototype: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">Set</span>: SetConstructor;<br></code></pre></td></tr></table></figure><p>Sometimes type declarations model the type of an instance (<code>Set</code>) and the type of the class (<code>SetConstructor</code>) separately. In this case we want to merge something into <code>SetConstructor</code>.</p><p>There&#39;s also an <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.iterable.d.ts#L169-L185">overload of the constructor</a> in <code>lib.es2015.iterable.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T&gt;(iterable?: Iterable&lt;T&gt; | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>We&#39;ll want to overload this one. Put this declaration in a <code>.d.ts</code> file somewhere in your project scope, e.g. <code>declarations/ban-evil-set-constructor.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>  <span class="hljs-keyword">new</span> (str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>When this gets merged with the other <code>SetConstructor</code> declarations, the net effect is that the problematic usage will trigger a type error without affecting the others:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&#x27;123&#x27;</span>));<br><span class="hljs-comment">//                    ~~~~~~~~~~~~~~</span><br><span class="hljs-comment">// Argument of type &#x27;void&#x27; is not assignable to parameter</span><br><span class="hljs-comment">//   of type &#x27;ReadonlySet&lt;string&gt;&#x27;.</span><br>setSelectedFeatureIds([<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h2 id="What-else-can-you-do-with-this"><a href="#What-else-can-you-do-with-this" class="headerlink" title="What else can you do with this?"></a>What else can you do with this?</h2><p>That was neat! What else can we do with this technique?</p><p>A TypeScript pet peeve of mine has always been that <code>JSON.parse</code> returns a dangerous <code>any</code> type. This <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1052-L1079">declaration</a> comes from <code>lib.es5.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> JSON &#123;<br>    parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">JSON</span>: <span class="hljs-built_in">JSON</span>;<br></code></pre></td></tr></table></figure><p>A safer return type would be <code>unknown</code>. This type was only <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">introduced in TypeScript 3.0</a> (July 2018) and changing this declaration would be a hugely breaking change for the TypeScript ecosystem as a whole. But there&#39;s no reason you can&#39;t &quot;fix&quot; it in your own project!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> JSON &#123;<br>  parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): unknown;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now you won&#39;t be able to use the result of <code>JSON.parse</code> without going through a type assertion or type guard first:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseType &#123;<br>  lastModifiedAt: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = <span class="hljs-built_in">JSON</span>.parse(apiResponse);<br>obj1.lastModifiedAt;<br><span class="hljs-comment">// ~~~~~~~~~~~~~~~ Object is of type &#x27;unknown&#x27;.</span><br><br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(apiResponse) <span class="hljs-keyword">as</span> ResponseType;<br>obj2.lastModifiedAt; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>You can do something similar with <code>Response.prototype.json()</code>, which is used in the <code>fetch</code> API. Its <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.dom.d.ts#L2622-L2630">declaration</a> comes from <code>interface Body</code> in <code>lib.dom.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Body &#123;<br>  <span class="hljs-keyword">readonly</span> body: ReadableStream&lt;<span class="hljs-built_in">Uint8Array</span>&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">readonly</span> bodyUsed: <span class="hljs-built_in">boolean</span>;<br>  arrayBuffer(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">ArrayBuffer</span>&gt;;<br>  blob(): <span class="hljs-built_in">Promise</span>&lt;Blob&gt;;<br>  formData(): <span class="hljs-built_in">Promise</span>&lt;FormData&gt;;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  text(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you merge in a new declaration for <code>json()</code>, you can get <code>unknown</code> types back instead of <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> Body &#123;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;unknown&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Declaration merging is surprising and controversial, but it&#39;s not all bad. TypeScript uses it to great effect in modeling which library methods will be available at runtime. And you can use it modify or disallow those methods as you like for your project.</p><p>A few notes to conclude:</p><ul><li><p>As with all type-level constructs, this only affects type checking. The runtime behavior the <code>Set</code> constructor is not affected, either in your own code or in library code.</p></li><li><p>This technique is best used either to make the built-in types stricter, or to disallow certain things. If you add declarations that don&#39;t reflect reality at runtime, you can create a really confusing situation. Incorrect types can be worse than no types.</p></li><li><p>Making a constructor return <code>void</code> isn&#39;t itself an error. So calling <code>new Set(&quot;string&quot;)</code> on its own will not cause a type error. You only get the error when you try to use the resulting value, which gets a <code>void</code> type. This is fine in our case, but if the method you want to &quot;knock out&quot; already returns <code>void</code>, then this technique won&#39;t work as well. (link to &quot;user-defined type error&quot; issue)</p></li></ul><p>References:</p><ul><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>.</li><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html#global-modifying-modules">global augmentation</a>.</li></ul><!--References:- KCD tweet about how augmentation makes him prefer `type`: https://twitter.com/kentcdodds/status/1392678508954980353- Item 13: Know the Differences Between `type` and `interface`- Rob Palmer tweet (blog post?) about compiler performance implications of `type` vs. `interface`:  - https://twitter.com/robpalmer2/status/1319188885197422594?lang=en  - https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/  - "9. Generated declarations can inline types from dependencies"- Is "augmentation" the right term for this? Declaration merging?  - https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation  - "Declaration Merging" is the general name  - "Augmentation" refers specifically to patching a module or "global augmentation"- The TS handbook calls out global augmentation as "somewhat dangerous":Notes to hit:- Declaration merging is surprising- Merging works best for adding methods to the standard library, e.g. `lib.dom.d.ts`- The mistake I made with `new Set(string)`-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript&amp;#39;s &lt;code&gt;interface&lt;/code&gt; has gotten a bit of a &lt;a href=&quot;https://twitter.com/kentcdodds/status/1392678508954980353&quot;&gt;bad rap&lt;/a&gt; lately, largely because of &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html&quot;&gt;declaration merging&lt;/a&gt;, a behavior of &lt;code&gt;interface&lt;/code&gt; that&amp;#39;s quite surprising when you first see it. This post explains what declaration merging is, &lt;em&gt;why&lt;/em&gt; it is, and how you can use it to iron out some of JavaScript&amp;#39;s and TypeScript&amp;#39;s wrinkles in your own projects.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Seven Sources of Unsoundness in TypeScript</title>
    <link href="https://effectivetypescript.com/2021/05/06/unsoundness/"/>
    <id>https://effectivetypescript.com/2021/05/06/unsoundness/</id>
    <published>2021-05-07T00:00:00.000Z</published>
    <updated>2023-11-12T17:30:49.895Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/square-peg-round-hole.png" title="A square peg in a round hole" width="212" height="197" style="float: right; padding-left: 10px;">Hang out on the internet much and you&#39;ll hear gripes about how TypeScript isn&#39;t &quot;sound,&quot; and that this makes it a poor choice of language. In this post, I&#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&#39;s never a good idea to listen to people on the internet!</p><span id="more"></span><p>Roughly speaking, a language is &quot;sound&quot; if the static type of every symbol is guaranteed to be compatible with its runtime value.</p><p>Here&#39;s a simple example of a sound type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Math</span>.random();<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>TypeScript infers a static type of <code>number</code> for <code>x</code>, and this is sound: whatever value <code>Math.random()</code> returns at runtime, it will be a <code>number</code>. This doesn&#39;t mean that <code>x</code> could be any <code>number</code> at runtime: a more precise type would be the half-open interval <code>[0, 1)</code>, but TypeScript has no way to express this. <code>number</code> is good enough. If you remember the <a href="https://wp.stolaf.edu/it/gis-precision-accuracy/">famous statistics dartboard</a>, soundness is more about accuracy than precision.</p><p>Here&#39;s an example of unsoundness in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];  <span class="hljs-comment">// type is number[]</span><br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The static type of <code>x</code> is inferred as <code>number</code>, but at runtime its value is <code>undefined</code>, which is not a <code>number</code>. So this is unsound.</p><p>Many programming languages include proofs of soundness, or at least purport to be sound. Fun fact: in 2016, two researchers <a href="https://dl.acm.org/doi/10.1145/2983990.2984004">discovered that Java had become unsound</a>! As we saw above, TypeScript is emphatically <em>not</em> sound. In fact, <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">soundness is not a design goal</a> of TypeScript at all. Instead, TypeScript favors convenience and the ability to work with existing JavaScript libraries.</p><p>That being said, unsoundness can lead to crashes and other problems at runtime, so it&#39;s a good idea to understand the ways that it can arise.</p><p>Here are the seven sources of unsoundness:</p><ul><li><a href="#any"><code>any</code></a></li><li><a href="#type-assertions">Type Assertions</a></li><li><a href="#object-and-array-lookups">Object and array lookups</a></li><li><a href="#inaccurate-type-definitions">Inaccurate type definitions</a></li><li><a href="#the-thing-with-variance-and-arrays">The thing with variance and arrays</a></li><li><a href="#function-calls-dont-invalidate-refinements">Function calls don&#39;t invalidate refinements</a></li><li><a href="#there-are-five-turtles">There Are Five Turtles</a></li></ul><p>For each of these, I&#39;ll assess how common it is in practice, show what it looks like, and explain how you can avoid it.</p><p>Note that this post assumes you&#39;re using <code>--strict</code>. If you&#39;re not, then there are more ways that TypeScript is unsound.</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h2><p><strong>How often does this occur?</strong> It depends how disciplined you are about not using <code>any</code>! But built-ins like <code>JSON.parse</code> that return <code>any</code> make it hard to avoid entirely.</p><p>If you &quot;put an <code>any</code> on it&quot;, then anything goes. The static types may or may not have anything to do with real runtime types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// static type of x is number, runtime type is string</span><br>&#125;<br><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;forty two&#x27;</span>;<br>alertNumber(num);<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The solution here is simple: limit your use of <code>any</code> or, better, don&#39;t use it at all! Chapter 5 of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> is all about how to mitigate and avoid the static type disaster that is <code>any</code>. The highlights are to limit the scope of <code>any</code> and to use <code>unknown</code> as a safer alternative when possible.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><strong>How often does this occur?</strong> Often (though not as often as object and array lookups).</p><p>The slightly less offensive cousin of <code>any</code> is the &quot;type assertion&quot; (<em>not</em> the &quot;cast&quot;, see my <a href="https://effectivetypescript.com/2021/02/03/pet-peeves/">rant on this terminology</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br>alertNumber(x1);<br><span class="hljs-comment">//          ~~ ... Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br>alertNumber(x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>);  <span class="hljs-comment">// type checks, but might blow up at runtime</span><br></code></pre></td></tr></table></figure><p>The <code>as number</code> in the last line is the type assertion, and it makes the error go away. It&#39;s the <a href="https://xkcd.com/149/">sudo make me a sandwich</a> of the type system.</p><p>Type assertions often come up in the context of input validation. You might fetch JSON via an API and give it a type using an assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json() <span class="hljs-keyword">as</span> FunFact;<br></code></pre></td></tr></table></figure><p>Nothing ensures that this API is <em>actually</em> returning a <code>FunFact</code>. You&#39;re simply asserting that it is. If it isn&#39;t, then the static type won&#39;t match reality.</p><p>What can you do about this? You can replace many assertions with conditionals (<code>if</code> statements or ternary operators):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br><span class="hljs-keyword">if</span> (x1 !== <span class="hljs-literal">null</span>) &#123;<br>  alertNumber(x1);  <span class="hljs-comment">// ok, x1&#x27;s type is number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Within the <code>if</code> block, the static type of <code>x1</code> is narrowed based on the condition, so the type assertion isn&#39;t needed.</p><p>For input validation, you can write a <a href="https://basarat.gitbook.io/typescript/type-system/typeguard">type guard function</a> to do some run-time type checking:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunFact</span>(<span class="hljs-params">data: unknown</span>): <span class="hljs-title">data</span> <span class="hljs-title">is</span> <span class="hljs-title">FunFact</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;fact&#x27;</span> <span class="hljs-keyword">in</span> data <span class="hljs-comment">/* &amp;&amp; ... */</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json();<br><span class="hljs-keyword">if</span> (!isFunFact(fact)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Either it wasn&#x27;t a fact or it wasn&#x27;t fun`</span>);<br>&#125;<br><span class="hljs-comment">// type of fact is now FunFact!</span><br></code></pre></td></tr></table></figure><p>Of course, you&#39;re still asserting that your type guard really guards the type. If you want to be more systematic about it, there are many possible approaches. One is to use a tool like <a href="https://github.com/colinhacks/zod">Zod</a> that&#39;s designed to solve this problem. Another is to generate JSON Schema from your TypeScript types (e.g. using <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a>) and validate the shape of your data at runtime using that. <a href="https://github.com/danvk/crosswalk">crosswalk</a> takes this approach.</p><!--The bit about about type guards being unchecked is called out here https://twitter.com/sebmck/status/1142601008251469824--><h2 id="Object-and-array-lookups"><a href="#Object-and-array-lookups" class="headerlink" title="Object and array lookups"></a>Object and array lookups</h2><p><strong>How often does this occur?</strong> All the time.</p><p>TypeScript doesn&#39;t do any sort of bounds checking on array lookups, and this can lead directly to unsoundness and runtime errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// static type is number but runtime type is undefined.</span><br>alert(x.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The same can happen when you reference a property on an object with an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string but runtime type is undefined.</span><br></code></pre></td></tr></table></figure><p>Why does TypeScript allow this sort of code? Because it&#39;s extremely common and because it&#39;s quite difficult to prove whether any particular index/array access is valid. If you&#39;d like TypeScript to try, there&#39;s a <a href="https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess"><code>noUncheckedIndexedAccess</code></a> option. If you turn it on, it finds the error in the first example but also flags perfectly valid code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><span class="hljs-keyword">const</span> x2 = xs[<span class="hljs-number">2</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x2.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p><code>noUncheckedIndexedAccess</code> is at least smart enough to understand some common array constructs:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>  <span class="hljs-built_in">console</span>.log(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-keyword">const</span> squares = xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);  <span class="hljs-comment">// also ok</span><br></code></pre></td></tr></table></figure><p>If you&#39;re concerned about unsafe access to specific arrays or objects, you can explicitly add <code>| undefined</code> to their value types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs: (<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><br><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string | undefined</span><br>alert(agent.toUpperCase());<br><span class="hljs-comment">//    ~~~~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p>The advantage of this approach over <code>noUncheckedIndexedAccess</code> is that it lets you limit the scope (and presumably false positives) of that flag. The disadvantage is that it lacks the smarts of the flag: the <code>for-of</code> loop will give you errors with this approach. It also introduces the possibility that you <code>push</code> an <code>undefined</code> onto the array.</p><p>Finally, it&#39;s often possible to rework your code to avoid the need for these sorts of lookups. Say your API looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuItem &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  displayText: <span class="hljs-built_in">string</span>;<br>  icon?: <span class="hljs-built_in">string</span>;<br>  hoverText?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This API is very likely to lead to lookups in the <code>onSelectItem</code> callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125; = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>Menu(&#123;<br>  menuItems,<br>  <span class="hljs-function"><span class="hljs-title">onSelectItem</span>(<span class="hljs-params">id</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> menuItem = menuItems[id]; <span class="hljs-comment">// oh no! object lookup!</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Instead, you might pass the <code>MenuItem</code> itself to the callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">menuItem: MenuItem</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is safer from a static types perspective.</p><h2 id="Inaccurate-type-definitions"><a href="#Inaccurate-type-definitions" class="headerlink" title="Inaccurate type definitions"></a>Inaccurate type definitions</h2><p><strong>How often does this occur?</strong> Surprisingly rarely, but it&#39;s annoying and surprising when it does!</p><p>The type declarations for a JavaScript library are like a giant type assertion: they claim to statically model the runtime behavior of the library but there&#39;s nothing that guarantees this. (Unless, that is, the library is written in TypeScript, the declarations are generated by <code>tsc</code> and the library doesn&#39;t break any of the rules in this post!)</p><p>It&#39;s hard to show a specific example here since these kinds of bugs tend to get fixed once you highlight them, particularly for declarations on DefinitelyTyped. But here&#39;s <a href="https://github.com/alex3165/react-mapbox-gl/issues/776">one example</a> in react-mapbox-gl that&#39;s been around for years. (Not to pick on react-mapbox-gl, we love you alex3165!)</p><p>How do you work around this? The best way is to fix the bug! For types on DefinitelyTyped (<code>@types</code>), the turnaround time on this is usually a week or less. If this isn&#39;t an option, you can work around some issues via <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">augmentation</a> or, in the worst case, a type assertion.</p><p>It&#39;s also worth noting that some functions have types that are just very hard to model statically. Take a look at the parameter list for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter"><code>String.prototype.replace</code></a> for a head-scratching example. There are also some functions that are <a href="https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598">incorrectly typed for historical reasons</a>, e.g. <code>Object.assign</code>.</p><h2 id="The-thing-with-variance-and-arrays"><a href="#The-thing-with-variance-and-arrays" class="headerlink" title="The thing with variance and arrays"></a>The thing with variance and arrays</h2><p><strong>How often does this occur?</strong> I&#39;ve never personally run into this, but I also tend not to use very deep or complex type hierarchies.</p><p>This is a famous one. TypeScript TL <a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> <a href="https://github.com/microsoft/TypeScript/issues/9825#issuecomment-234115900">offers</a> this example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat()];<br>addDogOrCat(z); <span class="hljs-comment">// Sometimes puts a Dog in a Cat array, sad!</span><br></code></pre></td></tr></table></figure><p>What can <em>you</em> do about this? The best solution is to avoid mutating array parameters. You can enforce this via <code>readonly</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: <span class="hljs-keyword">readonly</span> Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>  <span class="hljs-comment">//  ~~~~ Property &#x27;push&#x27; does not exist on type &#x27;readonly Animal[]&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will prevent this type of unsoundness. Instead, you might write the example this way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogOrCat</span>(<span class="hljs-params"></span>): <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat();<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat(), dogOrCat()];<br><span class="hljs-comment">//                           ~~~~~~~~~~ error, yay!</span><br><span class="hljs-comment">// Type &#x27;Animal&#x27; is missing the following properties from type &#x27;Cat&#x27;: ...</span><br></code></pre></td></tr></table></figure><p><em>(See <a href="https://www.typescriptlang.org/play?ssl=5&ssc=1&pln=6&pc=1#code/MYGwhgzhAECCB2BLAtmE0DeBfAsAKH1EhgFkxlV0BTADwBcr4ATGBFNTfaaRCMitAF46AJwCuVANz5cBPESjQAwmDrRaDZqXKVOebrxV1h4qVx4QAIgHsA5oIBmaCGbyzC4RTdvr6jFtD8uhjmvN4mEtL6FkaOzq7ueA5i8MB0iNbw0GBMTN4A8iJGABRgIiIAXHBIlADaALoAlHrcZSIAdAAOYhAAFsVkdL3tImDM1sjFzQB80AAM7QCs0AD80PBUAO7Q3lPQVRvbJY2NUYnJqemZ0LZUdEHOU1UPIA0t0CJ3YiJZDWf4+AA9IDoAAhfAXNIZLK9SAlNpVNh1JrvT50b5ZNrtCATKjFKjQQSzAmIeAQOhjYBUawOZSqU4yQiZcnQGjPHRoN6CG53F4QKZRYDMtQAT0J0FhEBKNAZcmByiZZLUAC8qkYudBaoc6XQpvUojk8nZCiVladoPL5QBlXHpZBUGDdOgwMA7Ow8TE67LlMAigA00AgOQAhPggA">full playground example</a>.)</em></p><p>Why does TypeScript allow this? Presumably because <code>readonly</code> wasn&#39;t always part of the language. In the future you could imagine a &quot;strict&quot; option that would prevent these types of errors. In the initial example, the <code>addDogOrCat</code> call should only be allowed with a subtype of <code>Animal[]</code> if it&#39;s declared as <code>readonly Animal[]</code>. This will have the side effect of pushing libraries to get better about declaring parameters <code>readonly</code>, which would be a very good thing!</p><p>TypeScript used to have more issues around function calls and variance, and you might still see gripes about this online. But these were largely fixed with <code>--strictFunctionTypes</code>, which was <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#strict-function-types">introduced with TypeScript 2.6</a> in November 2017.</p><h2 id="Function-calls-don-39-t-invalidate-refinements"><a href="#Function-calls-don-39-t-invalidate-refinements" class="headerlink" title="Function calls don&#39;t invalidate refinements"></a>Function calls don&#39;t invalidate refinements</h2><p><strong>How often does this come up?</strong> I&#39;ve rarely seen it myself, though this may depend on your style and the libraries that you use.</p><p>Here&#39;s some code that doesn&#39;t look too suspicious at first glance (at least from a type safety perspective):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> FunFact &#123;<br>  fact: <span class="hljs-built_in">string</span>;<br>  author?: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (fact.author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = fact.author.blink();  <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Depending on what <code>processor</code> does, however, the call to <code>blink()</code> might throw at runtime:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">&#x27;Peanuts are not actually nuts&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>);<br><span class="hljs-comment">// Type checks, but throws `Cannot read property &#x27;blink&#x27; of undefined`.</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>if (fact.author)</code> refines the type of <code>fact.author</code> from <code>string | undefined</code> to <code>string</code>. This is sound. However, the call to <code>processor(fact)</code> <em>should</em> invalidate this refinement. The type of <code>fact.author</code> should revert back to <code>string | undefined</code> because TypeScript has no way of knowing what the callback will do to our refined fact.</p><p>Why does TypeScript allow this? Because most functions don&#39;t mutate their parameters, and this sort of pattern is common in JavaScript.</p><p>How can you avoid this? A simple way is to avoid deeply mutating your parameters. You can enforce that callbacks do this by passing them a <code>Readonly</code> version of the object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: Readonly&lt;FunFact&gt;) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">`Peanuts aren&#x27;t actually nuts`</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>  <span class="hljs-comment">//          ~~~~~~~~</span><br>  <span class="hljs-comment">// The operand of a &#x27;delete&#x27; operator cannot be a read-only property.</span><br>);<br></code></pre></td></tr></table></figure><p>(Note that <code>Readonly</code> is shallow; you&#39;ll need to use a tool like <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> to get a <code>DeepReadonly</code>.)</p><p>You can also avoid this issue by refining a value itself, rather than the object that contains it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;author&#125; = fact;<br>  <span class="hljs-keyword">if</span> (author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = author.blink();  <span class="hljs-comment">// safe</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Because <code>author</code> is a primitive type (not an object), it cannot be changed by the callback and the <code>blink()</code> call is safe.</p><!--Here's an alternate example using refinements from string|number and a global (via https://twitter.com/sebmck/status/1146524039227174914):https://www.typescriptlang.org/play?strict=true#code/DYUwLgBAbghsBcEB2BXAtgIxAJwgHwgGcxsBLJAcwgF4IByOgbgChmAzFJAYzFIHskEGIUKkKSAHLos2ABQBKCAG9mEaHBoQATCwC+rDt14CIaGOQXLVEUmwiywATwAOIPndjAa1WnVSYcOkUVNTUwAAtsPgB3ZBBYgFFsKLk6CT5kaRxCIWBgGJAAEyCWNX1rAHoKiAARATpIJBAioSRHGyRC0mwQHn5BcJwQa2FRcSkAuXkWSuqAFXDSHMJwvhRgQog2c2AAGhswOhyYTMnrLgFiIhJEYjJKTU89IA--><h2 id="There-Are-Five-Turtles"><a href="#There-Are-Five-Turtles" class="headerlink" title="There Are Five Turtles"></a>There Are Five Turtles</h2><p><strong>How often does this come up?</strong> More or less never; if you run into it in real-world code, you might get mentioned at tsconf!</p><p>Anders explains this best:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/wpgKd-rwnMw?start=1714" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>I&#39;ve never been able to find the issue he references in the talk. And I&#39;ve heard rumors that there are now seven turtles. If you know more about either of these, please let me know in the comments!</p><hr><p>Those are the seven sources! But maybe there are eight, or nine, or ten. If you have an example of unsoundness that doesn&#39;t fit into any of these categories, please <a href="https://twitter.com/danvdk">let me know</a> and I&#39;ll update the post.</p><p>Updates:</p><ul><li><a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> offers <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhjAvDAFADwPwC4ZgK4C2ARgKYBOAlEgHwyYB0UIAYgJZokAmKFA3ALAAoUJFhEcPGjABuIVpyTwBw8NBjAJEbDGhlWYAOZVEtWfMVFlwFACIbfIUA">an example</a> that stems from how TypeScripthandles function assignability and optional parameters.</li><li>Ryan offers <a href="https://twitter.com/SeaRyanC/status/1397979078150344707">another example</a> stemming from a loss of information when you assign to a type with optional properties.</li><li>Oliver Ash <a href="https://twitter.com/OliverJAsh/status/1404719755324497922">offers</a> <a href="https://www.typescriptlang.org/play?strict=true#code/MYewdgzgLgBAhjAvDA3jAZiEAuV9cAUAlEgHwwDkcFMAvnQNwBQoksARknpjnu4SUTkK7GvVrMW4aDAC2AUwBOAc3lcAPAEEANDABCpAnFw6Y-fYPIE0AOjtxddm51pFmrGcC4KV8o7vY3FhseGzhiBhgAeiiYMBAYABUAZRglRRBFMwBXWCgACwyAdwh4WEVssCgASwUAQgbg0PYIpik2GAATLhQnBxgndgkmTpCsMIiYaNj0zJGxkGdWoA">an example</a> stemming from how TypeScript models object spread as a deep intersection between generics whereas it really operates as a shallow intersection. See <a href="https://github.com/microsoft/TypeScript/issues/28326">design notes</a> on this issue.</li></ul><!--Another one from Ryan around assignability issues with optional properties and index signatureshttps://twitter.com/SeaRyanC/status/1397979078150344707Is this related to my issues?https://github.com/microsoft/TypeScript/issues/41418https://github.com/microsoft/TypeScript/issues/43045Or related to distinguising undefined and missing?https://github.com/microsoft/TypeScript/issues/13195Anders has a PR out to fix this!https://github.com/microsoft/TypeScript/pull/43947--><p>Further reading:</p><ul><li><a href="https://frenchy64.github.io/2018/04/07/unsoundness-in-untyped-types.html">Are unsound type systems wrong?</a>, a discussion of types of soundness and TypeScript&#39;s deliberate choice to be unsound (see also <a href="https://news.ycombinator.com/item?id=16780068">HN Comments</a>).</li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness">A Note on Soudness</a> from the TypeScript handbook; this page gives background on some of TypeScript&#39;s design decisions.</li><li><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&q=209#example/soundness">TypeScript Playground Soundness example</a>; this is a built-in example on the TypeScript Playground. Note that it does not have <code>strictFunctionTypes</code> enabled.</li></ul><!--https://github.com/microsoft/TypeScript-Handbook/issues/1059No excess property checks in object types with spread-> This is not unsoundness, just misunderstanding excess property checkingIncorrect definition of spread and Object.assign-> This is a spurious error, but that's not unsoundness, is it?-> This just seems like a bug-> Can easily be modified to be unsound.See https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598Maybe this falls under "incorrect library definitions"?Hacker News thread from 2017:https://news.ycombinator.com/item?id=15659657  Counterexamples here seem to revolve around variance, which has not been an issue for a while.Luca Cardelli, 1996 (quoted in _Types and Programming Languages_):> It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/square-peg-round-hole.png&quot; title=&quot;A square peg in a round hole&quot; width=&quot;212&quot; height=&quot;197&quot; style=&quot;float: right; padding-left: 10px;&quot;&gt;Hang out on the internet much and you&amp;#39;ll hear gripes about how TypeScript isn&amp;#39;t &amp;quot;sound,&amp;quot; and that this makes it a poor choice of language. In this post, I&amp;#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&amp;#39;s never a good idea to listen to people on the internet!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
