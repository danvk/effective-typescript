<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2022-02-28T14:14:19.792Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The display of types</title>
    <link href="https://effectivetypescript.com/2022/02/25/gentips-4-display/"/>
    <id>https://effectivetypescript.com/2022/02/25/gentips-4-display/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2022-02-28T14:14:19.792Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: The display of types</li></ul><p>We talk all the time about how to define and use types in TypeScript, but we rarely talk about how TypeScript chooses to <em>display</em> our types. There are often several possible ways to display the same type, and the choice can have a big impact on the usability of your library. TypeScript tries to make good decisions on its own about type display, but it also gives us a few levers by which we can control it ourselves.</p><p>Let&#39;s dive in to the strange world of type display!</p><!-- more --><p>Suppose you have a <code>Comments</code> table in your database and you&#39;ve defined a <code>selectComments</code> function. As you prepare to call it, TypeScript shows you some type information:</p><img src="https://effectivetypescript.com/images/type-bad.png" width="579" height="98" title="Cryptic type display"><p>This leaves something to be desired. One issue is that it feels a bit &quot;implementation-y&quot;: why should I care that the parameter is constructed using <code>Pick</code> and an intersection (<code>&amp;</code>)? It&#39;s also a bit opaque. Is <code>author_id</code> nullable? What about <code>metadata</code> in the return type? What&#39;s its type? And is <em>it</em> nullable?</p><p>It&#39;s hard to answer these questions without wading through some type declarations or experimenting.</p><p>Here&#39;s an alternative display of exactly the same types:</p><img src="https://effectivetypescript.com/images/type-better.png" width="565" height="94" title="Clearer type display"><p>This is much better. All hints of the metaprogramming that went into deriving this type are gone, and you can see exactly what the type of each field is. <code>author_id</code> is not nullable, but <code>metadata</code> is. The type of <code>metadata</code> is <code>CommentMetadata | null</code>.</p><p>When you&#39;re writing code that works with types, you should consider safety and correctness first and foremost. But once you have those, you should <em>also</em> consider how your types display. The rest of this post walks through some of the techniques that you can use to change how TypeScript displays a type.</p><h2 id="Resolving-a-type"><a href="#Resolving-a-type" class="headerlink" title="Resolving a type"></a>Resolving a type</h2><p>This is the situation described above. TypeScript is showing a generic type expression (often involving <code>Pick</code>) and you&#39;d like it to do a little more work to resolve that type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;</span>;<br><br><span class="hljs-keyword">const</span> c: Color = &#123; <span class="hljs-attr">r</span>: <span class="hljs-number">255</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">0.5</span>&#125;;<br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: Pick&lt;Color, &quot;r&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>Here&#39;s the magic incantation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Resolve&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span> ? T : &#123;[K <span class="hljs-keyword">in</span> keyof T]: T[K]&#125;;<br></code></pre></td></tr></table></figure><p>(<code>Resolve</code> is my choice of name. This type alias also goes by <code>Simplify</code> or <code>NOP</code> or <code>NOOP</code>.)</p><p>This is an odd-looking type to be sure. Both cases of the conditional type are variations on the identity function. It doesn&#39;t look like it should do anything at all! But our goal isn&#39;t to change the type so much as to change how it&#39;s displayed, and, for whatever reason, this does the trick:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Resolve</span>&lt;<span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: &#123; r: number; &#125;</span><br></code></pre></td></tr></table></figure><p>(The conditional type <em>does</em> seem to be necessary: <code>type Resolve&lt;T&gt; = &#123;[K in keyof T]: T[K]&#125;</code> does not resolve this type in the same way.)</p><p>This trick is also helpful in resolving the intersection types like <code>T[K &amp; keyof T]</code> described in part 2 of this series: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a>. For example, here&#39;s the code from the start of this post:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Select&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>&gt; &#123;<br>  (<br>    where:<br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectComments: Select&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectComments()<br><span class="hljs-comment">// ^? let selectComments: Select</span><br><span class="hljs-comment">//    (where: Pick&lt;Comment, &quot;author_id&quot; | &quot;doc_id&quot;&gt; &amp; &#123;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>The <code>Select</code> function takes a table type and two sets of keys: one containing the columns that have to be set to a specific value and one containing the columns that may be any value in a set. The resulting function call has a parameter with that tell-tale implementation-y look.</p><p>As you&#39;d hope, <code>Resolve</code> makes short work of this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">interface</span> SelectResolved&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>  &gt; &#123;<br>  (<br>    where: Resolve&lt;        <span class="hljs-comment">// &lt;-- Resolve added here</span><br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>    &gt;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectCommentsResolved: SelectResolved&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectCommentsResolved()<br><span class="hljs-comment">// ^? let selectCommentsResolved: SelectResolved</span><br><span class="hljs-comment">//    (where: &#123;</span><br><span class="hljs-comment">//        author_id: string;</span><br><span class="hljs-comment">//        doc_id: string;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>All vestiges of the implementation of this type are gone and we&#39;re left with a clean display. Hooray! (Full example on the <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osE4EWANJ2XBwVXARDe4ol6LFedlnIWavIVCuiIZgAKAjQqtb4rnHYYcHPl+vcAXADJl6v12395MnC5UAAypowAjs2kilOUwDFKKkgAOpCg8HhyIMPZ4H2H5rgKEEKNBkhATASEoSAvaDCumElGUOFMB2oSsAAFJIrByghwCRIxrAPheV7YVB4rwVkwCER2r7sawM7zoucD4YRm5SYoraUVBEnvmR66KRuHZ5KwACU0SnlAWAesACmQe2uSWBoaByDwqBaDEwEjky+BENEQEKKBTkwOK3CnOcUCXJwUjqNsAXecsnDfkwGbuQRVTOXR2m1EUAB645MEAA">playground</a>.)</p><p>The <code>Resolve</code> alias can sometimes resolve <code>keyof</code> expressions. More on this below.</p><p><em>h/t to <a href="https://stackoverflow.com/users/5827215/tadhg-mcdonald-jensen">Tadhg McDonald-Jensen</a> on Stack Overflow for <a href="https://stackoverflow.com/a/69976234/388951">introducing</a> me to this helpful type alias!</em></p><h2 id="Special-casing-important-types"><a href="#Special-casing-important-types" class="headerlink" title="Special-casing important types"></a>Special-casing important types</h2><p>Sometimes the display of a type is bad for a specific, important case of your generic. In these situations it can be worthwhile to handle those cases specially using a conditional type.</p><p>For example, say you have a function that can either select all the columns from a table or just a few specific columns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Pick&lt;TableT, Cols&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br></code></pre></td></tr></table></figure><p>It makes sense that the <code>Cols</code> type parameter defaults to <code>keyof TableT</code> since that corresponds to selecting all the columns and <code>Pick&lt;T, keyof T&gt; = T</code>.</p><p>The type <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMSZOFyoADKmmAaBgAHlcMAADylcrAYrijxyQagXmiQaq4CIb09hTFRhwCdTgUzvsAPkWrFYAAo5UKHtFgntrodjDkAJTRAAKAjQqu7ZVnA4gQ9XuUsGjQch4qC0cGMiiZfAACFEAASSuRsFBbdsu0AmBX0sDBzXgbN4AYP8AKqYCwNELdDyuTgAEYACYAGZOHPCxCk3OAAD0AH4gA">doesn&#39;t display very cleanly</a> when we use the function, though:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Pick&lt;Comment, keyof Comment&gt;</span><br></code></pre></td></tr></table></figure><p>This is cryptic and quite implementation-y. And the <code>Resolve</code> trick doesn&#39;t quite do what we want here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- Resolve</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: &#123;id: string; doc_id: string; author_id: string, ...&#125;</span><br></code></pre></td></tr></table></figure><p><code>Resolve</code> has fully inlined this type. What it&#39;s displaying is exactly equivalent to <code>Comment</code>, but that&#39;s hard to tell without a careful comparison. It would be much nicer if it just said <code>Comment</code>!</p><p>You can improve the display here by explicitly checking for the default case:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>  (where: &#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> &#125;):<br>    keyof TableT <span class="hljs-keyword">extends</span> Cols       <span class="hljs-comment">// &lt;-- conditional type</span><br>    ? TableT                        <span class="hljs-comment">// &lt;-- special case</span><br>    : Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- default case</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Comment</span><br></code></pre></td></tr></table></figure><p>Much better! Here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osEiwBpOy4OCq4CIb3FEvRYpzks5CxMSZOFyoADKmmAI4A8rhgK2ygpiuKPHJBj28H2lyu13fgMVO8vVwKpTlD+HahKwrAABRykKDzTns1yHMYOQAJTRP+X7Ab+r4GIMT6DJOQH3nA0T1kQjYtgACgIaCqremGPo2RBtm2uSWBoaByDwqBaHAxiKEy+AAEKIAAklcp4KJe17NgJMAsZYGDmvA2bwAwvH8VUQmiaIEHBPBnAAIwAEwAMycChFiFOBcAAHrjmx56cQ8cA8XxMCyXh0QSeeMBXjesnipwyycFI6jbJcIVqHSrJkJF0g2jm9qcPJimeipx4oGgAhAmgeGdm5HmMbp+nGWZFm1EU4F2UwQA">full playground</a> for this example.</p><h2 id="Other-techniques-that-don-39-t-work-as-well"><a href="#Other-techniques-that-don-39-t-work-as-well" class="headerlink" title="Other techniques that don&#39;t work as well"></a>Other techniques that don&#39;t work as well</h2><p>There are a few other techniques I&#39;ve run across for simplifying type display that don&#39;t work as well as <code>Resolve</code>. They&#39;re included here for completeness. If you&#39;re using them, you may as well just use <code>Resolve</code> instead.</p><h3 id="Exclude-lt-keyof-T-never-gt"><a href="#Exclude-lt-keyof-T-never-gt" class="headerlink" title="Exclude&lt;keyof T, never&gt;"></a><code>Exclude&lt;keyof T, never&gt;</code></h3><p>This can be used to inline the display of <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> Chan = keyof Color;<br><span class="hljs-comment">//   ^? type Chan = keyof Color</span><br><span class="hljs-keyword">type</span> ChanInline = Exclude&lt;keyof Color, <span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">//   ^? type ChanInline = &quot;r&quot; | &quot;g&quot; | &quot;b&quot; | &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>The <code>Resolve</code> trick <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIHsA26rIN7JQBcyIArgLYBG0A3MgOYnnV3JXOU1T1yeu4AvrQBQIsAE8ADigBKEAM5YAbhAA8AFQB8yALzINyCAA9IIACYLkAMTIgEYYOhDIA-AeQk8AbQDSyUGQAawgJdBgDAF0SDT9I4XFpFFQACzgXfXklTFU1ELCIjGwoLVEAejLkKoA9d0kZNDSM5AAiKBbkAB9Whg7ulqo+1rgWsQRnBTBkBBIinD18QhIAJgBWVYAaRhIARmWADi2OZAAGLb5TgDpVhPMIBEw4KBQYOwcnFwYIMFT0kAhMAAKGZoLA4LYIJokLIqdT5cKg4paACU-G4ojGEymuH0Xx+TX+QIQGzEFWQAAUyFMwmRcAhaUpcHApmAUigIBZkAjWSgpM9lE4yFZMKAUOlzMgaQByTCYZAKCAQIgiMl434gQnA2ZgqAQqHBUIIuZQVGkLjQFVlS3IADubOecCsAEkpRKRSFkGB0PLFcrVd91ZqQca9ekSG0hi1el1WoMYy0RqaWNwREA">works just as well</a> in this case, and can resolve many types that excluding <code>never</code> cannot. So just use <code>Resolve</code>.</p><p>Side note: why does TypeScript display <code>keyof</code> types in this way? Prior to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">TypeScript 4.2</a>, TypeScript <em>always</em> inlined <code>keyof</code> display. This sometimes led to comical results:</p><img src="https://effectivetypescript.com/images/keyof-button.png" width="907" height="78" title="keyof HTMLButtonElement showing a union of 260 string literal types"><p>Count &#39;em, that&#39;s a union of 260 string literal types! Newer versions of TypeScript simply display this as <code>keyof HTMLButtonElement</code>, which seems like a win. But I think they <a href="https://github.com/microsoft/TypeScript/issues/42322">threw the baby out with the bathwater</a> here; for the common case of small unions (say less than 10 strings), it&#39;s clearer to <a href="https://twitter.com/danvdk/status/1414343269522227207">just show the type union</a>. This makes the behavior of <code>keyof</code> much easier to understand. Perhaps someday this will improve and we won&#39;t need to <code>Resolve</code> this type.</p><h3 id="unknown-amp-T"><a href="#unknown-amp-T" class="headerlink" title="unknown &amp; T"></a><code>unknown &amp; T</code></h3><p>I learned about this one from Titian&#39;s <a href="https://stackoverflow.com/a/56416192/388951">classic answer about typing <code>_.invert</code></a> on Stack Overflow. Sometimes you can replace <code>TypeExpr</code> with <code>&#123;&#125; &amp; TypeExpr</code> or <code>unknown &amp; TypeExpr</code> to force TypeScript to resolve a type.</p><p>You can see an example of this technique working in <a href="https://www.typescriptlang.org/play?#code/PTAEBUEsBdIQwHYHIDOpoE8AOBTNAzAJwHsBbUAC2mixQC4QVo4BjAa2IDcdD8AbYgHcAdCzLA4wAKwA2ACwBGGQoCcAJmABmABzaVUhQChMuUAEE+fAGpw+AVzwAecKBwAPaDgQATNACUcMUJvRwAFElxCTABpHAwAGlBw4kiYuIA+dNAAXlAAb0NQItAAbVDQSARQNjjifAgAXTp86rjm0MTOWwdm8DKG0ABfQ0GSmow6xoBuY2wcUABJBG4ogJQ7PmhnVw8vX1AAoJDk1IxYhKSInjSMTJz8wuKyiqqLa26ncHSSpC77HCQDSaoAAoh5CKwtm8bP8UM50ok8qA-j0kkNvkhxoCZoMZoYxAgmKBiPcCsVQHBmkg3Eh4o8igAjKkYWkjCloAlMPEmeYuXJLFbQNYbLY8ybEdIzEBFAB6AH5DLNTALrsLNgAhHDUHjbdyeHz+QLEYJhK5RM5xRIna4W25ZXJ2BBsBBCKoAMge5OelXMlhhDjhXx+KIBQOaYOgEJYUL9H0DCJaIfa6J+WIaOLx3kCfDghHm+Ed0cgxCqlUFut2BoORpN1vN5ytZpumQAFMQGQArXoASmaKtWeBF8JmWZYObzoALCCLJZegs12sIFf1+0OxuOTdtjZSNvOrfbXYgvcWy1Vg41Ws8S6+I+zufzhdgs7LZ5QxD43BCLj1e0NR1NO71palyAc26Rtp2PbNGs77cI4-ZCueWxfJKirSuAFCQGgFBwGgiCgAARJApBYHwOCkF4zBPggGAEegcygN4WGkXAGDCKAADqOHQKgJ6Cmq0AKpy0BzvcL5RG23ZSmAxTymhYBmN4TEIAA5hSoCCDglgALQsSwODeKAAAGjrOq6oBukZoCkHANRoDAjHMTmGDWca8xjjgiB8BgdD4iWRJlmoYmnlEC5XpJ0nknJhjSmY1Zvh+OCOFkrCYTg3BoNAFDzCgcAUaAebrJsvnCXOmjBfxeCwQZEUxTJsoKvJECYfZeFVLYV4IHAsDcBUJFkRRCBUcWVQoBQQiVGpWXzN4EKCAyrBsGgkwmU6LqCO6Vn4O+AiCJNdWUNQtAMMAOD4PggQ9VqcwoCwhCQFg0CiOIagAAxvcAr1SMACgaI6I2QAAXjg2kHpdkD4BgwCKjyoAAKoIADwPLr+xKdpd9qeqUbAvK0Ez1OAwJ5GwzRsFMyK9GMDTDKM4yTIT3IMdEVihHAkCEKSJMgac5zk5wzSmetCDDLDADy6NFpDKNVszrPs5jZLY7jfSYoCwIRlGyGIlzbCDBinCAiMjOmAAyoIcBYMz8I5I836VvsxPNJUF0c9EnROwgLugFYwxFHK+Rc1YfPNNE5ODEU0qONp2mgC6njoNloAoObWAAISPM0CDpTwxvzDBiXW7kdsrmgABij4jaA-suM0eQlNEuN0wTwJ9NE1MzLDCFw6L0v7GD0aY+LHbg1LZsW1bCNI0lKEWaAsts4QqFKvMXei-nn698tEvQJj69JUPI8YI4Y+W1YjiTyWQPT3cHrz-LS+juOD7TtRc7XN3m-Vv+dY3NuPMZOBA8UE+Lvx7jeQwj97yTgrs+EK0Bu57y-DsEuX91wAX-hcH+tp9yQSPH2OBCCqqJS-EvdCLUKR8DfJQXCFIqhEX6uRSi3URq0XoqYJiKAWI+T8oSESZY4YklyOJeBotarSlko1aUe9kqTkgG4PAFRoCJAZHYESEw7CgBYIgJAIk4BKWMoLcyllaEYEENlCc0ASTeBJDAYQPCArLAEUFIRBC15EM-GI+qoA5JAA">this playground</a>. I&#39;ll spare you the full details, but from hard-earned experience I&#39;ve learned that this trick is much more finnicky than <code>Resolve</code>. Just use <code>Resolve</code> instead.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While it may seem that you&#39;re stuck with however TypeScript chooses to display your type, that&#39;s not actually the case! You do have a few levers at your disposal. The <code>Resolve</code> alias is wonderful for removing implementation details from generic types. And where it doesn&#39;t work, you can sometimes add a special case to get the display that you want.</p><p>Remember that <a href="https://twitter.com/SeaRyanC/status/1414347018646921216">all representations are equally valid</a>, and that the TypeScript team might choose to change the display of your type at any time (as <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">happened</a> with <code>keyof</code> in TypeScript 4.2). So once you&#39;ve got your types displaying the way you like, it&#39;s worth writing some tests to make sure they stay that way. Tools like <a href="https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, which make assertions about the textual display of types, are the way to go here.</p><p>Do you have other tricks for controlling type display? Let me know <a href="https://twitter.com/danvdk">on Twitter</a> or in the comments below.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We talk all the time about how to define and use types in TypeScript, but we
rarely talk about how TypeScript chooses to &lt;i&gt;display&lt;/i&gt; our types. There
are often several possible ways to display the same type, and the choice can
have a big impact on the usability of your library. TypeScript tries to make
good decisions on its own about type display, but it also gives us a few very
obscure levers by which we can control it ourselves.&lt;/p&gt;
&lt;p&gt;Let&#39;s dive in to the strange world of type display!&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A TypeScript Perspective on Go: the 2021 Advent of Code</title>
    <link href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/"/>
    <id>https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/</id>
    <published>2022-02-06T23:00:00.000Z</published>
    <updated>2022-02-07T14:51:09.127Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">It&#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.</p><p>My favorite way to learn a new language is through the annual <a href="https://adventofcode.com">Advent of Code</a> (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. In 2019 I <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">did it in Python</a> (not a new language for me) and in 2020 I <a href="https://effectivetypescript.com/2021/03/24/advent-of-code/">did it in Rust</a> (which was a new language). This year, I did it in Go (aka Golang).</p><p>This post has three parts:</p><ul><li>My impressions of Go (coming from a TypeScript perspective)</li><li>My impressions of this year&#39;s Advent of Code</li><li>Notes and links for each day</li></ul><span id="more"></span><h2 id="My-Impressions-of-Go"><a href="#My-Impressions-of-Go" class="headerlink" title="My Impressions of Go"></a>My Impressions of Go</h2><p>I first used Go when I was working at Google in 2011. C++ was my main language at the time, so Go wasn&#39;t such a big shift. I remember finding it quite confusing until I really &quot;got&quot; the idea of duck typing: the consumer of an interface defines what it needs and the producer doesn&#39;t need to declare that it implements this interface. I didn&#39;t have much use for Go in my work or personal projects, so I mostly forgot about it.</p><p>Some parts of Go&#39;s design that seemed strange in 2011 have aged quite well: automatic formatting of source code is very standard now, and I certainly didn&#39;t mind Go complaining about unused symbols. One thing that I found confusing in 2011 and still found confusing today: Go&#39;s insistence on where you put your source code on disk. I usually put all my GitHub repos in <code>~/github/reponame</code>. But Go wants them under <code>$GOROOT</code>, which is <code>~/go</code> (or <code>~/gotip</code>) on my system. This made my setup experience a bit frustrating, but once I gave up and put my code in <code>$GOROOT</code> everything worked OK and I moved on.</p><p>Last year my pattern was to solve the puzzle, then look at how more experienced Rust developers solved it on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. I almost invariably learned something from this. That didn&#39;t work this year. In Go, the straightforward approach is usually the canonical one. There are just fewer surprises. Go takes pride in being a <a href="https://www.capitalone.com/tech/software-engineering/go-is-boring/">&quot;boring&quot; language</a>. I learned more about Go from having <a href="https://github.com/danvk/aoc2021/commit/a3b38546680c52e1c9c29365a712c834214082cf#r62160234">@derat review my code</a> and make more specific suggestions.</p><p>I&#39;m aware that the Advent of Code doesn&#39;t particularly play to Go&#39;s strengths: there&#39;s no concurrency, for example. But I still found it to be a good way to force myself to learn the basics of the language and use it to solve real problems.</p><p>Here are a few differences between Go and TypeScript that stood out to me.</p><h3 id="Implicit-copies"><a href="#Implicit-copies" class="headerlink" title="Implicit copies"></a>Implicit copies</h3><p>I&#39;m not aware of any situation in which JavaScript makes a copy of an object without your asking it to. In Go, however, this happens all the time. Building a mental model for when these copies happens is always relevant for performance, and sometimes relevant for correctness.</p><p>In TypeScript, we can create a <code>Student</code> type with a name and age, and <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMpgK4BMLmQbwFgAoZZEOAWwgC5kBnMKUAcwG4Sy4XbyNKARtA7EAviRIwMIBGGAB7EMgCCPZQE0IcKAAp6ddNlxgAlAU4MAdNxQBqALzIAjCXHESCRY2QD5AgQCeBpg4eI745FS8AOQAQn6B0QA0yDZ0TgBMyKIiqhAaWrq+-gEmIp4g9PIANhCW1fIsOsWB1jxlZAD0ncgACszg9M4AzCRAA">write a function</a> to make a student age by a year:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AgeAYear</span>(<span class="hljs-params">s: Student</span>) </span>&#123;<br>  s.age += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">const</span> bobby: Student = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;;<br>AgeAYear(bobby);<br><span class="hljs-built_in">console</span>.log(bobby.age);  <span class="hljs-comment">// Prints 13</span><br></code></pre></td></tr></table></figure><p>In JavaScript, objects are always passed by reference. There&#39;s only one <code>Student</code> floating around and <code>AgeAYear</code> modifies it, which is why this code logs 13. (Are primitive types like <code>string</code> are passed by value or by reference? It&#39;s irrelevant because they&#39;re immutable.)</p><p>In Go, <a href="https://go.dev/play/p/zhTqc1-SP1J">something very different happens</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AgeAYear</span><span class="hljs-params">(s Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)  <span class="hljs-comment">// prints 13</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bobby := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>AgeAYear(bobby)<br>fmt.Printf(<span class="hljs-string">&quot;Bobby&#x27;s age is %d\n&quot;</span>, bobby.age)  <span class="hljs-comment">// prints 12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go passes objects by <em>value</em>, not by reference, so <code>AgeAYear</code> is actually operating on a <em>copy</em> of <code>bobby</code>, not the original. This copy&#39;s <code>age</code> increases, but then the copy gets thrown away when the function returns. C++ has a similar behavior and calls this &quot;value semantics.&quot;</p><p>If you want to mutate <code>bobby</code>, you can use a pointer instead:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetOlder</span><span class="hljs-params">(s *Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bob := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>GetOlder(&amp;bob)<br>fmt.Printf(<span class="hljs-string">&quot;Bob&#x27;s age is %d\n&quot;</span>, bob.age)<br>&#125;<br></code></pre></td></tr></table></figure><p>Now this logs <code>13</code> twice. Working with pointers has some famous drawbacks, of course, but it&#39;s much easier in Go than it is in C or C++ because there&#39;s garbage collection.</p><p>Pointers in Go have a way of being contagious. Once you use a pointer to a structure in one place, you can get into trouble if you ever pass it by value someplace else. For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SelfReference <span class="hljs-keyword">struct</span> &#123;<br>  name <span class="hljs-keyword">string</span><br>  self *SelfReference<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeSelfReference</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">SelfReference</span></span> &#123;<br>  me := SelfReference &#123;name: name&#125;<br>  me.self = &amp;me<br>  fmt.Printf(<span class="hljs-string">&quot;References self? %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// true</span><br>  <span class="hljs-keyword">return</span> me<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  me := MakeSelfReference(<span class="hljs-string">&quot;me&quot;</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;References self?: %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/wCiNfPlX75W">This code</a> logs:</p><pre><code>References self? trueReferences self? false</code></pre><p>I scratched my head a good long time over an issue like this before realizing that when <code>MakeSelfReference</code> <em>returns</em>, it makes a copy of the object but of course doesn&#39;t update the <code>self</code> pointer. So the two get out of sync. If you want to keep them in sync, you want to return a <code>*SelfReference</code> instead.</p><p>It took me some time to build an intuition for this because the rules about what&#39;s copied can be surprising. An array (which always has a fixed size in Go) is copied by value, but passing a slice (which is like a small struct with a pointer, length and cap) does not make a copy of the underlying array. Another wrinkle (which I won&#39;t dive into here) is that depending on how a method is declared, invoking it can implicitly copy the object, too.</p><p>All these implicit copies are important and eventually this became intuitive, but it&#39;s quite a shift if you&#39;re coming from JS!</p><h3 id="Batteries-not-included"><a href="#Batteries-not-included" class="headerlink" title="Batteries not included"></a>Batteries not included</h3><p>Go is definitely not a &quot;batteries included&quot; language: there are many very common and familiar functions that are missing from its standard library, notably <a href="https://stackoverflow.com/questions/19239449/how-do-i-reverse-an-array-in-go/19239832">reversing a list</a>, the standard <code>map</code> / <code>filter</code> / <code>reduce</code> functions, taking the min/max of two numbers or <a href="https://stackoverflow.com/questions/57648933/why-doesnt-go-have-a-function-to-calculate-the-absolute-value-of-integers">taking the absolute value of an integer</a>. The argument is that these functions are easy to write, so if you want them, you should just write them. But that does lead to some strange interactions. This VS Code shortcut is a real gem:</p><p><img src="https://effectivetypescript.com/images/golang-reverse.gif" alt="VS Code Reverse"></p><p>I guess this beats copy/pasting from Stack Overflow? My old coworker Dan suggested that this was a way to push you towards reverse iteration, which is faster and requires less memory than allocating a new list. The Go team tends to have very strong opinions about things like this. If you agree with them, then it&#39;s fun to watch them take a stand. But if you don&#39;t, you wind up having to settle for weird workarounds like this one.</p><p>The omission of <code>map</code> / <code>filter</code> / <code>reduce</code> is likely because these functions aren&#39;t that useful without generics. And there is some exciting news on that front!</p><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>The Go team <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">accepted a propsal</a> to add generics to the language in mid-2021 and the Go 1.18 beta, which included support for them, came out in the middle of this year&#39;s AoC. Generics are a big part of TypeScript, so I was curious to see Go&#39;s take on them. I did most of the puzzles using <a href="https://pkg.go.dev/golang.org/dl/gotip">gotip</a> so that I could use generics before they were officially released. Overall this was a pretty smooth process. I found that Go with Generics is a much more pleasant language to use than Go without.</p><p>Here&#39;s what a <a href="https://github.com/danvk/aoc2021/blob/ba0936c804ff9c2a170472c77de029712baa069f/util/util.go#L159-L170">generic <code>min</code> function</a> looks like in Go:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;constraints&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(nums []T)</span> <span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(nums)<br>&#125;<br>min := nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure><p>Aside from some syntax differences, this is quite similar to how you&#39;d <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWRmAPAFQHwAoBuAhgDYDOAXIpgNoC6AlJZogN4CwAUIojMIgSVIA6YgFMwAcygALRAF4FiAAz1WnbtxkAnOAHdEYUfoCiWnVtwByAMKEwYOFERRCAa1GIAtmkRw+ozwAHKABPRGIYUihLegBudUQAXwSxJ28kOUQiMmolWniuRGA4LX4IBCis3z5s4VIIiFFcAEZ6VXZC7l5+fER0LzR2hI0BjKyCkeTCqe4tUSgQLSR0gsSgA">write this code</a> in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vals.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Cannot take min of empty list&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> min = vals[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> vals.slice(<span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (v &lt; min) &#123;<br>      min = v;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> min;<br>&#125;<br></code></pre></td></tr></table></figure><p>The most interesting bit in the Go code is the <code>[T constraints.Ordered]</code>, which would be similar to <code>T extends Ordered</code> in TypeScript. Go comes with a <code>constraints.go</code> module that <a href="https://cs.opensource.google/go/go/+/master:src/constraints/constraints.go;l=44-50?q=constraints.go&ss=go%2Fgo">defines <code>Ordered</code></a> and many other constraints that can be placed on type parameters:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Ordered is a constraint that permits any ordered type: any type</span><br><span class="hljs-comment">// that supports the operators &lt; &lt;= &gt;= &gt;.</span><br><span class="hljs-comment">// If future releases of Go add new ordered types,</span><br><span class="hljs-comment">// this constraint will be modified to include them.</span><br><span class="hljs-keyword">type</span> Ordered <span class="hljs-keyword">interface</span> &#123;<br>Integer | Float | ~<span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Both <code>Integer</code> and <code>Float</code> are themselves constraints (while JS/TS just has <code>number</code>, there are many numeric types in Go such as <code>uint32</code> or <code>float64</code>). The tilde in <code>~string</code> is also interesting. It matches any type whose &quot;underlying type&quot; is <code>string</code>. This confused me for a while until I realized that, unlike TypeScript, Go has nominal types! For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> EnglishWord <span class="hljs-keyword">string</span><br><span class="hljs-keyword">type</span> GermanWord <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>This would create two types that are not comparable or assignable to one another. But you can certainly take the min or max of a list of <code>EnglishWord</code>s. This is a feature that has been <a href="https://github.com/Microsoft/Typescript/issues/202">much discussed</a> in TypeScript but is not natively supported. I found nominal types less useful in the Advent of Code than I would have expected. (I only used them to create distinct types for <code>Digit</code> and <code>ScrambledDigit</code> on <a href="https://github.com/danvk/aoc2021#day-8-seven-segment-search-33759--24434">Day 8</a>).</p><p>So is the Go generic code equivalent to this TypeScript?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Orderable = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Orderable</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>Not quite. This TypeScript definition would allow you to take the min of a mixed list of <code>string</code>s and <code>number</code>s, which should be an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> mixedList = [<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;forty two&#x27;</span>];  <span class="hljs-comment">// type is (string | number)[]</span><br><span class="hljs-keyword">const</span> min = Min(mixedList);  <span class="hljs-comment">// T is string|number, returns a string|number</span><br></code></pre></td></tr></table></figure><p>There&#39;s no notion of a union type in Go (more on that in a moment), so <code>T</code> has to be exactly one of the types enumerated in the constraint (or a type with exactly one of those underlying types).</p><p>I found Go generics to mostly work as expected and be quite intuitive. They let me factor out some of the repetitive boilerplate that bothered me when I first started with the language.</p><p>For example, this is a very common pattern to map a function over a slice:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">var</span> squares []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>  squares = <span class="hljs-built_in">append</span>(squares, num * num)<br>&#125;<br></code></pre></td></tr></table></figure><p>With generics, you can factor out a <code>Map</code> function and <a href="https://go.dev/play/p/boWkZFquqck?v=gotip">rewrite this loop</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">U</span> <span class="hljs-title">any</span>]<span class="hljs-params">(vals []T, fn <span class="hljs-keyword">func</span>(T)</span> <span class="hljs-title">U</span>) []<span class="hljs-title">U</span></span> &#123;<br><span class="hljs-keyword">var</span> us []U<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> vals &#123;<br>us = <span class="hljs-built_in">append</span>(us, fn(v))<br>&#125;<br><span class="hljs-keyword">return</span> us<br>&#125;<br><br>squares := Map(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> num * num &#125;)<br></code></pre></td></tr></table></figure><p>This is quite verbose compared to how it would look in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">squares = nums.map(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num);<br></code></pre></td></tr></table></figure><p>The TypeScript version is so much shorter because:</p><ol><li>JavaScript&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> have a very compact syntax compared to Go&#39;s <code>func</code> and <code>return</code>.</li><li>TypeScript is able to infer two types: both a) the type of the function parameter (<code>num</code>), which it gets from the type of <code>nums</code> and the type of <code>Array.prototype.map</code>, and b) the return type of the arrow function, which it gets from the function body (<code>num * num</code>). Go infers neither of these, so you have to write out the types. It does infer the return type of the whole <code>Map</code> expression, though (<code>[]int</code>).</li></ol><p>I expect that having generics will greatly increase the demand for concise function definitions and better type inference. The Go team will either adopt them or declare that the users asking for them are misguided. It&#39;ll almost certainly be one of those two  they&#39;re quite opinionated!</p><p>There&#39;s a <a href="https://research.swtch.com/generic">famous quote</a> from one of the Go developers (Russ Cox) that when it comes to generics, you can either have:</p><ol><li>Slow programmers (i.e. no generics)</li><li>Slow compilers (by emitting a different version of a generic function for every type instantiation)</li><li>Slow programs (by boxing everything and doing runtime dispatch).</li></ol><p>In this scheme, JavaScript forces TypeScript to choose &quot;slow programs&quot; (though JS JITs are quite good!). And TypeScript has a complex enough type system that it&#39;s often a slow compiler, even without C++-style compile-time specialization.</p><p>Go tries to <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#implementation">escape this dilemma</a> by leaving it up to the compiler whether to specialize a function or box it. The whole <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">generics proposal</a> is interesting to read. It only occurred to me halfway through the doc that runtime performance was a consideration. Clearly I&#39;ve internalized the TypeScript approach to generics!</p><p>Overall I found Go generics easy to use and a great addition to the language. It will be interesting to see how they&#39;re adopted by the community, and whether they bifurcate libraries. I wanted a Graph library, for example, but there weren&#39;t any that used generics. So I just <a href="https://github.com/danvk/aoc2021/blob/master/graph/graph.go">wrote my own</a>.</p><h3 id="Other-bits"><a href="#Other-bits" class="headerlink" title="Other bits"></a>Other bits</h3><p>Here are a few other things I found interesting about Go:</p><ul><li><p>Go has some extremely error-prone constructs. Two examples:</p><ul><li>You write a for loop over a slice as <code>for idx, el := range vals</code>. So <code>range</code> gives you the index first and then the value. This means that if you write <code>for el := range vals</code>, you&#39;ll iterate over the indices, not the values. I much prefer the JS approach of value then index, e.g. for <code>map</code> and <code>forEach</code>. It seems much more common to only care about the value than to only care about the index.</li><li>Does <code>a, b := fn()</code> introduce two new variables? It depends. If both <code>a</code> and <code>b</code> exist, then it will create two new variables. But if only <code>a</code> exists, then it will create a new <code>a</code> variable but reassign <code>b</code>. I found this quite surprising!</li></ul></li><li><p>I really missed union types. Go has <a href="https://making.pusher.com/alternatives-to-sum-types-in-go/">nothing like them</a>, and the official stance from the Go team is that they <a href="https://github.com/golang/go/issues/19412#issuecomment-284301017">&quot;do not add very much&quot;</a> to untyped solutions.  Remember what I said about the Go team being opinionated?</p></li><li><p>You don&#39;t need regular expressions as much as you think for parsing. <code>fmt.Sscanf</code> woked great for most of the Advent of Code problems.</p></li><li><p>Like TS, Go has both <code>var</code> and <code>const</code> but <a href="https://go.dev/ref/spec#Package_initialization">they mean pretty different things</a>.</p></li><li><p>Go doesn&#39;t really have a C++-like notion of <code>const</code> or TypeScript&#39;s <code>readonly</code>.</p></li><li><p><a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">As in other years</a>, I found that using <code>map[Coord]T</code> instead of <code>[][]T</code> is almost always a good idea. It lets you create sparse arrays and accomodates unknown size or negative indices.</p></li><li><p>Go&#39;s type syntax is almost exactly backwards from TypeScript or C, which was a constant source of typos for me. For example, <code>[]T</code> instead of <code>T[]</code>. Or for function parameters, <code>min(a int, b int)</code> instead of <code>min(int a, int b)</code>. Or even <code>min(a, b int)</code>.</p></li><li><p>I still find Go&#39;s pickiness about where I put my code on disk to be weird, confusing and counterproductive. Why can&#39;t I <code>go build</code> something in a subdirectory?</p></li><li><p>Go types all have a meaningful zero value. I started to learn to work with this more and more as the month went on. For example, <code>nil</code> works perfectly well as an empty slice.</p></li><li><p>I&#39;ve always been a spaces person but Go uses tabs. It didn&#39;t bother me one bit.</p></li></ul><h2 id="My-impressions-of-this-year-39-s-Advent-of-Code"><a href="#My-impressions-of-this-year-39-s-Advent-of-Code" class="headerlink" title="My impressions of this year&#39;s Advent of Code"></a>My impressions of this year&#39;s Advent of Code</h2><p>The 2021 AoC was harder than 2020 but easier than 2019. As in 2020, none of the solutions built on one another. Each day was a completely independent puzzle. I&#39;m sure <a href="http://was.tl/">Eric Wastl</a> has his reasons for doing it this way, but I missed how 2019&#39;s puzzles encouraged you to improve the design of your previous day&#39;s solutions. With the independent puzzles, Advent of Code feels more like pure speed coding.</p><p>Days 8, 22 and 24 were the real standouts to me as a creative puzzles. For the other days, my first idea on how to solve the puzzle always turned out to be right, even if it took quite a while to implement it. Many, many of the puzzles this year could be solved with some variation on <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. It&#39;s always amazing to see how effective the standard algorithms are once you figure out how to map your problem onto them.</p><p>I continue to wish I were in a timezone where it was more reasonable for me to do the puzzles as soon as they came out. And I continue to think this is a great way to learn a language. AoC problems don&#39;t really play to Go&#39;s strengths (there&#39;s no concurrency) but I did feel much more confident writing Go by the end than I did at the start.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Once again, I had a great time doing Advent of Code this year and I enjoyed the opportunity to learn a new language. The days&#39; puzzles gave me something concrete and fun to cling to during a time of <a href="https://www.theverge.com/2021/12/16/22840028/sidewalk-labs-google-doctoroff-health-toronto-quayside">complete chaos</a> at my work.</p><p>Day 25 in particular stands out. I woke up early (6 AM) to watch the long-anticipated <a href="https://www.youtube.com/watch?v=9tXlqWldVVk">launch of the James Webb Space Telescope</a>, and I raced to collect my final stars before I had to drive off to the airport for a trip to the Dominican Republic, my first international vacation in ~2.5 years.</p><p>It&#39;s unlikely I&#39;ll use Go in my daily work, but I do enjoy the perspective on TypeScript that it gives. As always, TypeScript&#39;s relationship to JavaScript (types are erased at runtime) and its ability to infer types stand out. Which language will I try next year? I&#39;m not sure! Suggestions welcome.</p><p>If you&#39;ve made it this far and for some reason want even more, check out the <a href="https://github.com/danvk/aoc2021">notes and code</a> in my GitHub repo.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;It&amp;#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&amp;#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.&lt;/p&gt;
&lt;p&gt;My favorite way to learn a new language is through the annual &lt;a href=&quot;https://adventofcode.com&quot;&gt;Advent of Code&lt;/a&gt; (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on &lt;a href=&quot;https://reddit.com/r/adventofcode&quot;&gt;r/adventofcode&lt;/a&gt;. In 2019 I &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;did it in Python&lt;/a&gt; (not a new language for me) and in 2020 I &lt;a href=&quot;https://effectivetypescript.com/2021/03/24/advent-of-code/&quot;&gt;did it in Rust&lt;/a&gt; (which was a new language). This year, I did it in Go (aka Golang).&lt;/p&gt;
&lt;p&gt;This post has three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My impressions of Go (coming from a TypeScript perspective)&lt;/li&gt;
&lt;li&gt;My impressions of this year&amp;#39;s Advent of Code&lt;/li&gt;
&lt;li&gt;Notes and links for each day&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Types: The First 500 Years (tsconf 2021 talk)</title>
    <link href="https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/"/>
    <id>https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/</id>
    <published>2021-12-10T14:25:00.000Z</published>
    <updated>2021-12-10T14:32:06.049Z</updated>
    
    <content type="html"><![CDATA[<p>My talk from tsconf 2021, <a href="https://www.youtube.com/watch?v=uN1zuV4DGRY&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe"><em>TypeScript Types: The First 500 Years</em></a>, is up on YouTube (<a href="https://docs.google.com/presentation/d/1HYknblfcAnbjbdDe4MYTyRQpCw_gV72n2cj88xH7z8c/edit?usp=sharing">slides here</a>). Check it out!</p><iframe width="560" height="315" src="https://www.youtube.com/embed/uN1zuV4DGRY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>The talk tries to answer the question &quot;what is a type?&quot; It seems simple but it&#39;s actually quite tricky! The talk explains how sets can be built constructively (<code>&quot;A&quot; | &quot;B&quot; | &quot;C&quot;</code>), but that the more common approach in TypeScript is best thought of as a subtractive process, where you start from the raw, undifferentiated <code>unknown</code> type and then whittle your way down:</p><img src="/images/unknown-marble.jpg" width="527" height="395" alt="Large block of marble with the word unknown on it" style="max-height: 395px"><p>It then talks about how TypeScript has given us the ability to &quot;carve&quot; out finer and finer details in our types over time, and how that lets us capture more and more errors in our code.</p><p>Overall I&#39;m happy with how the talk turned out. Let me know what you think! All the <a href="https://www.youtube.com/playlist?list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe">tsconf 2021</a> talks are online now. The Anders <a href="https://www.youtube.com/watch?v=V5OnAN63vls&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&index=2">keynote</a> is always a highlight.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;My talk from tsconf 2021, &lt;a href=&quot;https://www.youtube.com/watch?v=uN1zuV4DGRY&amp;list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&quot;&gt;&lt;em&gt;TypeScript Ty
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Exclusive Or and the Optional never Trick</title>
    <link href="https://effectivetypescript.com/2021/11/11/optional-never/"/>
    <id>https://effectivetypescript.com/2021/11/11/optional-never/</id>
    <published>2021-11-11T22:00:00.000Z</published>
    <updated>2021-11-11T14:06:42.874Z</updated>
    
    <content type="html"><![CDATA[<p><em>Apologies for the <a href="https://effectivetypescript.com/2021/06/03/interface/">long delay</a> between posts. I&#39;ve been busy <a href="https://www.instagram.com/p/CU8hUZwJ3be/">getting married</a> and <a href="https://www.instagram.com/p/CWBG_BGrl31/">climbing</a>. With winter setting in and the wedding behind me, I hope that I&#39;ll find more time for writing.</em></p><blockquote><p>&quot;Do you want coffee or tea?&quot;</p><p>&quot;Yes&quot;</p></blockquote><p>In ordinary speech, &quot;or&quot; means &quot;exclusive or.&quot; Only programmers and logicians use an <em>inclusive</em> or.</p><p>In TypeScript, it&#39;s easy to get mixed up between these two:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>We usually read the last line as &quot;Type <code>Thing</code> is a <code>ThingOne</code> or <code>ThingTwo</code>.&quot; But just like JavaScript&#39;s runtime or (<code>||</code>), TypeScript&#39;s type-level or (<code>|</code>) is an <em>inclusive</em> or. There&#39;s no reason a thing can&#39;t be both a <code>ThingOne</code> <em>and</em> a <code>ThingTwo</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> allThings: Thing = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Why does this work? It&#39;s because TypeScript has a structural type system. Both the <code>ThingOne</code> and <code>ThingTwo</code> types allow additional properties that aren&#39;t declared in their interface (this fact is sometimes obscured by <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks">excess property checking</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> bothThings = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> thing1: Thing1 = bothThings;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> thing2: Thing2 = bothThings;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>So what if you really do want an exclusive or? What if you want to keep your <code>ThingOne</code>s and <code>ThingTwo</code>s separate? How can you model that?</p><p>There&#39;s a standard trick, which is to use an <em>optional <code>never</code></em> type in your interface to disallow a property:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> OnlyThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>  hairColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> OnlyThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>  shirtColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">type</span> ExclusiveThing = OnlyThingOne | OnlyThingTwo;<br></code></pre></td></tr></table></figure><p>Now none of the assignments from before pass the type checker (see <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPIgDYE8AqALUAc3RQG8BYAKGWQGcCowBhAewxagC46woiBuKjTxxgUVuygB+biAgA3aIMoBfKqEixEKdNnxEcAdxbIK1ZCLESO3WrwFC6DZmw4zkcxVGVrKYLAAOKACiAB4IGACutMCK+iCEyAC8aJi4BAkkyAA+qXoZhEYsylQILCB2yABGLGB48YS0yaaO9GIuktwA5FAQACZdADSOluKuXMhdVVEQQ1QqJZRlFWDIdUQAjNy66URZKTV1DbTKAPSnNDQAfje3yDiBEE0sMMgBUCxBjFiTo9ZQXWQcF6yFAZQAtgE4GBgNMIAA6UrlSrrBIAJm2aQaRWah3qBROVHOl2QtzuDyCz1e70+0H8kzajH+gOBKDBLEh0NhGARSJWQIwGGO3DCEWisQgDWaZmJlzJ8vujypbw+X3pXUZHQ4LJB7M5MLhiPMmv+3V6A2G5j+42600is0tCyoQA">playground</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> thing1: OnlyThingOne = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;hairColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> thing2: OnlyThingTwo = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> allThings: ExclusiveThing = &#123;<br><span class="hljs-comment">//    ~~~~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>This works because no value is assignable to a <code>never</code> type. But because the property is <em>optional</em>, there&#39;s exactly one way out: not having that property.</p><p>This isn&#39;t just useful for unions. If you want to define a two dimensional vector type, for example, you might want to specifically disallow adding a third dimension:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>With this type, you&#39;ll get an error if you accidentally pass a three-dimensional vector to a function like <code>norm</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">norm</span>(<span class="hljs-params">v: Vector2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(v.x ** <span class="hljs-number">2</span> + v.y ** <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">const</span> v = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">const</span> d = norm(v);<br><span class="hljs-comment">//             ~ Types of property &#x27;z&#x27; are incompatible.</span><br></code></pre></td></tr></table></figure><p>This wouldn&#39;t be an error without the <code>z?: never</code> because the call is structurally valid, even though it&#39;s semantically incorrect.</p><p>&quot;Tags&quot; are another common way to make an or exclusive:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;one&#x27;</span>;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;two&#x27;</span>;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>A string can&#39;t be both &quot;one&quot; <em>and</em> &quot;two&quot;, so there&#39;s no overlap between these types. This means there&#39;s no distinction between inclusive and exclusive or. This is one of many great reasons to use tagged unions when you can.</p><p>It&#39;s a fun exercise to define an exclusive or generic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;A, B&gt; = <span class="hljs-comment">/* ??? */</span>;<br></code></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwEEA0UBCA+KBeKAegCooB+CqYwgbgFgAoRgSwDtgIAnAMwEMBjaHFYAbEABUAFmwDmw6AG9GUKAGdpnYAGEA9iJ2cAXGuCdZ9Bism9mnXfs5ljrCADcuFgL4t2XPoKhhMSlZcQB3HSglSyhrW3sDY1VTc2U1DW09AycoF3dOL0ZQSCgAUQAPfhEAV1VmdxDWGXxYRCQgiWkm+QwOxplwnWwLRn4dVmSoACMdYEl+1RbolXVbTIdjAHJOCAATTbQ0uLssoyhNqZqIA8ZPEYZCQigpCFVodR1qkV2oXhERabQLicAyqUbjSZzWQARmMfS6chcLRmcwWFkeKhUAD8cbjnuBXlAdNwoGAQZBNCBzscEpxNr8dlA2GMALZgXjAZiXCAAOnBE2AUChTQATHDRJ1QhFkbN5gjVOinpjcXjxATFsTSeSuKBzqtNLT6bxGcydGyOVyRLz+ZM-iIFsYKlVavUIP0lowMcqVSr8ZANSSyToKbrNvr1gYjSbWKz2ZzuXyYuHaVsdvtDjEaactpdqtcM3dGJ6ni83gyhABpG2C8bBBGwsqVGp1BoIj0xFYZFPnNM3BiFhhjAVEiX9MWN50tt1tgjLTFZjbnXP524WIA">Give it a try!</a></p><p>Here&#39;s <a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwBUCMAaKKBMA+KAXgFgAoKCqACnSgDIoBvAbQGsoBLAOygFEAPAMYAbAK4ATCElYQQAewBm2HFhnyl6PAF0A-AC4oXCADcIAJwC+ASigAfMpWq56TNpx4CREqWsXZMUL4a+LoGRqaWVgDcZGTcwOYKAIaC0HBcwiAoABbcAObp0IwOUADOuWbAAMJywnJmBqXAZvkx5FDZSRxmNXVm+oYm5m0WcVwJZsmpUOmZOfkoAO5yTCWd3b31jc2tJeXd1bX1A+HDZKOkoJB8QmKlHKbzXHlEsIhIs1m5z4VYn095JZyPBtMiCORcJpQABGcmA2QBpVexXa+0qmwaUAA5GYIOIsRg1l0ekdMVjoWIIATzqDSAB6OnYbIQUrQcpyUTCcRQJLCYQw6DmMz1UpgiFQ+H5NAGf7fApGV6w+GItoMxwAP01Wuw4BZUD8YGFkEqIGx6xJfSxPNx7nBAFswElgBwKRAAHRiyHAKCS544GUZL4LZaKuEIuWlVWMyha7UoXVIg1G8ygbFow6W63Qbj2x3O10e0jgr08vmIgyeO4PCAA5FkNUx2OxnWQRNKQ1yY2prHpjFWpI2nNyB1Ol3Cd17CoZrbY3H4wntc0YgzkynU0gWWlqnIs6ADtIAaU9UIhczl0puXnujzldfaFF7pJXc-Xm+P3tPQb9FduomvNdvQhVnvDpiWXbEKVEKkFzfUggA">what I came up with</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;T1, T2&gt; =<br>    (T1 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T2, keyof T1&gt;]?: <span class="hljs-built_in">never</span>&#125;) |<br>    (T2 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T1, keyof T2&gt;]?: <span class="hljs-built_in">never</span>&#125;);<br></code></pre></td></tr></table></figure><p>This is roughly the same as the <a href="https://github.com/krzkaczor/ts-essentials/blob/831ba8b6f3600872559c30e875ea74450953dc8a/lib/types.ts#L441-L445"><code>XOR</code> implementation</a> from the <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> library.</p><p>There&#39;s one caveat to the optional <code>never</code> trick that&#39;s worth knowing: unless you set the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/#exact-optional-property-types"><code>--exactOptionalPropertyTypes</code></a> compiler flag (added in TS 4.4), you&#39;re allowed to assign <code>undefined</code> to an optional never field:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br><br><span class="hljs-comment">// OK with just --strict</span><br><span class="hljs-keyword">const</span> v: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><br><span class="hljs-comment">// Error with --exactOptionalPropertyTypes</span><br><span class="hljs-keyword">const</span> w: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><span class="hljs-comment">//                              ~</span><br><span class="hljs-comment">//    Type &#x27;undefined&#x27; is not assignable to type &#x27;never&#x27;.</span><br></code></pre></td></tr></table></figure><p>So remember: in TypeScript, &quot;or&quot; is a union: <code>A | B</code> means either <code>A</code>, <code>B</code>, or both. Remember that &quot;both&quot; is a possibility, and you should either prevent it or handle it in your code.</p>]]></content>
    
    <summary type="html">
    
      This post looks at how TypeScript&#39;s type union operator (&lt;code&gt;|&lt;/code&gt; aka &quot;pipe&quot; or &quot;or&quot;) is really an &lt;i&gt;inclusive&lt;/i&gt; or, and how this can come as a surprise. It presents a few options for getting an &lt;i&gt;exclusive&lt;/i&gt; or if that&#39;s what you want, including the &quot;optional &lt;code&gt;never&lt;/code&gt;&quot; trick.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>In defense of interface: Using declaration merging to disable &quot;bad parts&quot;</title>
    <link href="https://effectivetypescript.com/2021/06/03/interface/"/>
    <id>https://effectivetypescript.com/2021/06/03/interface/</id>
    <published>2021-06-03T21:00:56.000Z</published>
    <updated>2021-06-03T20:58:25.392Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript&#39;s <code>interface</code> has gotten a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a> lately, largely because of <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>, a behavior of <code>interface</code> that&#39;s quite surprising when you first see it. This post explains what declaration merging is, <em>why</em> it is, and how you can use it to iron out some of JavaScript&#39;s and TypeScript&#39;s wrinkles in your own projects.</p><span id="more"></span><hr><p>I recently implemented a multiselect feature on my product at work. For the most part this involved changing my state from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureId: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureIds: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>and tracking down all the resulting errors. But I had a bug! Sometimes I&#39;d click on a feature and it wouldn&#39;t get selected. Or, weirder, it would select a random smattering of other, unrelated features.</p><p>I eventually realized that I&#39;d converted the existing code from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureId(featureId);<br></code></pre></td></tr></table></figure><p>to</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(featureId));<br></code></pre></td></tr></table></figure><p>In my case <code>featureId</code> was something like <code>&quot;357&quot;</code> and, as you can see:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; new Set(&quot;357&quot;)<br>&#123;&quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125;<br></code></pre></td></tr></table></figure><p>The <code>new Set</code> constructor takes an iterable, and JavaScript <code>string</code>s let you iterate over the sequence of their characters. Instead of selecting feature 357, I was selecting features 3, 5 and 7.</p><p>The solution was to change it to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([featureId]));  <span class="hljs-comment">// one element array</span><br></code></pre></td></tr></table></figure><p>Fixing one bug is fine, but it&#39;s better to find a way to make sure that same bug, or a whole class of bugs, never comes back. Since this is a blog about TypeScript, let&#39;s look at how we can use one of TypeScript&#39;s most head-scratching features to prevent ourselves (and our coworkers) from ever passing a <code>string</code> to the <code>Set</code> constructor again.</p><h2 id="What-is-Declaration-Merging"><a href="#What-is-Declaration-Merging" class="headerlink" title="What is Declaration Merging?"></a>What is Declaration Merging?</h2><p>One of TypeScript&#39;s most surprising behaviors is <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">interface</span> Product &#123;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> furby: Product;<br>furby.name;  <span class="hljs-comment">// ok, type is string</span><br>furby.price;  <span class="hljs-comment">// ok, type is number</span><br></code></pre></td></tr></table></figure><p>Even though they may be separated by thousands of lines of code or in entirely different modules, the two declarations of the <code>Product</code> interface are <em>merged</em> into a single type with both <code>name</code> and <code>price</code> properties.</p><p>Declaration merging is surprising and it&#39;s given <code>interface</code> a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a>. <em>Effective TypeScript</em> even suggests using <code>type</code> instead of <code>interface</code> to avoid it (type aliases are not merged; see Item 13: Know the Differences Between <code>type</code> and <code>interface</code>).</p><p>But it&#39;s not all bad! Let&#39;s look at why TypeScript merges declarations before we use this to ban the evil <code>Set</code> constructor.</p><h2 id="Why-Declaration-Merging"><a href="#Why-Declaration-Merging" class="headerlink" title="Why Declaration Merging?"></a>Why Declaration Merging?</h2><p>Declaration merging really shines when you look at the <a href="https://www.typescriptlang.org/tsconfig#lib"><code>lib</code> setting</a> in <code>tsconfig.json</code>, which models the ECMAScript version that will be available at runtime.</p><p>The file <code>lib.es5.core.d.ts</code> <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1220">contains declarations</a> for built-in methods on the <code>Array</code> type as of 2009 vintage ES5:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  length: <span class="hljs-built_in">number</span>;<br>  pop(): T | <span class="hljs-literal">undefined</span>;<br>  push(...items: T[]): <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES2015 added a few new methods, for example <code>Array.prototype.find</code>. When you add <code>es2015</code> to the <code>lib</code> setting in <code>tsconfig.json</code>, TypeScript pulls in <code>lib.es2015.core.d.ts</code>, which <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.core.d.ts#L21-L32">defines those methods</a>, too:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  find&lt;S <span class="hljs-keyword">extends</span> T&gt;(predicate: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">void</span>, value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> value is S, thisArg?: <span class="hljs-built_in">any</span>): S | <span class="hljs-literal">undefined</span>;<br>  find(predicate: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> unknown, thisArg?: <span class="hljs-built_in">any</span>): T | <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The net effect when these declarations are merged is that TypeScript will only know about <code>find</code> if your <code>lib</code> includes <code>es2015</code> (or later). Which is exactly what you want!</p><p>I assume that <code>lib</code> was the motivation behind declaration merging. But you can make use of it in your own code, too. Let&#39;s use it to ban the &quot;evil&quot; <code>Set</code> constructor.</p><h2 id="Banning-the-Evil-Set-Constructor"><a href="#Banning-the-Evil-Set-Constructor" class="headerlink" title="Banning the Evil Set Constructor"></a>Banning the Evil <code>Set</code> Constructor</h2><p>Recall that we want to disallow <code>new Set(&quot;string&quot;)</code> in our own code without affecting other invocations of the <code>Set</code> constructor.</p><p>Here&#39;s the <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.collection.d.ts#L58-L71">declaration of <code>Set</code></a> from <code>lib.es2015.collections.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Set&lt;T&gt; &#123;<br>    add(value: T): <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">delete</span>(value: T): <span class="hljs-built_in">boolean</span>;<br>    has(value: T): <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-keyword">readonly</span> size: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T = <span class="hljs-built_in">any</span>&gt;(values?: <span class="hljs-keyword">readonly</span> T[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>    <span class="hljs-keyword">readonly</span> prototype: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">Set</span>: SetConstructor;<br></code></pre></td></tr></table></figure><p>Sometimes type declarations model the type of an instance (<code>Set</code>) and the type of the class (<code>SetConstructor</code>) separately. In this case we want to merge something into <code>SetConstructor</code>.</p><p>There&#39;s also an <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.iterable.d.ts#L169-L185">overload of the constructor</a> in <code>lib.es2015.iterable.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T&gt;(iterable?: Iterable&lt;T&gt; | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>We&#39;ll want to overload this one. Put this declaration in a <code>.d.ts</code> file somewhere in your project scope, e.g. <code>declarations/ban-evil-set-constructor.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>  <span class="hljs-keyword">new</span> (str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>When this gets merged with the other <code>SetConstructor</code> declarations, the net effect is that the problematic usage will trigger a type error without affecting the others:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&#x27;123&#x27;</span>));<br><span class="hljs-comment">//                    ~~~~~~~~~~~~~~</span><br><span class="hljs-comment">// Argument of type &#x27;void&#x27; is not assignable to parameter</span><br><span class="hljs-comment">//   of type &#x27;ReadonlySet&lt;string&gt;&#x27;.</span><br>setSelectedFeatureIds([<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h2 id="What-else-can-you-do-with-this"><a href="#What-else-can-you-do-with-this" class="headerlink" title="What else can you do with this?"></a>What else can you do with this?</h2><p>That was neat! What else can we do with this technique?</p><p>A TypeScript pet peeve of mine has always been that <code>JSON.parse</code> returns a dangerous <code>any</code> type. This <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1052-L1079">declaration</a> comes from <code>lib.es5.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> JSON &#123;<br>    parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">JSON</span>: <span class="hljs-built_in">JSON</span>;<br></code></pre></td></tr></table></figure><p>A safer return type would be <code>unknown</code>. This type was only <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">introduced in TypeScript 3.0</a> (July 2018) and changing this declaration would be a hugely breaking change for the TypeScript ecosystem as a whole. But there&#39;s no reason you can&#39;t &quot;fix&quot; it in your own project!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> JSON &#123;<br>  parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): unknown;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now you won&#39;t be able to use the result of <code>JSON.parse</code> without going through a type assertion or type guard first:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseType &#123;<br>  lastModifiedAt: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = <span class="hljs-built_in">JSON</span>.parse(apiResponse);<br>obj1.lastModifiedAt;<br><span class="hljs-comment">// ~~~~~~~~~~~~~~~ Object is of type &#x27;unknown&#x27;.</span><br><br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(apiResponse) <span class="hljs-keyword">as</span> ResponseType;<br>obj2.lastModifiedAt; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>You can do something similar with <code>Response.prototype.json()</code>, which is used in the <code>fetch</code> API. Its <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.dom.d.ts#L2622-L2630">declaration</a> comes from <code>interface Body</code> in <code>lib.dom.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Body &#123;<br>  <span class="hljs-keyword">readonly</span> body: ReadableStream&lt;<span class="hljs-built_in">Uint8Array</span>&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">readonly</span> bodyUsed: <span class="hljs-built_in">boolean</span>;<br>  arrayBuffer(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">ArrayBuffer</span>&gt;;<br>  blob(): <span class="hljs-built_in">Promise</span>&lt;Blob&gt;;<br>  formData(): <span class="hljs-built_in">Promise</span>&lt;FormData&gt;;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  text(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you merge in a new declaration for <code>json()</code>, you can get <code>unknown</code> types back instead of <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> Body &#123;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;unknown&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Declaration merging is surprising and controversial, but it&#39;s not all bad. TypeScript uses it to great effect in modeling which library methods will be available at runtime. And you can use it modify or disallow those methods as you like for your project.</p><p>A few notes to conclude:</p><ul><li><p>As with all type-level constructs, this only affects type checking. The runtime behavior the <code>Set</code> constructor is not affected, either in your own code or in library code.</p></li><li><p>This technique is best used either to make the built-in types stricter, or to disallow certain things. If you add declarations that don&#39;t reflect reality at runtime, you can create a really confusing situation. Incorrect types can be worse than no types.</p></li><li><p>Making a constructor return <code>void</code> isn&#39;t itself an error. So calling <code>new Set(&quot;string&quot;)</code> on its own will not cause a type error. You only get the error when you try to use the resulting value, which gets a <code>void</code> type. This is fine in our case, but if the method you want to &quot;knock out&quot; already returns <code>void</code>, then this technique won&#39;t work as well. (link to &quot;user-defined type error&quot; issue)</p></li></ul><p>References:</p><ul><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>.</li><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html#global-modifying-modules">global augmentation</a>.</li></ul><!--References:- KCD tweet about how augmentation makes him prefer `type`: https://twitter.com/kentcdodds/status/1392678508954980353- Item 13: Know the Differences Between `type` and `interface`- Rob Palmer tweet (blog post?) about compiler performance implications of `type` vs. `interface`:  - https://twitter.com/robpalmer2/status/1319188885197422594?lang=en  - https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/  - "9. Generated declarations can inline types from dependencies"- Is "augmentation" the right term for this? Declaration merging?  - https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation  - "Declaration Merging" is the general name  - "Augmentation" refers specifically to patching a module or "global augmentation"- The TS handbook calls out global augmentation as "somewhat dangerous":Notes to hit:- Declaration merging is surprising- Merging works best for adding methods to the standard library, e.g. `lib.dom.d.ts`- The mistake I made with `new Set(string)`-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript&amp;#39;s &lt;code&gt;interface&lt;/code&gt; has gotten a bit of a &lt;a href=&quot;https://twitter.com/kentcdodds/status/1392678508954980353&quot;&gt;bad rap&lt;/a&gt; lately, largely because of &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html&quot;&gt;declaration merging&lt;/a&gt;, a behavior of &lt;code&gt;interface&lt;/code&gt; that&amp;#39;s quite surprising when you first see it. This post explains what declaration merging is, &lt;em&gt;why&lt;/em&gt; it is, and how you can use it to iron out some of JavaScript&amp;#39;s and TypeScript&amp;#39;s wrinkles in your own projects.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Seven Sources of Unsoundness in TypeScript</title>
    <link href="https://effectivetypescript.com/2021/05/06/unsoundness/"/>
    <id>https://effectivetypescript.com/2021/05/06/unsoundness/</id>
    <published>2021-05-07T00:00:00.000Z</published>
    <updated>2022-03-01T14:34:59.433Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/square-peg-round-hole.png" title="A square peg in a round hole" width="212" height="197" style="float: right; padding-left: 10px;">Hang out on the internet much and you&#39;ll hear gripes about how TypeScript isn&#39;t &quot;sound,&quot; and that this makes it a poor choice of language. In this post, I&#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&#39;s never a good idea to listen to people on the internet!</p><span id="more"></span><p>Roughly speaking, a language is &quot;sound&quot; if the static type of every symbol is guaranteed to be compatible with its runtime value.</p><p>Here&#39;s a simple example of a sound type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Math</span>.random();<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>TypeScript infers a static type of <code>number</code> for <code>x</code>, and this is sound: whatever value <code>Math.random()</code> returns at runtime, it will be a <code>number</code>. This doesn&#39;t mean that <code>x</code> could be any <code>number</code> at runtime: a more precise type would be the half-open interval <code>[0, 1)</code>, but TypeScript has no way to express this. <code>number</code> is good enough. If you remember the <a href="https://wp.stolaf.edu/it/gis-precision-accuracy/">famous statistics dartboard</a>, soundness is more about accuracy than precision.</p><p>Here&#39;s an example of unsoundness in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];  <span class="hljs-comment">// type is number[]</span><br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The static type of <code>x</code> is inferred as <code>number</code>, but at runtime its value is <code>undefined</code>, which is not a <code>number</code>. So this is unsound.</p><p>Many programming languages include proofs of soundness, or at least purport to be sound. Fun fact: in 2016, two researchers <a href="https://dl.acm.org/doi/10.1145/2983990.2984004">discovered that Java had become unsound</a>! As we saw above, TypeScript is emphatically <em>not</em> sound. In fact, <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">soundness is not a design goal</a> of TypeScript at all. Instead, TypeScript favors convenience and the ability to work with existing JavaScript libraries.</p><p>That being said, unsoundness can lead to crashes and other problems at runtime, so it&#39;s a good idea to understand the ways that it can arise.</p><p>Here are the seven sources of unsoundness:</p><ol><li><a href="#any"><code>any</code></a></li><li><a href="#Type-Assertions">Type Assertions</a></li><li><a href="#Object-and-array-lookups">Object and array lookups</a></li><li><a href="#Inaccurate-type-definitions">Inaccurate type definitions</a></li><li><a href="#The-thing-with-variance-and-arrays">The thing with variance and arrays</a></li><li><a href="#Function-calls-don-39-t-invalidate-refinements">Function calls don&#39;t invalidate refinements</a></li><li><a href="#There-Are-Five-Turtles">There Are Five Turtles</a></li></ol><p>For each of these, I&#39;ll assess how common it is in practice, show what it looks like, and explain how you can avoid it.</p><p>Note that this post assumes you&#39;re using <code>--strict</code>. If you&#39;re not, then there are more ways that TypeScript is unsound.</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h2><p><strong>How often does this occur?</strong> It depends how disciplined you are about not using <code>any</code>! But built-ins like <code>JSON.parse</code> that return <code>any</code> make it hard to avoid entirely.</p><p>If you &quot;put an <code>any</code> on it&quot;, then anything goes. The static types may or may not have anything to do with real runtime types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// static type of x is number, runtime type is string</span><br>&#125;<br><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;forty two&#x27;</span>;<br>alertNumber(num);<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The solution here is simple: limit your use of <code>any</code> or, better, don&#39;t use it at all! Chapter 5 of <a href="https://amzn.to/38s1oCK">Effective TypeScript</a> is all about how to mitigate and avoid the static type disaster that is <code>any</code>. The highlights are to limit the scope of <code>any</code> and to use <code>unknown</code> as a safer alternative when possible.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><strong>How often does this occur?</strong> Often (though not as often as object and array lookups).</p><p>The slightly less offensive cousin of <code>any</code> is the &quot;type assertion&quot; (<em>not</em> the &quot;cast&quot;, see my <a href="https://effectivetypescript.com/2021/02/03/pet-peeves/">rant on this terminology</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br>alertNumber(x1);<br><span class="hljs-comment">//          ~~ ... Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br>alertNumber(x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>);  <span class="hljs-comment">// type checks, but might blow up at runtime</span><br></code></pre></td></tr></table></figure><p>The <code>as number</code> in the last line is the type assertion, and it makes the error go away. It&#39;s the <a href="https://xkcd.com/149/">sudo make me a sandwich</a> of the type system.</p><p>Type assertions often come up in the context of input validation. You might fetch JSON via an API and give it a type using an assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json() <span class="hljs-keyword">as</span> FunFact;<br></code></pre></td></tr></table></figure><p>Nothing ensures that this API is <em>actually</em> returning a <code>FunFact</code>. You&#39;re simply asserting that it is. If it isn&#39;t, then the static type won&#39;t match reality.</p><p>What can you do about this? You can replace many assertions with conditionals (<code>if</code> statements or ternary operators):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br><span class="hljs-keyword">if</span> (x1 !== <span class="hljs-literal">null</span>) &#123;<br>  alertNumber(x1);  <span class="hljs-comment">// ok, x1&#x27;s type is number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Within the <code>if</code> block, the static type of <code>x1</code> is narrowed based on the condition, so the type assertion isn&#39;t needed.</p><p>For input validation, you can write a <a href="https://basarat.gitbook.io/typescript/type-system/typeguard">type guard function</a> to do some run-time type checking:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunFact</span>(<span class="hljs-params">data: unknown</span>): <span class="hljs-title">data</span> <span class="hljs-title">is</span> <span class="hljs-title">FunFact</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;fact&#x27;</span> <span class="hljs-keyword">in</span> data <span class="hljs-comment">/* &amp;&amp; ... */</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json();<br><span class="hljs-keyword">if</span> (!isFunFact(fact)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Either it wasn&#x27;t a fact or it wasn&#x27;t fun`</span>);<br>&#125;<br><span class="hljs-comment">// type of fact is now FunFact!</span><br></code></pre></td></tr></table></figure><p>Of course, you&#39;re still asserting that your type guard really guards the type. If you want to be more systematic about it, there are many possible approaches. One is to use a tool like <a href="https://github.com/colinhacks/zod">Zod</a> that&#39;s designed to solve this problem. Another is to generate JSON Schema from your TypeScript types (e.g. using <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a>) and validate the shape of your data at runtime using that. <a href="https://github.com/danvk/crosswalk">crosswalk</a> takes this approach.</p><!--The bit about about type guards being unchecked is called out here https://twitter.com/sebmck/status/1142601008251469824--><h2 id="Object-and-array-lookups"><a href="#Object-and-array-lookups" class="headerlink" title="Object and array lookups"></a>Object and array lookups</h2><p><strong>How often does this occur?</strong> All the time.</p><p>TypeScript doesn&#39;t do any sort of bounds checking on array lookups, and this can lead directly to unsoundness and runtime errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// static type is number but runtime type is undefined.</span><br>alert(x.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The same can happen when you reference a property on an object with an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string but runtime type is undefined.</span><br></code></pre></td></tr></table></figure><p>Why does TypeScript allow this sort of code? Because it&#39;s extremely common and because it&#39;s quite difficult to prove whether any particular index/array access is valid. If you&#39;d like TypeScript to try, there&#39;s a <a href="https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess"><code>noUncheckedIndexedAccess</code></a> option. If you turn it on, it finds the error in the first example but also flags perfectly valid code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><span class="hljs-keyword">const</span> x2 = xs[<span class="hljs-number">2</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x2.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p><code>noUncheckedIndexedAccess</code> is at least smart enough to understand some common array constructs:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>  <span class="hljs-built_in">console</span>.log(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-keyword">const</span> squares = xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);  <span class="hljs-comment">// also ok</span><br></code></pre></td></tr></table></figure><p>If you&#39;re concerned about unsafe access to specific arrays or objects, you can explicitly add <code>| undefined</code> to their value types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs: (<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><br><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string | undefined</span><br>alert(agent.toUpperCase());<br><span class="hljs-comment">//    ~~~~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p>The advantage of this approach over <code>noUncheckedIndexedAccess</code> is that it lets you limit the scope (and presumably false positives) of that flag. The disadvantage is that it lacks the smarts of the flag: the <code>for-of</code> loop will give you errors with this approach. It also introduces the possibility that you <code>push</code> an <code>undefined</code> onto the array.</p><p>Finally, it&#39;s often possible to rework your code to avoid the need for these sorts of lookups. Say your API looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuItem &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  displayText: <span class="hljs-built_in">string</span>;<br>  icon?: <span class="hljs-built_in">string</span>;<br>  hoverText?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This API is very likely to lead to lookups in the <code>onSelectItem</code> callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125; = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>Menu(&#123;<br>  menuItems,<br>  <span class="hljs-function"><span class="hljs-title">onSelectItem</span>(<span class="hljs-params">id</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> menuItem = menuItems[id]; <span class="hljs-comment">// oh no! object lookup!</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Instead, you might pass the <code>MenuItem</code> itself to the callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">menuItem: MenuItem</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is safer from a static types perspective.</p><h2 id="Inaccurate-type-definitions"><a href="#Inaccurate-type-definitions" class="headerlink" title="Inaccurate type definitions"></a>Inaccurate type definitions</h2><p><strong>How often does this occur?</strong> Surprisingly rarely, but it&#39;s annoying and surprising when it does!</p><p>The type declarations for a JavaScript library are like a giant type assertion: they claim to statically model the runtime behavior of the library but there&#39;s nothing that guarantees this. (Unless, that is, the library is written in TypeScript, the declarations are generated by <code>tsc</code> and the library doesn&#39;t break any of the rules in this post!)</p><p>It&#39;s hard to show a specific example here since these kinds of bugs tend to get fixed once you highlight them, particularly for declarations on DefinitelyTyped. But here&#39;s <a href="https://github.com/alex3165/react-mapbox-gl/issues/776">one example</a> in react-mapbox-gl that&#39;s been around for years. (Not to pick on react-mapbox-gl, we love you alex3165!)</p><p>How do you work around this? The best way is to fix the bug! For types on DefinitelyTyped (<code>@types</code>), the turnaround time on this is usually a week or less. If this isn&#39;t an option, you can work around some issues via <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">augmentation</a> or, in the worst case, a type assertion.</p><p>It&#39;s also worth noting that some functions have types that are just very hard to model statically. Take a look at the parameter list for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter"><code>String.prototype.replace</code></a> for a head-scratching example. There are also some functions that are <a href="https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598">incorrectly typed for historical reasons</a>, e.g. <code>Object.assign</code>.</p><h2 id="The-thing-with-variance-and-arrays"><a href="#The-thing-with-variance-and-arrays" class="headerlink" title="The thing with variance and arrays"></a>The thing with variance and arrays</h2><p><strong>How often does this occur?</strong> I&#39;ve never personally run into this, but I also tend not to use very deep or complex type hierarchies.</p><p>This is a famous one. TypeScript TL <a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> <a href="https://github.com/microsoft/TypeScript/issues/9825#issuecomment-234115900">offers</a> this example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat()];<br>addDogOrCat(z); <span class="hljs-comment">// Sometimes puts a Dog in a Cat array, sad!</span><br></code></pre></td></tr></table></figure><p>What can <em>you</em> do about this? The best solution is to avoid mutating array parameters. You can enforce this via <code>readonly</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: <span class="hljs-keyword">readonly</span> Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>  <span class="hljs-comment">//  ~~~~ Property &#x27;push&#x27; does not exist on type &#x27;readonly Animal[]&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will prevent this type of unsoundness. Instead, you might write the example this way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogOrCat</span>(<span class="hljs-params"></span>): <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat();<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat(), dogOrCat()];<br><span class="hljs-comment">//                           ~~~~~~~~~~ error, yay!</span><br><span class="hljs-comment">// Type &#x27;Animal&#x27; is missing the following properties from type &#x27;Cat&#x27;: ...</span><br></code></pre></td></tr></table></figure><p><em>(See <a href="https://www.typescriptlang.org/play?ssl=5&ssc=1&pln=6&pc=1#code/MYGwhgzhAECCB2BLAtmE0DeBfAsAKH1EhgFkxlV0BTADwBcr4ATGBFNTfaaRCMitAF46AJwCuVANz5cBPESjQAwmDrRaDZqXKVOebrxV1h4qVx4QAIgHsA5oIBmaCGbyzC4RTdvr6jFtD8uhjmvN4mEtL6FkaOzq7ueA5i8MB0iNbw0GBMTN4A8iJGABRgIiIAXHBIlADaALoAlHrcZSIAdAAOYhAAFsVkdL3tImDM1sjFzQB80AAM7QCs0AD80PBUAO7Q3lPQVRvbJY2NUYnJqemZ0LZUdEHOU1UPIA0t0CJ3YiJZDWf4+AA9IDoAAhfAXNIZLK9SAlNpVNh1JrvT50b5ZNrtCATKjFKjQQSzAmIeAQOhjYBUawOZSqU4yQiZcnQGjPHRoN6CG53F4QKZRYDMtQAT0J0FhEBKNAZcmByiZZLUAC8qkYudBaoc6XQpvUojk8nZCiVladoPL5QBlXHpZBUGDdOgwMA7Ow8TE67LlMAigA00AgOQAhPggA">full playground example</a>.)</em></p><p>Why does TypeScript allow this? Presumably because <code>readonly</code> wasn&#39;t always part of the language. In the future you could imagine a &quot;strict&quot; option that would prevent these types of errors. In the initial example, the <code>addDogOrCat</code> call should only be allowed with a subtype of <code>Animal[]</code> if it&#39;s declared as <code>readonly Animal[]</code>. This will have the side effect of pushing libraries to get better about declaring parameters <code>readonly</code>, which would be a very good thing!</p><p>TypeScript used to have more issues around function calls and variance, and you might still see gripes about this online. But these were largely fixed with <code>--strictFunctionTypes</code>, which was <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#strict-function-types">introduced with TypeScript 2.6</a> in November 2017.</p><h2 id="Function-calls-don-39-t-invalidate-refinements"><a href="#Function-calls-don-39-t-invalidate-refinements" class="headerlink" title="Function calls don&#39;t invalidate refinements"></a>Function calls don&#39;t invalidate refinements</h2><p><strong>How often does this come up?</strong> I&#39;ve rarely seen it myself, though this may depend on your style and the libraries that you use.</p><p>Here&#39;s some code that doesn&#39;t look too suspicious at first glance (at least from a type safety perspective):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> FunFact &#123;<br>  fact: <span class="hljs-built_in">string</span>;<br>  author?: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (fact.author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = fact.author.blink();  <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Depending on what <code>processor</code> does, however, the call to <code>blink()</code> might throw at runtime:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">&#x27;Peanuts are not actually nuts&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>);<br><span class="hljs-comment">// Type checks, but throws `Cannot read property &#x27;blink&#x27; of undefined`.</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>if (fact.author)</code> refines the type of <code>fact.author</code> from <code>string | undefined</code> to <code>string</code>. This is sound. However, the call to <code>processor(fact)</code> <em>should</em> invalidate this refinement. The type of <code>fact.author</code> should revert back to <code>string | undefined</code> because TypeScript has no way of knowing what the callback will do to our refined fact.</p><p>Why does TypeScript allow this? Because most functions don&#39;t mutate their parameters, and this sort of pattern is common in JavaScript.</p><p>How can you avoid this? A simple way is to avoid deeply mutating your parameters. You can enforce that callbacks do this by passing them a <code>Readonly</code> version of the object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: Readonly&lt;FunFact&gt;) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">`Peanuts aren&#x27;t actually nuts`</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>  <span class="hljs-comment">//          ~~~~~~~~</span><br>  <span class="hljs-comment">// The operand of a &#x27;delete&#x27; operator cannot be a read-only property.</span><br>);<br></code></pre></td></tr></table></figure><p>(Note that <code>Readonly</code> is shallow; you&#39;ll need to use a tool like <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> to get a <code>DeepReadonly</code>.)</p><p>You can also avoid this issue by refining a value itself, rather than the object that contains it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;author&#125; = fact;<br>  <span class="hljs-keyword">if</span> (author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = author.blink();  <span class="hljs-comment">// safe</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Because <code>author</code> is a primitive type (not an object), it cannot be changed by the callback and the <code>blink()</code> call is safe.</p><!--Here's an alternate example using refinements from string|number and a global (via https://twitter.com/sebmck/status/1146524039227174914):https://www.typescriptlang.org/play?strict=true#code/DYUwLgBAbghsBcEB2BXAtgIxAJwgHwgGcxsBLJAcwgF4IByOgbgChmAzFJAYzFIHskEGIUKkKSAHLos2ABQBKCAG9mEaHBoQATCwC+rDt14CIaGOQXLVEUmwiywATwAOIPndjAa1WnVSYcOkUVNTUwAAtsPgB3ZBBYgFFsKLk6CT5kaRxCIWBgGJAAEyCWNX1rAHoKiAARATpIJBAioSRHGyRC0mwQHn5BcJwQa2FRcSkAuXkWSuqAFXDSHMJwvhRgQog2c2AAGhswOhyYTMnrLgFiIhJEYjJKTU89IA--><h2 id="There-Are-Five-Turtles"><a href="#There-Are-Five-Turtles" class="headerlink" title="There Are Five Turtles"></a>There Are Five Turtles</h2><p><strong>How often does this come up?</strong> More or less never; if you run into it in real-world code, you might get mentioned at tsconf!</p><p>Anders explains this best:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/wpgKd-rwnMw?start=1714" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>I&#39;ve never been able to find the issue he references in the talk. And I&#39;ve heard rumors that there are now seven turtles. If you know more about either of these, please let me know in the comments!</p><hr><p>Those are the seven sources! But maybe there are eight, or nine, or ten. If you have an example of unsoundness that doesn&#39;t fit into any of these categories, please <a href="https://twitter.com/danvdk">let me know</a> and I&#39;ll update the post.</p><p>Updates:</p><ul><li><a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> offers <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhjAvDAFADwPwC4ZgK4C2ARgKYBOAlEgHwyYB0UIAYgJZokAmKFA3ALAAoUJFhEcPGjABuIVpyTwBw8NBjAJEbDGhlWYAOZVEtWfMVFlwFACIbfIUA">an example</a> that stems from how TypeScripthandles function assignability and optional parameters.</li><li>Ryan offers <a href="https://twitter.com/SeaRyanC/status/1397979078150344707">another example</a> stemming from a loss of information when you assign to a type with optional properties.</li><li>Oliver Ash <a href="https://twitter.com/OliverJAsh/status/1404719755324497922">offers</a> <a href="https://www.typescriptlang.org/play?strict=true#code/MYewdgzgLgBAhjAvDA3jAZiEAuV9cAUAlEgHwwDkcFMAvnQNwBQoksARknpjnu4SUTkK7GvVrMW4aDAC2AUwBOAc3lcAPAEEANDABCpAnFw6Y-fYPIE0AOjtxddm51pFmrGcC4KV8o7vY3FhseGzhiBhgAeiiYMBAYABUAZRglRRBFMwBXWCgACwyAdwh4WEVssCgASwUAQgbg0PYIpik2GAATLhQnBxgndgkmTpCsMIiYaNj0zJGxkGdWoA">an example</a> stemming from how TypeScript models object spread as a deep intersection between generics whereas it really operates as a shallow intersection. See <a href="https://github.com/microsoft/TypeScript/issues/28326">design notes</a> on this issue.</li></ul><!--Another one from Ryan around assignability issues with optional properties and index signatureshttps://twitter.com/SeaRyanC/status/1397979078150344707Is this related to my issues?https://github.com/microsoft/TypeScript/issues/41418https://github.com/microsoft/TypeScript/issues/43045Or related to distinguising undefined and missing?https://github.com/microsoft/TypeScript/issues/13195Anders has a PR out to fix this!https://github.com/microsoft/TypeScript/pull/43947--><p>Further reading:</p><ul><li><a href="https://frenchy64.github.io/2018/04/07/unsoundness-in-untyped-types.html">Are unsound type systems wrong?</a>, a discussion of types of soundness and TypeScript&#39;s deliberate choice to be unsound (see also <a href="https://news.ycombinator.com/item?id=16780068">HN Comments</a>).</li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness">A Note on Soudness</a> from the TypeScript handbook; this page gives background on some of TypeScript&#39;s design decisions.</li><li><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&q=209#example/soundness">TypeScript Playground Soundness example</a>; this is a built-in example on the TypeScript Playground. Note that it does not have <code>strictFunctionTypes</code> enabled.</li></ul><!--https://github.com/microsoft/TypeScript-Handbook/issues/1059No excess property checks in object types with spread-> This is not unsoundness, just misunderstanding excess property checkingIncorrect definition of spread and Object.assign-> This is a spurious error, but that's not unsoundness, is it?-> This just seems like a bug-> Can easily be modified to be unsound.See https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598Maybe this falls under "incorrect library definitions"?Hacker News thread from 2017:https://news.ycombinator.com/item?id=15659657  Counterexamples here seem to revolve around variance, which has not been an issue for a while.Luca Cardelli, 1996 (quoted in _Types and Programming Languages_):> It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/square-peg-round-hole.png&quot; title=&quot;A square peg in a round hole&quot; width=&quot;212&quot; height=&quot;197&quot; style=&quot;float: right; padding-left: 10px;&quot;&gt;Hang out on the internet much and you&amp;#39;ll hear gripes about how TypeScript isn&amp;#39;t &amp;quot;sound,&amp;quot; and that this makes it a poor choice of language. In this post, I&amp;#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&amp;#39;s never a good idea to listen to people on the internet!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The trouble with Jsonify: Unify types instead of modeling small differences</title>
    <link href="https://effectivetypescript.com/2021/04/09/unify-over-model/"/>
    <id>https://effectivetypescript.com/2021/04/09/unify-over-model/</id>
    <published>2021-04-09T13:45:00.000Z</published>
    <updated>2021-04-09T13:39:14.154Z</updated>
    
    <content type="html"><![CDATA[<!-- Alternate title: the trouble with Jsonify --><p>Last year I wrote about <a href="/2020/04/09/jsonify/"><code>Jsonify</code></a>, a generic that models how a type changes as it goes through JSON serialization and deserialization. This is especially relevant for JavaScript <code>Date</code>s, which get converted to strings in this process:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; JSON.parse(JSON.stringify(d))<br>&#39;2021-04-07T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure><p>If you use a type on your server, <code>Jsonify</code> tells you what that type will look like on your client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <a href="/2020/04/09/jsonify/">original post</a> generated some <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/">strong</a> <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/">reactions</a>. Since I posted it, I&#39;ve learned two things:</p><p>First, <strong>I didn&#39;t come up with this.</strong> In fact, Anders presented it at <a href="https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s">his keynote</a> at the original TSConf, in 2018. He, in turn, based it on <a href="https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545">discussion</a> on GitHub. What&#39;s surprising is that <em>I was at that talk</em>! But it must have gone in one ear and out the other. In any case, <code>Jsonify</code> became much more compelling once TypeScript 3.7 introduced <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases">recursive type aliases</a> in Nov. 2019.</p><p>Second, I&#39;ve learned that <strong><code>Jsonify</code> isn&#39;t a good idea</strong>.</p><p>Why not? While it&#39;s neat that you can model a transformation like this in the type system, it wound up being quite annoying when my team put it into practice.</p><p>For example, if you have an API on the server that produces a <code>Student</code>, then your client-side code should work in terms of <code>Jsonify&lt;Student&gt;</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>As you pass the <code>student</code> object around your application, you&#39;ll get long error messages any time you forget the <code>Jsonify</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);<br>  <span class="hljs-comment">//             ~~~~~~~</span><br>  <span class="hljs-comment">// Argument of type &#x27;&#123; id: number; name: string; birthday: string | null; &#125;&#x27; is not assignable to parameter of type &#x27;Student&#x27;.</span><br>  <span class="hljs-comment">//   Types of property &#x27;birthday&#x27; are incompatible.</span><br>  <span class="hljs-comment">//     Type &#x27;string | null&#x27; is not assignable to type &#x27;Date | null&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;string&#x27; is not assignable to type &#x27;Date | null&#x27;. (2345)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Nothing about this error says &quot;you forgot <code>Jsonify</code>.&quot; We just had to learn &quot;any time you see something about <code>Date</code> and <code>string</code>, it means you forgot a <code>Jsonify</code> somewhere.&quot; In more realistic code, there can be many <code>Date</code> objects that are deeply nested, leading to even longer, more confusing errors. These <code>Date</code> fields typically weren&#39;t used by the function producing the error, so we weren&#39;t even gaining safety for our trouble.</p><p>After battling <code>Jsonify</code> for a few months, we decided to get rid of it by eliminating <code>Date</code>s from our API. Most of these were coming from our database. By default, <code>node-postgres</code> <a href="https://node-postgres.com/features/types#date--timestamp--timestamptz">converts Postgres date/timestamp columns</a> to <code>Date</code> objects. This makes a lot of sense as a default. But to keep our server and and client types equal, we decided to just use strings instead.</p><p>To make this work, we had to reconfigure the types returned by node-postgres:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;types&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br>types.setTypeParser(types.builtins.DATE, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMPTZ, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMP, _.identity);<br></code></pre></td></tr></table></figure><p>We use <a href="https://github.com/danvk/pg-to-ts"><code>pg-to-ts</code></a> (a fork of <a href="https://github.com/PSYT/schemats"><code>schemats</code></a>) to generate types from our database schema (which we consider a source of truth). So we had to <a href="https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c">adapt it</a> with a <code>--datesAsStrings</code> flag.</p><p>With these changes in place, our API types were fully unified: they were exactly the same on the server and the client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Used to be Date | null</span><br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Student&gt;;  <span class="hljs-comment">// exactly the same!</span><br></code></pre></td></tr></table></figure><p>So we could drop <code>Jsonify</code>! Now we could write code like this error-free:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);  <span class="hljs-comment">// ok!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The lesson here is that <strong>you should prefer to unify your types rather than model small differences between them.</strong> By unifying your types, you&#39;ll save all the time and effort you would have spent getting the transformations exactly correct and applied in exactly the right places.</p><p>As another example, it&#39;s common to have <code>snake_case</code> column names in your database and convert them to <code>camelCase</code> for JS/TS variable names and types in your API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> StudentTable &#123;<br>  first_name: <span class="hljs-built_in">string</span>;<br>  last_name: <span class="hljs-built_in">string</span>;<br>  birth_date: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  firstName: <span class="hljs-built_in">string</span>;<br>  lastName: <span class="hljs-built_in">string</span>;<br>  birthDate: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>As I discussed in my <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> post, <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types">as of TypeScript 4.1</a> you can model this snake_case  camelCase transformation in the type system. But should you? Following the mantra of &quot;unify rather than model small differences,&quot; clearly you should not! In this case you could either use <code>snake_case</code> names in your API or use a tool like <a href="https://github.com/hoegaarden/pg-camelcase">pg-camelcase</a> to convert the <code>snake_case</code> names to <code>camelCase</code> as you load them from the database (you can do something similar with <a href="http://knexjs.org/#Installation-wrap-identifier">knex</a>). In either case, you&#39;ll be able to forget about the type transformations entirely.</p><p>Of course, any rule comes with caveats.</p><p>First, this isn&#39;t always an option. You may need the two types if the database and the API aren&#39;t under your control. If this is the case, then modeling these sorts of differences systematically in the type system will help you find bugs in your transformation code. It&#39;s better than creating types ad-hoc and hoping they stay in sync.</p><p>Second, don&#39;t unify types that aren&#39;t representing the same thing! Say you have a tagged union, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseSuccess &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span>;<br>  payload: PayloadType;<br>&#125;<br><span class="hljs-keyword">interface</span> ResponseError &#123;<br>  status: <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  error: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Response = ResponseSuccess | ResponseError;<br></code></pre></td></tr></table></figure><p>It would be counterproductive to &quot;unify&quot; these types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don&#x27;t do this!</span><br><span class="hljs-keyword">interface</span> Response &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span> | <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  payload?: PayloadType;<br>  error?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This will make TypeScript less effective at finding bugs in your <code>Response</code>-handling code. The two <code>Response</code> types are fundamentally different, so they should not be unified. This rule is best applied to types that are fundamentally the same but superficially different.</p><p>If you find yourself creating lots of types that are only slightly different from one another, consider unifying them. You&#39;ll be happy you did!</p>]]></content>
    
    <summary type="html">
    
      Last year I wrote about &lt;code&gt;Jsonify&lt;/code&gt;, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with &lt;code&gt;Jsonify&lt;/code&gt; and 2) It&#39;s a bad idea!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Advent of Code 2020, this time in Rust</title>
    <link href="https://effectivetypescript.com/2021/03/24/advent-of-code/"/>
    <id>https://effectivetypescript.com/2021/03/24/advent-of-code/</id>
    <published>2021-03-24T04:00:00.000Z</published>
    <updated>2021-03-24T21:34:22.977Z</updated>
    
    <content type="html"><![CDATA[<p>There&#39;s been <a href="https://fettblog.eu/learning-rust-and-go/">lots of interest</a> in Rust in the JavaScript and TypeScript community over the past few years, both because <a href="https://rustwasm.github.io/book/">it can target WebAssembly</a> and because <a href="https://github.com/denoland/deno">deno</a> is written in Rust.</p><p>Last year I decided to learn Rust by doing the <a href="https://adventofcode.com/">Advent of Code</a> in it: two puzzles every day of December leading up to Christmas. I had a great time and learned a lot about Rust, and I&#39;d highly recommend this as a way to learn a language.</p><p>Since this is a bit off-topic for the <em>Effective TypeScript</em> blog, I posted my writeup on Medium. If you&#39;re interested in Rust, check it out: <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">Advent of Code 2020 (this time in Rust)</a>.</p><p>TL;DR: Rust is an interesting language that works great for a specific niche, but it&#39;s a bit annoying to work with and I wouldn&#39;t choose to use it unless I was working in its niche. Also, this year&#39;s Advent of Code was too easy!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;There&amp;#39;s been &lt;a href=&quot;https://fettblog.eu/learning-rust-and-go/&quot;&gt;lots of interest&lt;/a&gt; in Rust in the JavaScript and TypeScript commun
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Four words to avoid in TypeScript writing</title>
    <link href="https://effectivetypescript.com/2021/02/03/pet-peeves/"/>
    <id>https://effectivetypescript.com/2021/02/03/pet-peeves/</id>
    <published>2021-02-03T18:40:00.000Z</published>
    <updated>2021-02-03T18:52:46.721Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;ve <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);">written</a> <a href="https://effectivetypescript.com/archives/">many words</a> about TypeScript and I&#39;m sure I&#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!</p><a id="more"></a><ol><li><p><strong>&quot;Typescript&quot;</strong></p><p>It&#39;s not Typescript. It&#39;s Type<strong>S</strong>cript. Capital T, capital S. Fun fact: it&#39;s also JavaScript, capital J, capital S. I thought about ending my post here, this one bugs me so much! If you want to be taken seriously, you need to spell the name of the language correctly. The most egregious example of &quot;Typescript&quot; I know of this is the title of the <a href="https://www.reddit.com/r/typescript" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/typescript', event);">r/typescript</a> subreddit. (I&#39;ve requested that this be fixed several times, but to no avail.)</p></li><li><p><strong>&quot;strongly-typed&quot;</strong></p><p>This one is hyphenated, sorry. I don&#39;t like it because no one can agree on what &quot;strongly-typed&quot; means. The TypeScript types that look &quot;strong&quot; to you coming from a Java background might look weak to a Haskell developer. Or to someone who&#39;s been using TypeScript a bit longer. And can types that go away at runtime really be considered strong?</p><p>When you write &quot;strongly typed,&quot; perhaps you mean to write &quot;statically typed&quot; (which TypeScript is) or &quot;sound&quot; (which it isn&#39;t)? Adding to the confusion, a <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection', event);">weak type</a> is something very specific in TypeScript, and it&#39;s probably not the opposite of the &quot;strong types&quot; that you have in mind.</p></li><li><p><strong>&quot;advanced&quot;</strong></p><p>Expertise in programming is less about using &quot;advanced&quot; features and more about learning how to effectively use the basic building blocks of your language. To me, using the word &quot;advanced&quot; when discussing features like conditional types implies that that the more you use these features, the more &quot;advanced&quot; you are as a TS programmer. I prefer the word &quot;fancy&quot; (as in &quot;fancy types&quot;) since that has more accurate connotations about how often you really need to use these features. After all, the first rule of generics is to <a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">avoid them if you can</a>.</p></li><li><p><strong>&quot;cast&quot;</strong></p><p>The correct term for the expression <code>x as number</code> is &quot;type assertion&quot;. I don&#39;t like the word &quot;cast&quot; because in most languages (C, C++, Java, Rust, ), a cast can have an effect at runtime. In C, for example, <code>(int)f</code> will  convert a <code>float</code> into an <code>int</code> by rounding down. But because <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'http://neugierig.org/software/blog/2016/04/typescript-types.html', event);">TypeScript types are erased at runtime</a>, the <code>as number</code> can&#39;t possibly have an effect. If you look at the generated JS in the <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOB5eA5ArgWxgXhgWQEMoALAOngLABMQMAKAShgH4YByAFgCY2YAuGNwDcAWABQoSLDCYccKElSyCEGDIwAjAKbwhMGAHoDMADwBaMzAAiILRDBtYBYFDQEANu4CeMAETAVKF8YLxA0eHl4AEswAHMYKBAYAjVMbXgAQnEgA" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOB5eA5ArgWxgXhgWQEMoALAOngLABMQMAKAShgH4YByAFgCY2YAuGNwDcAWABQoSLDCYccKElSyCEGDIwAjAKbwhMGAHoDMADwBaMzAAiILRDBtYBYFDQEANu4CeMAETAVKF8YLxA0eHl4AEswAHMYKBAYAjVMbXgAQnEgA', event);">TypeScript playground</a>, you can see this plainly. It&#39;s called a &quot;type assertion&quot; because you&#39;re asserting that the value <em>already</em> has the type you say it does. You&#39;re not &quot;casting&quot; it into that type. Item 9 of <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>, <em>Prefer Type Declarations to Type Assertions</em>, has much more to say about exactly when it&#39;s appropriate to use type assertions.</p></li></ol><p>I always try to maintain a positive tone in public forums, and I certainly don&#39;t want this post to discourage anyone from writing about <del>Typescript</del> TypeScript. If you&#39;ve learned something about the language and want to share it online, that&#39;s great! I hope you do. But please avoid these four terms!</p><!--1. Thinking "types" are only about "type safety"   Actually they drive all the great language service features.   `tsserver` is just as important as `tsc`.   This is what makes people love TS!2. Misc incorrect terminology:   1. "type assertion" vs. "cast" (it cannot have a runtime effect, unlike some `C++` casts.)   2. String literal vs. string literal type3. Prefixing all your interfaces with `I`. If you do this, then you should probably prefix your types with `T` and your classes with `I`. And maybe your numbers with `n` and your strings with `s`?4. Using object wrappers for everything. TypeScript isn't Java. This isn't the kingdom of the nouns! (See ch10 of _Mastering TypeScript_.)5. Putting type annotations on all your variables and function parameters, for example `beforeEach((done: jest.DoneCallback)` in ch10 of _Mastering TypeScript_.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I&amp;#39;ve &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;written&lt;/a&gt; &lt;a href=&quot;https://effectivetypescript.com/archives/&quot;&gt;many words&lt;/a&gt; about TypeScript and I&amp;#39;m sure I&amp;#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 3: Avoid Repeating Type Expressions</title>
    <link href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/"/>
    <id>https://effectivetypescript.com/2021/01/20/gentips-3-aliases/</id>
    <published>2021-01-21T02:40:00.000Z</published>
    <updated>2022-02-25T16:31:20.862Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: Avoid Repeating Type Expressions</li><li>Part 4: <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">The Display of Types</a></li></ul><p>Recently there&#39;s been some <a href="https://twitter.com/kentcdodds/status/1348016701632221184">chatter</a> online about how you should use <a href="https://fettblog.eu/tidy-typescript-name-your-generics/">long names for generic types</a> (i.e. longer than just <code>T</code>). I&#39;d generalize all this a bit to say:</p><p><strong>Just because you&#39;re writing generics, don&#39;t forget everything you&#39;ve learned about programming!</strong></p><p>So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.</p><p>This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&#39;re worth learning because they&#39;re usually better than repeating yourself!</p><span id="more"></span><p>As a motivating example, we&#39;ll look at how <a href="https://github.com/danvk/crosswalk">crosswalk</a> registers express endpoints (see the <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> for background on crosswalk). Recall that an API definition in crosswalk looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">&#x27;/users&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">the last post</a> we looked at how crosswalk defines safe wrappers to register handlers for an endpoint. Here&#39;s what usage looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>app.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> (params, request, response) =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>The <code>params</code> object has a type based on the path (<code>/users/:userId</code>) and the response is required to be <code>Promise&lt;User&gt;</code> (based on the <code>API</code> interface). Here&#39;s the implementation we wound up with in the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">last post</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ...;<br><span class="hljs-comment">// See https://twitter.com/danvdk/status/1301707026507198464</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-comment">// ... implementation ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The real crosswalk API passes the express <code>request</code> and <code>response</code> objects to the callback as well as the path params. And express requests and responses <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8d49ebd3e913bdbb90294d7672cda5884566d62a/types/express/index.d.ts#L112-L118">take several generic parameters</a>: the path params, the request body type and the response type. For a GET request, we can ignore the request type (there&#39;s no request body) but the other two are relevant. They let you reference <code>request.params</code> and get a type, for example.</p><p>Here&#39;s what this looks like, focusing just on <code>get</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;<br>    &gt;,<br>    response: express.Response&lt;<br>      LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;<br>    &gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Wow that&#39;s a lot of a lot of repetition! The <code>ExtractRouteParams</code> clause appears twice and the response type (the <code>LooseKey2</code> bit) appears three times. It would be even worse for the <code>post</code> handler, where we have a request body to type, too.</p><p>So what can you do about this? There are a few options. They&#39;re better than nothing but, as we&#39;ll see, none are perfect.</p><h3 id="Factor-out-helper-types"><a href="#Factor-out-helper-types" class="headerlink" title="Factor out helper types"></a>Factor out helper types</h3><p>This is the generic equivalent of factoring out a helper function. Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You can factor the repeated bits out into a helper type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Exp&lt;T&gt; = Expression&lt;Involving&lt;T&gt;&gt;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">a: Exp&lt;T&gt;, b: Exp&lt;T&gt;</span>): <span class="hljs-title">Exp</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>(Of course, you should give the helper type a semantically meaningful name if possible.)</p><p>In the case of the crosswalk <code>get</code> method, we might want to factor out a helper to extract the <code>response</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> GetResponse&lt;API, Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt; =<br>  LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;;<br><br>get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      GetResponse&lt;API, Path&gt;<br>    &gt;,<br>    response: express.Response&lt;GetResponse&lt;API, Path&gt;&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;GetResponse&lt;API, Path&gt;&gt;<br>)<br></code></pre></td></tr></table></figure><p>While this does cut down on repetition in the <code>get</code> declaration itself, it forces us to repeat the constraint on <code>Path</code>. As with helper functions, helper types work best when they are semantically meaningful on their own. This makes them easier to think about and increases the likelihood that they&#39;ll be useful in other places.</p><h3 id="Introduce-a-local-type-alias"><a href="#Introduce-a-local-type-alias" class="headerlink" title="Introduce a local type alias"></a>Introduce a local type alias</h3><p>The <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> in this series looked at how you can use classes and currying to introduce new inference sites. Currying has another advantage: it introduces a new scope in which you can create type aliases (you can&#39;t introduce a type alias scoped to a <code>class</code>).</p><p>Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You could write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">type</span> Exp = Expresion&lt;Involving&lt;T&gt;&gt;;<br><br>  <span class="hljs-keyword">return</span> (a: Exp, <span class="hljs-attr">b</span>: Exp): <span class="hljs-function"><span class="hljs-params">Exp</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>By changing the signature, we&#39;re able to introduce a type alias that depends on the generic parameter, <code>T</code>. This greatly simplifies the resulting generic and doesn&#39;t require us to repeat any bounds on the generic parameters.</p><p>Here&#39;s what <code>get</code> might look like if we curried it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path<br>) =&gt; &#123;<br>  <span class="hljs-keyword">type</span> Params = ExtractRouteParams&lt;Path&gt;;<br>  <span class="hljs-keyword">type</span> ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;;<br><br>  <span class="hljs-keyword">return</span> (<br>    handler: (<br>      params: Params,<br>      request: express.Request&lt;Params, Response&gt;,<br>      response: express.Response&lt;Response&gt;<br>    ): <span class="hljs-built_in">Promise</span>&lt;Response&gt;) =&gt; &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>This is much clearer and much less repetitive. The downside is that it&#39;s more complicated for the caller. One hybrid option is to have a public, non-curried function that delegates to a curried, internal function. See crosswalk&#39;s <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L88"><code>registerWithBody</code></a> for an example of this in action.</p><h3 id="Add-Generic-Parameters-with-Defaults"><a href="#Add-Generic-Parameters-with-Defaults" class="headerlink" title="Add Generic Parameters with Defaults"></a>Add Generic Parameters with Defaults</h3><p>What if you&#39;re defining a type alias, rather than a generic function? Then you can&#39;t create a local scope since there&#39;s no function body.</p><p>But if you&#39;re repeating the same type expression <em>a lot</em>, there is one mediocre option available: you can define another generic parameter with a default value.</p><p>Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A&gt; = [F&lt;A&gt;, F&lt;A&gt;, F&lt;A&gt;];<br></code></pre></td></tr></table></figure><p>You&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A, B <span class="hljs-keyword">extends</span> F&lt;A&gt; = F&lt;A&gt;&gt; = [B, B, B];<br></code></pre></td></tr></table></figure><p>You have to write <code>F&lt;A&gt;</code> twice, so this trick isn&#39;t helpful unless it appears three or more times in your type alias.</p><p>You can use the same technique with generic functions. For example, here&#39;s how you might write crosswalk&#39;s <code>get</code> with an extra generic parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  ResponseType <span class="hljs-keyword">extends</span><br>    LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt; =<br>    LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;,<br>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      ResponseType<br>    &gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Because <code>ResponseType</code> appears three times, defining it this way <em>does</em> reduce repetition. But because <code>ExtractRouteParams&lt;Path&gt;</code> only appears twice, factoring that out in the same way wouldn&#39;t be a win.</p><p>The upside of this technique is that it effectively introduces a local type alias without changing the function signature. The downside is that it&#39;s gross and potentially confusing for your users, who may think they need to pass a value for the additional type parameter. But it works with type aliases and it&#39;s (arguably) better than nothing!</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Just because you&#39;re doing generic programming, don&#39;t forget that you&#39;re programming! Cryptic code is hard to follow, so use meaningful type names. And repetitive code is hard to follow and error-prone, so use the techniques at your disposal to reduce repetition.</p><p>Admittedly none of these options are perfect. I&#39;ve filed a <a href="https://github.com/microsoft/TypeScript/issues/42388">feature request</a> to support <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">Rust-style <code>where</code> syntax</a> for generics, which would let you write <code>get</code> like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get(<br>  path: Path,<br>  handler: (<br>    params: Params,<br>    request: express.Request&lt;Params, ResponseType&gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) where<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  Params = ExtractRouteParams&lt;Path&gt;,<br>  ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;,<br>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>In other words, you&#39;d get the local type alias without any of the downside. This would make the story around reducing repetition much better (and this blog post happily obsolete!). If you like the idea, please go vote it up!</p><p>The posts in this series have looked at how generic types are computed and inferred. In the next (and hopefully last) post, we&#39;ll look at your options for controlling how they&#39;re displayed.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This is part of an ongoing series on tips I learned for working with TypeScript generics from building the &lt;a href=&quot;https://github.com/danvk/crosswalk&quot;&gt;crosswalk&lt;/a&gt; library. Check out &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;part 1&lt;/a&gt; for more background.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part 0: &lt;a href=&quot;/2020/08/12/generics-golden-rule/&quot;&gt;The Golden Rule of Generics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 1: &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;Use Classes and Currying to create new inference sites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 2: &lt;a href=&quot;https://effectivetypescript.com/2020/12/09/gentips-2-intersect/&quot;&gt;Intersect what you have with whatever TypeScript wants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3: Avoid Repeating Type Expressions&lt;/li&gt;
&lt;li&gt;Part 4: &lt;a href=&quot;https://effectivetypescript.com/2022/02/25/gentips-4-display/&quot;&gt;The Display of Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recently there&amp;#39;s been some &lt;a href=&quot;https://twitter.com/kentcdodds/status/1348016701632221184&quot;&gt;chatter&lt;/a&gt; online about how you should use &lt;a href=&quot;https://fettblog.eu/tidy-typescript-name-your-generics/&quot;&gt;long names for generic types&lt;/a&gt; (i.e. longer than just &lt;code&gt;T&lt;/code&gt;). I&amp;#39;d generalize all this a bit to say:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Just because you&amp;#39;re writing generics, don&amp;#39;t forget everything you&amp;#39;ve learned about programming!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.&lt;/p&gt;
&lt;p&gt;This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&amp;#39;re worth learning because they&amp;#39;re usually better than repeating yourself!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Top Posts of 2020</title>
    <link href="https://effectivetypescript.com/2021/01/09/top-posts-2020/"/>
    <id>https://effectivetypescript.com/2021/01/09/top-posts-2020/</id>
    <published>2021-01-10T03:30:00.000Z</published>
    <updated>2021-01-10T03:03:33.541Z</updated>
    
    <content type="html"><![CDATA[<p>I <a href="https://effectivetypescript.com/2020/03/06/hello-world/">started</a> the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&#39;d still be working remotely. It&#39;s been quite a year.</p><p>I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:</p><a id="more"></a><ol><li><p><a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a> (August 12th)</p><p>My most popular post is based on <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice', event);">advice in the TypeScript handbook</a>. The alternate title was &quot;Good use of generics or bad use of generics?&quot; This showcasing of good examples and bad examples made this article fun to write and, evidently, fun to read as well. The <a href="https://www.reddit.com/r/programming/comments/i8zqp9/good_use_of_generics_or_bad_use_of_generics/?" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/i8zqp9/good_use_of_generics_or_bad_use_of_generics/?', event);">extensive discussion</a> on r/programming is worth reading. I&#39;m intrigued by the idea of introducing generic parameters as a way of simulating nominal types to help get a function&#39;s implementation correct.</p></li><li><p><a href="https://effectivetypescript.com/2020/04/09/jsonify/">What&#39;s the type of JSON.parse(JSON.stringify(x))?</a> (April 9th)</p><p>I was quite happy when I &quot;discovered&quot; this trick, only to learn a few months later that I&#39;d subconsciously cribbed it from Anders Hejlsberg&#39;s <a href="https://www.youtube.com/watch?t=2550&v=wpgKd-rwnMw" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.youtube.com/watch?t=2550&v=wpgKd-rwnMw', event);">excellent tsconf 2018 keynote</a>. Whatever the provenance, I&#39;ve soured on tools like <code>Jsonify</code>. Better to unify types instead of modeling small differences. Look for a future post on this topic. Also notable on this was the wildly different response on <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">r/typescript</a> vs. <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/26/iterate-objects/">Item 54: Know How to Iterate Over Objects</a> (May 26th)</p><p>The blog started with several sample items from <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> and this one has done well with Google: &quot;Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the quirks of JavaScript objects and duck typing.&quot;</p></li><li><p><a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> (November 5th)</p><p>Template Literal Types are one of the most exciting additions to TypeScript in years, and we&#39;re all just starting to learn how to use them. This post introduces them to an audience that may not be familiar with TypeScript and explains why I think they&#39;re a particularly <em>TypeScripty</em> solution to a long-standing class of issues. See <a href="https://www.reddit.com/r/programming/comments/jsakpy/typescript_splits_the_atom_a_first_look_at_ts_41s/?" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.reddit.com/r/programming/comments/jsakpy/typescript_splits_the_atom_a_first_look_at_ts_41s/?', event);">discussion on r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a> (May 12th)</p><p>This article was inspired by a particularly insightful <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">answer</a> from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian Cernicova Dragomir</a> on Stack Overflow. I kept finding more uses for his trick, and I wanted to give it a catchy name. <code>Unionize</code> it is! I&#39;m quite proud of this post and I&#39;m happy to see it crack the top five.</p></li></ol><p>I&#39;m excited to see what 2021 brings to TypeScript! I&#39;ve started a <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">series on generics</a> that I plan to wrap up this month. I&#39;m working on &quot;Pet Peeves in TypeScript Writing&quot; post, and am planning some kind of (now late) &quot;Writing a book, the view from a year out&quot; retrospective. Subscribe or follow for updates!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I &lt;a href=&quot;https://effectivetypescript.com/2020/03/06/hello-world/&quot;&gt;started&lt;/a&gt; the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&amp;#39;d still be working remotely. It&amp;#39;s been quite a year.&lt;/p&gt;
&lt;p&gt;I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 2: Intersect what you have with whatever TypeScript wants</title>
    <link href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/"/>
    <id>https://effectivetypescript.com/2020/12/09/gentips-2-intersect/</id>
    <published>2020-12-09T22:50:00.000Z</published>
    <updated>2022-02-25T16:30:35.635Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: Intersect what you have with whatever TypeScript wants</li><li>Part 3: <a href="/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">The Display of Types</a></li></ul><p>Recall that an API definition in <a href="https://github.com/danvk/crosswalk">crosswalk</a> looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">&#x27;/users&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(<code>Endpoint</code> and <code>GetEndpoint</code> are simple type aliases <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6">defined by the library</a>. Their parameters are request and response types.)</p><p>In <a href="/2020/12/04/gentips-1-curry/">last week&#39;s post</a> we defined a <code>getUrl</code> function to safely generate API URLs. In this week&#39;s post, we&#39;ll create type-safe wrappers around <a href="https://expressjs.com/">express</a> methods to handle these endpoints.</p><p>Here&#39;s how you typically register a <code>get</code> handler in express:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, <span class="hljs-keyword">async</span> (request, response) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;userId&#125; = request.params;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUserById(userId);<br>  response.json(user);<br>  <span class="hljs-comment">// (error handling omitted)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>There are a few issues with this from a TypeScript perspective:</p><ol><li>The type of <code>request.params</code> is <code>any</code>. This means that <code>userId</code> also gets an <code>any</code> type, and this destructuring assignment is completely unsafe.</li><li>The call to <code>response.json()</code> doesn&#39;t check the type of its argument. In fact, nothing checks that we call <code>response.json</code> at all.</li></ol><p>Crosswalk defines a typed wrapper so that the registration looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>typedRouter.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>Instead of using <code>response.json</code> to send a response, we return <code>Promise&lt;User&gt;</code>, which TypeScript checks against the <code>API</code> interface. Additionally, thanks to <a href="/2020/11/05/template-literal-types/">the magic of <code>ExtractRouteParams</code></a>, <code>params</code> has an inferred type of <code>&#123;userId: string&#125;</code>, so the reference to <code>params.userId</code> is type safe.</p><p>Let&#39;s take a crack at implementing <code>TypedRouter</code>. As <a href="/2020/12/04/gentips-1-curry/">last week&#39;s tip</a> explained, you can either use a class or a <a href="https://wiki.haskell.org/Currying">curried function</a> to capture the <code>API</code> type parameter. In this case let&#39;s use a class. Then we can use a method (<code>get</code>) that infers a string literal type for the path. Here&#39;s a sketch:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;unknown&gt;  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> fill in this type!</span><br>  ) &#123;<br>    <span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This gets us some of the way there: the <code>params</code> parameter to our handler is getting the correct type:</p><p><img src="https://effectivetypescript.com/images/gentips-2-inferred-params.png" alt="path parameters being inferred"></p><p>But what about that return type? Really you&#39;d like to look it up from the <code>API</code> interface given <code>Path</code>.</p><p>Here&#39;s how you&#39;d do that with a type alias:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Response = API[<span class="hljs-string">&#x27;/users/:userId&#x27;</span>][<span class="hljs-string">&#x27;get&#x27;</span>][<span class="hljs-string">&#x27;response&#x27;</span>];<br><span class="hljs-comment">// type is User</span><br></code></pre></td></tr></table></figure><p>If you plug that into our <code>get</code> function, however, you get several errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;API[Path][<span class="hljs-string">&#x27;get&#x27;</span>][<span class="hljs-string">&#x27;response&#x27;</span>]&gt;<br>  <span class="hljs-comment">//           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br>  <span class="hljs-comment">// Type &#x27;Path&#x27; cannot be used to index type &#x27;API&#x27;. (2536)</span><br>  <span class="hljs-comment">// Type &#x27;&quot;get&quot;&#x27; cannot be used to index type &#x27;API[Path]&#x27;. (2536)</span><br>  <span class="hljs-comment">// Type &#x27;&quot;response&quot;&#x27; cannot be used to index type &#x27;API[Path][&quot;get&quot;]&#x27;. (2536)</span><br>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>It&#39;s reasonable for TypeScript to complain here. We haven&#39;t constrained <code>API</code> or <code>Path</code>, so it has no reason to believe that <code>Path</code> is defined on <code>API</code>, let alone that it has a <code>get</code> property which has a <code>response</code> property.</p><p>You can fix the first of these errors by changing:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends string&gt;(<br>+ get&lt;Path extends keyof API&gt;(<br></code></pre></td></tr></table></figure><p>Unfortunately, this introduces a <em>new</em> error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//              ~~~~</span><br><span class="hljs-comment">// Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;(string | RegExp)[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>(The full error is quite long, but that&#39;s the important part.)</p><p>The problem is that express wants the <code>path</code> parameter to be a <code>string</code> (or a <code>RegExp</code>), but in TypeScript, <code>keyof API</code> is a <code>PropertyKey</code>, which is <a href="https://github.com/microsoft/TypeScript/blob/4dc82fdfba577085a087db6535a4ad2cc755e503/lib/lib.es5.d.ts#L105">defined in the standard library</a> as:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyKey = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol;<br></code></pre></td></tr></table></figure><p>The <code>number</code> is a lie (Item 16 of <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a>, &quot;Prefer Arrays, Tuples, and ArrayLike to number Index Signatures&quot;, explains this in great detail). But <code>path</code> could certainly be a <code>string</code> or <code>symbol</code>. We don&#39;t care about the <code>symbol</code> or <code>number</code> cases, though. We only want the <code>string</code>. To get down to this, you can use an intersection type:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends keyof API&gt;(<br>+ get&lt;Path extends keyof API &amp; string&gt;(<br></code></pre></td></tr></table></figure><p>This eliminates the error with <code>router.get</code>! This intersection trick winds up being an extremely useful way to get rid of TypeScript errors with generics. As it turns out, it&#39;s this week&#39;s tip!</p><p><strong>To get rid of generic type errors, intersect what you have with whatever TypeScript wants.</strong></p><p>Let&#39;s use the same trick to get rid of the remaining two errors:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39;][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;get&quot;&#39; cannot be used to index type &#39;API[Path]&#39;. (2536)<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot;]&#39;. (2536)<br></code></pre></td></tr></table></figure><p>In the first error, TypeScript is saying that it&#39;s seeing <code>&#39;get&#39;</code>, but it wants something that can index <code>API[Path]</code>. In other words, <code>keyof API[Path]</code>. So let&#39;s intersect!</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot; &amp; keyof API[Path]]&#39;. (2536)&#96;&#96;&#96;<br><br>Voila! The error is gone! It&#39;s like magic. You can get rid of the remaining error using the same trick. Watch out, this is going to get a little wordy:<br><br>&#96;&#96;&#96;ts<br>Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39; &amp; keyof API[Path][&quot;get&quot; &amp; keyof API[Path]]]&gt;<br></code></pre></td></tr></table></figure><p>And the errors are gone! What&#39;s more, we have perfect type inference. The error if you return the wrong type from a handler is exactly what you&#39;d hope for:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">typedRouter.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//              ~~~~</span><br>  <span class="hljs-comment">// Type &#x27;Promise&lt;null&gt;&#x27; is not assignable to type &#x27;Promise&lt;User&gt;&#x27;.</span><br>  <span class="hljs-comment">//   Type &#x27;null&#x27; is not assignable to type &#x27;User&#x27;. (2322)</span><br>);<br></code></pre></td></tr></table></figure><p>But this a mess. The issue is that for every index operator, you also have to introduce a <code>keyof</code>. And with three index operators (<code>Path</code>, <code>&#39;get&#39;</code>, <code>&#39;response&#39;</code>), this has spiraled out of control.</p><p>You can improve things with a short helper:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br></code></pre></td></tr></table></figure><p>This is like <code>T[K]</code> except that it doesn&#39;t require evidence that <code>K</code> is actually a key of <code>T</code>. (If it&#39;s not, it will resolve to <code>never</code>.) The win here is that while <code>T</code> appears twice in the definition of <code>LooseKey</code>, it only appears once when you use it. Here&#39;s how you can use it to simplify the monstruous type expression from earlier:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39; &amp; keyof API[Path][&quot;get&quot; &amp; keyof API[Path]]]&gt;<br>+ Promise&lt;LooseKey&lt;LooseKey&lt;API[Path], &#39;get&#39;&gt;, &#39;response&#39;&gt;&gt;<br></code></pre></td></tr></table></figure><p>As before, this still resolves all our types perfectly. You could even define a <code>LooseKey2</code> to simplify things a bit more:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><br><span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br></code></pre></td></tr></table></figure><p>(You could define a variadic version of this that works on tuples of keys. Give it a try!)</p><p>This technique also comes in handy with <a href="https://github.com/microsoft/TypeScript/pull/40336">template literal types</a>. For example, let&#39;s define a generic type that capitalizes the property names of another type. You can do this using the built-in <code>Capitalize</code> generic and a mapped type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K&gt;]: T[K];<br>  <span class="hljs-comment">//                          ~</span><br>  <span class="hljs-comment">// Type &#x27;K&#x27; does not satisfy the constraint &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//   Type &#x27;keyof T&#x27; is not assignable to type &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//     Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. (2344)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This looks familiar! TypeScript wants a <code>string</code>, but we&#39;ve got a <code>PropertyKey</code>. By now you should see how to solve the problem: intersect with whatever TS wants!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K &amp; <span class="hljs-built_in">string</span>&gt;]: T[K];<br>&#125;<br></code></pre></td></tr></table></figure><p>and now this works as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Caps&lt;&#123;<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>&#125;&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     Name: string;</span><br><span class="hljs-comment">//     Age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>Of course, there&#39;s no free lunch. The downside of this approach is that TypeScript won&#39;t check that the property accesses in your generic are safe. You&#39;ll need to verify them in some other way, <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">probably with a test</a>. But it&#39;s undeniably convenient to have this safety valve available! You can think of it as a rough equivalent of <code>as any</code> for generic types.</p><p>Here&#39;s our final version of <code>TypedAPI</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>As usual, you can find the <a href="https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wKYA8xQ69AMyghDgHJtd9VyBuAKAaunmADsYMpDkBjDHACi7ACaQOMADwAlDAEcArvhgAaOHNSR2qDAD44AbwZw4eJSoBcGhctQxGpvFog6M1zdt2MAvsxyscDAAnmCCAOIYMCLiEJKy+F76cAC8wmISnFLsigA2ueqerrp6jAyS3LwCcACqulBGQaHuFIr19HB+FTz8gnXcqEVujW0D1v1QANoAunSd5ZyVvXAAwnjIXBNyFvaN7MggLfZQHADmc12LPdU1YKIbGBN7BxgA-NbHZ51lAPQ-cABlDCCAAWMBgYFQlj+p2AMBBigARgA6PikH73dgANwA1j8+CQCAB3ZC5HH+SCwODdKqCACCAAUAJJGEwUH6jKC0azGUymU5RayRaIZOJZCaDRLFfSOPmQezWGKZaRrDAPLa2FTqCalNk+WXkDn1VA-Sycpmicg8tn8wVwYVKsXSHWy0xgRQwRWi+K3e6bera+q60x+PwMP6A4FwMEQ6E-XIQPikkEQBUAFgADFmfgAmDN5n4ARkLPwzAFYflxwLkHgBaXJw7ik2shMImimBVuCIRYGBQfgwGQQD0YBnIfsgVBSAAqBjSn3Yp0wvYwYnQ07ZrxsaKgoikC9O6gPejZ1mny64a7gAAMACSGDiEbhwAD6AJg45gPks98fz7HE4+D8v7sE+DSaF+16bo0kw4tS7BwABBxwAAPnAOIYMEECEMIvb9nwg7DlwSGTgk9h6NMHx9l8fimGeF6rqI6B3g+oHPm+H6wN+IFgYh44HD4UGmFuhhwLB8F8ROlFwAe8x0UY+pMKIGB8DWeBwLkUQoGAYDWFQzioMiQ4jlAjDKap46CIQijsARwCuHAAowBMABCwQWgAFOaohUSci4AJTWAyJAgMAuhSC6TBdjYLjDGkjJMpMhqciaZr1Ba5DTElTmZUlzhJJljARtFYW1PUUXNHAAAyECphgADSmEzuo9VznA06TPVcAAGToZh2HtbMDDRTVdWNcEObNXA9WFi1OZtaNujjVIi0NU104tYWehzbqDAWQQ7XNKIxlcFAUgJQYvJwGiOh9ooBHQB5uDAFiDxmER3B6TgBlGR9UD+QpbJOVIY7wgxV4YVhOEJT1MnUYuegeTacBgBsIJBWjqjIyCyBiJpUDWEjfJyvxk6KnhA4naOpNTqDILbcjAMpAYwWkGFGArbVS2YZNCWTHT0zqOQOVC-l0rkHoJ6mADV2mPCYXIiQJnIk5T2Y3AHnmHYahmFKbhM5dyOmDjePcJrmr2MiqMTqg-lG3AyLwquHkQIiABWqQGGLbjIm7qCuC77v+f5rqdHbIYMGGN27F2x1-akcDsBgRKHWEccmedzKI8gOkh8NR1U1AKtRET7Ipaa3nkFjphoMEtkozTnuOVErnuaIas28i3l23n+dhKsOdTrOCdXZ1EmQwN55oAPYBwqSwAAF4c11vXHtJHX1dMkcVf355pCsg9SIY+yHL5ZzqMgArWDkICItwPi6sVlV76yEbEwAci8Z+LkV-zE3SV9E6KFvtwX+8wgA">full code</a> for this post on the TypeScript playground.</p><p>Next week we&#39;ll add the express Request and Response objects to the callback and look at ways to mitigate the repetition of types that follows.</p>]]></content>
    
    <summary type="html">
    
      When you&#39;re working with generic types and run into a seemingly unavoidable error, there&#39;s a trick that can often make it go away: intersect what you have with whatever TypeScript wants it to be. Your errors will melt away! Read on for examples and caveats.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 1: Use Classes and Currying to create new inference sites</title>
    <link href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/"/>
    <id>https://effectivetypescript.com/2020/12/04/gentips-1-curry/</id>
    <published>2020-12-04T05:00:00.000Z</published>
    <updated>2022-02-25T16:30:50.534Z</updated>
    
    <content type="html"><![CDATA[<ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: Use Classes and Currying to create new inference sites</li><li>Part 2: <a href="/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">The Display of Types</a></li></ul><p>Perhaps the best thing about <a href="http://scottmeyers.blogspot.com/2013/01/effective-effective-books.html">Effective-style books</a> is that they present hard-earned lessons learned from years of experience using a language. The author has spent years falling into traps and digging out of them so that you don&#39;t have to! But this also makes <em>Effective</em> books difficult to write. You can&#39;t just read the documentation on a new feature and write an Item about it. You need to use that feature, make mistakes with it, and eventually learn how to use it well. This takes time.</p><p><a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a> has relatively little to say about &quot;advanced&quot; topics like conditional types. That&#39;s largely because I didn&#39;t have enough practical experience working with them when I wrote the book. That&#39;s changed this year because of work that eventually made its way into the open source <a href="https://github.com/danvk/crosswalk">crosswalk</a> library.</p><p>I found writing the types for crosswalk extremely difficult this spring, but I found it much easier when I reworked it for open source this fall. So I must have learned something! This is the first in a series of posts that will explain some of the tips I&#39;ve picked up along the way. I&#39;ll aim to post one each week for the rest of this month.</p><p>Of course, any discussion of generics and &quot;fancy&quot; types should start with Rule Zero: don&#39;t use them unless you need to! My previous post on the <a href="/2020/08/12/generics-golden-rule/">&quot;Golden Rule of Generics&quot;</a> can help you tell whether this is the case.</p><h2 id="The-problem"><a href="#The-problem" class="headerlink" title="The problem"></a>The problem</h2><p>In <a href="https://github.com/danvk/crosswalk">crosswalk</a>, you define an API using a TypeScript <code>interface</code> that looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">&#x27;/users&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(<code>Endpoint</code> and <code>GetEndpoint</code> are simple type aliases <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6">defined by the library</a>. Their parameters are request and response types.)</p><p>In addition to providing tools to safely implement an API for this schema using <a href="https://expressjs.com/">express</a>, crosswalk also offers a function to construct URLs for API endpoints. This checks a few things: that the endpoints exist, that you specify the proper path parameters, and that they have the correct type (<code>string</code>, not <code>string | null</code>). This is extremely helpful for making safe API calls from the client.</p><p>Here&#39;s how we&#39;d like that function work:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Correct usage:</span><br><span class="hljs-keyword">const</span> url = getUrl&lt;API&gt;(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">// returns &#x27;/users/bob&#x27;</span><br><br><span class="hljs-comment">// Incorrect usage; these should be errors:</span><br>getUrl&lt;API&gt;(<span class="hljs-string">&#x27;/users/:userId/profile&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">// endpoint doesn&#x27;t exist</span><br>getUrl&lt;API&gt;(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">// should be userId, not user</span><br></code></pre></td></tr></table></figure><p>The logic to extract types for the path parameters is fascinating but a bit off-topic. If you&#39;re interested, check out my previous post: <a href="/2020/11/05/template-literal-types/">TypeScript Splits the Atom!</a> For now, let&#39;s assume we have a generic type that does this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Route&gt; = <span class="hljs-comment">/* ... */</span>;<br><span class="hljs-keyword">type</span> Params = ExtractRouteParams&lt;<span class="hljs-string">&#x27;/users/:userId&#x27;</span>&gt;;<br><span class="hljs-comment">// type is &#123;userId: string&#125;</span><br></code></pre></td></tr></table></figure><p>Given that, here&#39;s how you might declare <code>getUrl</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>&lt;</span><br><span class="hljs-function">  <span class="hljs-title">API</span>, <span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">API</span></span><br><span class="hljs-function">&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  path: Path, params: ExtractRouteParams&lt;Path&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>Unfortunately, when you try to use this, you&#39;ll get an unexpected error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API&gt;(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">//     ~~~ Expected 2 type arguments, but got 1. (2558)</span><br></code></pre></td></tr></table></figure><p>The problem is that type inference in TypeScript is <a href="https://github.com/microsoft/TypeScript/issues/10571">all or nothing</a>: either you can let TS infer <em>all</em> the type parameters from usage, or you can specify all of them explicitly. There&#39;s no in between. (There was an <a href="https://github.com/microsoft/TypeScript/pull/26349">attempt</a> to support this in TypeScript 3.1 but it was abandoned.)</p><p>The <code>API</code> parameter is free: it can&#39;t possibly be inferred. So it would seem the only solution here is to write the <code>Path</code> type explicitly:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API, <span class="hljs-string">&#x27;/users/:userId&#x27;</span>&gt;(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>This works, but yuck! Surely there&#39;s a better way. We need to somehow separate the place where we write the type parameter (<code>API</code>) from the place where we infer it.</p><h2 id="Solution-1-Classes"><a href="#Solution-1-Classes" class="headerlink" title="Solution 1: Classes"></a>Solution 1: Classes</h2><p>TypeScript has one very familiar tool to introduce a new inference site: classes.</p><p>Here&#39;s how you can use a class to solve this problem:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">URLMaker</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  getUrl&lt;<br>    Path <span class="hljs-keyword">extends</span> keyof API<br>  &gt;(<br>    path: Path,<br>    params: ExtractRouteParams&lt;Path&gt;<br>  ): <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>And here&#39;s how you use it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> urlMaker = <span class="hljs-keyword">new</span> URLMaker&lt;API&gt;();<br>urlMaker.getUrl(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><br>urlMaker.getUrl(<span class="hljs-string">&#x27;/users/:userId/profile&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">//              ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">//  &#x27;&quot;/users/:userId/profile&quot;&#x27; is not assignable to &#x27;&quot;/users/:userId&quot; | &quot;/users&quot;&#x27;</span><br>urlMaker.getUrl(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">//                                 ~~~~~~~~~~~</span><br><span class="hljs-comment">//  &#x27;&#123; user: string; &#125;&#x27; is not assignable to &#x27;&#123; userId: string; &#125;&#x27;.</span><br></code></pre></td></tr></table></figure><p>This produces exactly the errors we were hoping for. Hurray!</p><p>What used to be a function that needed two generic type parameters is now a class with one generic type (that you specify explicitly) and a method with one generic type (that&#39;s inferred). TypeScript is perfectly happy to let you bind the <code>API</code> parameter when you call the class&#39;s constructor (<code>new URLMaker&lt;API&gt;()</code>) and then bind <code>Path</code> when you call the <code>getUrl</code> method.</p><p>Using classes to create a distinct binding site is particularly effective when you have multiple methods that all require the same generic parameter. Check out crosswalk&#39;s <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L71-L100"><code>typed-router.ts</code></a> for an example of this.</p><h2 id="Solution-2-Currying"><a href="#Solution-2-Currying" class="headerlink" title="Solution 2: Currying"></a>Solution 2: Currying</h2><p>Fun fact: programming languages don&#39;t really need functions that take more than one parameter. Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params">mon: <span class="hljs-built_in">string</span>, day: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">Date</span></span>;<br>getDate(<span class="hljs-string">&#x27;dec&#x27;</span>, <span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>You could instead write a function that returns a function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getDate</span>(<span class="hljs-params">mon: <span class="hljs-built_in">string</span></span>): (<span class="hljs-params">day: <span class="hljs-built_in">number</span></span>) =&gt; <span class="hljs-title">Date</span></span>;<br>getDate(<span class="hljs-string">&#x27;dec&#x27;</span>)(<span class="hljs-number">25</span>);<br></code></pre></td></tr></table></figure><p>Note the slightly different syntax to call the second version. This practice is known as <a href="https://wiki.haskell.org/Currying">currying</a>, after <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Curry</a>, who always disavowed having come up with the technique.</p><p>Currying gives us the flexibility we need to introduce as many inference sites as we like. Each function can infer new generic parameters.</p><p>Here&#39;s how you can rework <code>getUrl</code> using functions that return functions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUrl</span>&lt;<span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span>):</span><br><span class="hljs-function">  &lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    path: Path,</span></span><br><span class="hljs-function"><span class="hljs-params">    params: ExtractRouteParams&lt;Path&gt;</span></span><br><span class="hljs-function"><span class="hljs-params">  </span>) =&gt; <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>Now <code>getUrl</code> takes <em>no</em> parameters, but it returns a function that takes two. Here&#39;s how you use it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">getUrl&lt;API&gt;()(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);  <span class="hljs-comment">// ok</span><br><br>getUrl&lt;API&gt;()(<span class="hljs-string">&#x27;/users/:userId/profile&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">//            ~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">//  &#x27;&quot;/users/:userId/profile&quot;&#x27; is not assignable to &#x27;&quot;/users/:userId&quot; | &quot;/users&quot;&#x27;</span><br>getUrl&lt;API&gt;()(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">user</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);<br><span class="hljs-comment">//                               ~~~~~~~~~~~</span><br><span class="hljs-comment">//  &#x27;&#123; user: string; &#125;&#x27; is not assignable to &#x27;&#123; userId: string; &#125;&#x27;.</span><br></code></pre></td></tr></table></figure><p>So this works in the case where we want it to and fails in the others. Perfect!</p><p>For other examples of using currying with generics, check out my posts on building a <a href="/2020/07/27/safe-queryselector/">type-safe query selector</a> and <a href="/2020/06/16/typed-identity-functions/">using typed identity functions to guide inference</a>.</p><p>This isn&#39;t as distinct from the class approach as it might initially appear. If you use a different name and return an object type instead of a function, they look nearly identical:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">urlMaker</span>&lt;<span class="hljs-title">API</span>&gt;(<span class="hljs-params"></span>): </span>&#123;<br>  getUrl&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path, <span class="hljs-attr">params</span>: ExtractRouteParams&lt;Path&gt;<br>  ): <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> maker = urlMaker&lt;API&gt;();<br>maker.getUrl(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, &#123;<span class="hljs-attr">userId</span>: <span class="hljs-string">&#x27;bob&#x27;</span>&#125;);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>The only difference between this and the class exmaple is the keyword <code>new</code>.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>If you want to specify some generic parameters explicitly while allowing others to be inferred, classes and currying are your two options.</p><p>So which one should you prefer? Ultimately it&#39;s up to you! Whichever one feels most comfortable and produces the API you find most convenient is the way to go.</p><p>The currying approach does have at least one advantage in the context of TypeScript, however, which we&#39;ll discuss in next week&#39;s tip. Stay tuned!</p><p>As always, here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBASwHY2FAZgQwMbDgUSQBNJkYAeAJWAEcBXYAZxgBo5rHIlHgA+OAN4AoOKLhRaDZgC52kpjADcIsRM4RuwWRy49lAXyFDQkWHBgBPMHgDiwGIRIQyVJrr5wAvAWKkU5JDoAGyC2HQ0eXmUhS2s4AFUeKC9BcystOAByOiTMxTh9ZVi8RLRGcM0UgTgcstlSqABtAF18wpj0uABhCUxUBup6BSq4JEwAWwzmKGQAczaizviwIj7gBpGxyYB+WWm5guiAeiO4AGVgPAALGBgwRmkT2YQYK7oAIwA6bAhxo9WkAA3ADWR2wUAgjEYAHdMEFgcZwNB4GQ0FhcHAAIIABQAkoIVKJMkdalBGJlZMIxNS4LN7LI7A5fM5-A1ym4InxlDSxJAZD4nC4esA1gN5Mw2A0ooTDjLiaTGEdpKTcUQKQSeaI6TAGfZHH4KFLuZqwHQdQKDeRlqt+klJUlpdTDIYhCdzpc4Dc7o8jkEINg4VdITqACwABgjRwATGGY0cAIzxo5hgCsR1Q4zAQTWAFogi80HCc8VFYjTPBigQQDAoDgYJQIGbgNjMLXxoxyAAVfjefZIWZwUCoYiMOCdmXbOQ-KBEch92Zsee8GWyTuD6vAEdwAAGABIBMh0Gg4AB9M4wVswfTSfeH48ttv6I63pBH5IcK-biepRrAxBIOAHwmOAAB84GBYALAgdAqxrOsGybID21cZheGaPYawOQxqVXddhyIUc9wPV9jzPC9YGvF830A1sJn0L9qUnapf3-Gi23QuB5wKFdBHaV1TjOCAgjNBANDgeNZC6bMoSMIhgGwbMJDgBTMChBJKAAGQAWUwCCoHIHFcX4KkxG1eIoCCcgZWpFtXjwzcCPAyDoKxPEZV4AAKazeT6K5ZFsq4WG80QwFo9tZHwata2wetG1QJCOwC5dqQASgwmZ+wMIwfm4eA6AsnS9JSJBgGhdTtN0tADLxTyUuUfKgkKtBPjMiyPPlJJFWVJJVUyNhqhVIhZEyd4IHeTICjqowGqaqAWvscygnaklOqVQajjACF0AQIJgD61JBuG0bxsm5Q3U1HkAD9rpu267vum7+KJAAiFayjWnqiA2raduAZ6JoQUckAgeBVMYBBZjGd5dvMCAslehUPrQVVntAuAEc6-6hBmyq5tapaOve7rkbVfqaiSI6xom-QpvOi76YZ6kHtup6sgGinOMwzKCgBoGQbgMGIahmGYDhzJ2ZJ9K5jaTJPiMJ7BOEmBRIAqNJPyqALDmWT5MUvB0DoJAYpV2kFos6qjI8tKVHIAL7K3CCoJgwzPJlULXn83ygupUK2weWDotixCwsS3zkrgFKvH4edonxi3auWxHiagXr+sOrJjsyGn8jgN0IARIQ45dq3E9W5PVW+6Dfv2gR05Gqns9ZhnmZbh7WcyDGifWzaq92-7ED50GoSFzBobwUX4beskkZTohUbAzuySxouapLwnp-L0nBFJSnxsbunGcPmlW8u9uJagKXuf0XnRn5wXIdHkWxfP1VL-mHm5aAA">playground</a> with complete examples from this post.</p>]]></content>
    
    <summary type="html">
    
      This series will present a few tips and tricks for working with TypeScript generics that I&#39;ve picked up over the past year. This post looks at how you can use classes and currying to combine explicit type parameters and type inference.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Splits the Atom!</title>
    <link href="https://effectivetypescript.com/2020/11/05/template-literal-types/"/>
    <id>https://effectivetypescript.com/2020/11/05/template-literal-types/</id>
    <published>2020-11-05T05:00:00.000Z</published>
    <updated>2022-02-24T14:24:56.797Z</updated>
    
    <content type="html"><![CDATA[<img src="https://effectivetypescript.com/images/split-atom.png" width="324" height="298" alt="Splitting a string type" style="max-height: 100%; float: right"><p>TypeScript&#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming <a href="https://github.com/microsoft/TypeScript/issues/40124">TypeScript 4.1 release</a> includes a particularly exciting new <a href="https://github.com/microsoft/TypeScript/pull/40336">addition</a> to the type system: <em>template literal types</em>.</p><p>Template literal types solve a <a href="https://github.com/microsoft/TypeScript/issues/12754">long-standing gap</a> in TypeScript&#39;s type system and, as I&#39;ll argue at the end of the post, they solve it in a particularly <em>TypeScripty</em> way.</p><p>To understand template literal types, let&#39;s start with a seemingly simple question: what can&#39;t you type?</p><span id="more"></span><h2 id="The-limits-of-type-safety-in-TypeScript"><a href="#The-limits-of-type-safety-in-TypeScript" class="headerlink" title="The limits of type safety in TypeScript"></a>The limits of type safety in TypeScript</h2><p>My standard example of a pattern you <em>couldn&#39;t</em> type has always been the <code>camelCase</code> function, which maps something like <code>&quot;foo_bar&quot;</code>  <code>&quot;fooBar&quot;</code>. It&#39;s easy to implement in JavaScript using a regular expression:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> term.replace(<span class="hljs-regexp">/_([a-z])/g</span>, <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">1</span>].toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure><p>This function is trivial to <em>simply</em> type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure><p>So that&#39;s not quite what I&#39;m getting at. Ideally you&#39;d like to be able to use this to convert objects with <code>snake_cased</code> properties (like you&#39;d get from a database) into one with <code>camelCased</code> properties (like you typically use in JS/TS). In other words, what should the return type of this function be to make the following code type check (or not) as you&#39;d expect?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out: <span class="hljs-built_in">any</span> = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>    out[camelCase(k)] = v;<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;<span class="hljs-attr">foo_bar</span>: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// camel&#x27;s value at runtime is &#123;fooBar: 12&#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type of val is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;  <span class="hljs-comment">// should be a type error</span><br></code></pre></td></tr></table></figure><p>Prior to TypeScript 4.1 (now a release candidate) this just wasn&#39;t possible. The reason was that string literal types like <code>&quot;foo_bar&quot;</code> were &quot;atomic&quot; in the sense that you couldn&#39;t observe any structure inside of them. They were indivisible. But clearly there <em>is</em> structure in strings. Just look at <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Instance_methods">all the methods</a> on <code>String.prototype</code>.</p><p>Enter: TypeScript 4.1!</p><h2 id="TypeScript-splits-the-atom"><a href="#TypeScript-splits-the-atom" class="headerlink" title="TypeScript splits the atom"></a>TypeScript splits the atom</h2><p>TypeScript 4.1 introduce a few features that make it possible to precisely type the <code>objectToCamel</code> function:</p><ol><li><em>Template literal types</em> This is the key advance. Template literal types allow you to find structure inside string literal types and create infinite, strict subsets of <code>string</code> (think &quot;strings starting with <code>on</code>&quot;).</li><li><em>Key Remapping in Mapped Types</em> While it was possible to change the keys in an object before using tricks like <a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a>, this new feature makes it much more straightforward.</li></ol><p>Let&#39;s use these two features to implement <code>objectToCamel</code>.</p><p>First, let&#39;s look at template literal types. They look like ES template literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OnString = <span class="hljs-string">`on<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> onClick: OnString = <span class="hljs-string">&#x27;onClick&#x27;</span>;<br><span class="hljs-keyword">const</span> handleClick: OnString = <span class="hljs-string">&#x27;handleClick&#x27;</span>;<br>   <span class="hljs-comment">// ~~~~~~~~~~~ Type &#x27;&quot;handleClick&quot;&#x27; is not assignable to type &#x27;`on$&#123;string&#125;`&#x27;.</span><br></code></pre></td></tr></table></figure><p>This lets you create a type for &quot;strings starting with <code>on</code>.&quot; Before TypeScript 4.1, you either had <code>string</code> or an enumerated union of string literal types (<code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code>). Now you can define structured subsets of <code>string</code>.</p><p>Here are a few other patterns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdNum = <span class="hljs-string">`id<span class="hljs-subst">$&#123;<span class="hljs-built_in">number</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> id1: IdNum = <span class="hljs-string">&#x27;id123&#x27;</span>;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> id2: IdNum = <span class="hljs-string">&#x27;idABC&#x27;</span>;<br>   <span class="hljs-comment">// ~~~ Type &#x27;idABC&#x27; is not assignable to IdNum</span><br><br><span class="hljs-keyword">type</span> Digit = <span class="hljs-string">&#x27;0&#x27;</span> | <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span> | <span class="hljs-string">&#x27;3&#x27;</span> | <span class="hljs-string">&#x27;4&#x27;</span> |<br>             <span class="hljs-string">&#x27;5&#x27;</span> | <span class="hljs-string">&#x27;6&#x27;</span> | <span class="hljs-string">&#x27;7&#x27;</span> | <span class="hljs-string">&#x27;8&#x27;</span> | <span class="hljs-string">&#x27;9&#x27;</span>;<br><span class="hljs-keyword">type</span> ThreeDigitNum = <span class="hljs-string">`<span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span>`</span>;<br></code></pre></td></tr></table></figure><p>What makes this really powerful is that you can use the <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/"><code>infer</code> keyword</a> in a template literal type to do pattern matching:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel1&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;Tail&gt;&#125;</span>`</span><br>    : S;<br><br><span class="hljs-keyword">type</span> T = ToCamel1&lt;<span class="hljs-string">&#x27;foo_bar&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar&quot; (!!!)</span><br></code></pre></td></tr></table></figure><p>The conditional matches string literal types of the form <code>&quot;head_tail&quot;</code>. The &quot;<code>_</code>&quot; acts as a delimiter to split the string. Because <a href="https://mariusschulz.com/blog/conditional-types-in-typescript#distributive-conditional-types">conditional types distribute over unions</a>, this also works for union types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> TU = ToCamel1&lt;<span class="hljs-string">&#x27;first_name&#x27;</span> | <span class="hljs-string">&#x27;last_name&#x27;</span>&gt;;<br><span class="hljs-comment">// type is &quot;firstName&quot; | &quot;lastName&quot;</span><br></code></pre></td></tr></table></figure><p>There&#39;s a big issue, though. What if there&#39;s two <code>_</code>s in the string literal type?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T2 = ToCamel1&lt;<span class="hljs-string">&#x27;foo_bar_baz&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar_baz&quot;</span><br></code></pre></td></tr></table></figure><p>We can&#39;t stop after the first &quot;<code>_</code>&quot;, we need to keep going. We can do this by making the type recursive:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;ToCamel&lt;Tail&gt;&gt;&#125;</span>`</span><br>    : S;<br><span class="hljs-keyword">type</span> T0 = ToCamel&lt;<span class="hljs-string">&#x27;foo&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;foo&quot;</span><br><span class="hljs-keyword">type</span> T1 = ToCamel&lt;<span class="hljs-string">&#x27;foo_bar&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar&quot;</span><br><span class="hljs-keyword">type</span> T2 = ToCamel&lt;<span class="hljs-string">&#x27;foo_bar_baz&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBarBaz&quot;</span><br></code></pre></td></tr></table></figure><p>The recursive bit is where we call <code>ToCamel&lt;Tail&gt;</code>.</p><p>Pretty neat! Now let&#39;s put it all together.</p><h2 id="A-typed-objectToCamel"><a href="#A-typed-objectToCamel" class="headerlink" title="A typed objectToCamel"></a>A typed objectToCamel</h2><p>Recall that a <a href="https://medium.com/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8">mapped type</a> in TypeScript looks and works something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Promisify&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">Promise</span>&lt;T[K]&gt;  <span class="hljs-comment">// &lt;-- the mapping</span><br>&#125;;<br><span class="hljs-keyword">type</span> VectorPromise = Promisify&lt;Vector&gt;;<br><span class="hljs-comment">// type is &#123; x: Promise&lt;number&gt;; y: Promise&lt;number&gt;; &#125;</span><br></code></pre></td></tr></table></figure><p>The <code>keyof T</code> here produces a union of string literal types (<code>&quot;x&quot; | &quot;y&quot;</code>) and the mapped type produces an object type from this given a way to produce the values (the <code>Promise&lt;T[K]&gt;</code>). But the keys are set by the union. You can&#39;t change them.</p><p>With Key Remapping, you can add an <code>as</code> clause to the key in a mapped type to change things around. This works particularly well with template literal types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Evented&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;K &amp; <span class="hljs-built_in">string</span>&#125;</span>Changed`</span>]: <span class="hljs-function">(<span class="hljs-params">val: T[K]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">type</span> StudentEvents = Evented&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   nameChanged: (val: string) =&gt; void;</span><br><span class="hljs-comment">//   ageChanged: (val: number) =&gt; void;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>(The <code>&amp; string</code> is there for technical reasons that I don&#39;t want to get into.)</p><p>Using this, we can plug in our <code>ToCamel</code> generic to put it all together:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ObjectToCamel&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> ToCamel&lt;K&gt;]: T[K]<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">ObjectToCamel</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ... as before ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;<span class="hljs-attr">foo_bar</span>: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// type is &#123; fooBar: number &#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;<br>                <span class="hljs-comment">// ~~~~~~~ Property &#x27;foo_bar&#x27; does not exist on type</span><br>                <span class="hljs-comment">//         &#x27;&#123; fooBar: number; &#125;&#x27;. Did you mean &#x27;fooBar&#x27;?</span><br></code></pre></td></tr></table></figure><p>Here&#39;s a <a href="https://www.typescriptlang.org/play?ts=4.2.0-dev.20201109#code/C4TwDgpgBAKg9gYQIYFsIBsA8BlKEAewEAdgCYDOU5wATgJbEDmAfFALwBQU3UuBRZSgAMAJAG8GAMwg0oACQhJSAXwD64qTNhI66ZUK48A-FFFiFS5eORg6wJOjoAvCJnjI0WGDvTNm+w24ALl4Abg5QSFgABnZYRFQMTABySTg4ZOZQ7gB6HKhI6DpKACI0uBKI8GgYAEY490SsVPTVACMkGkzsqDyC6qhiqDL0gCFOysLYACYGhM8U8vbO5adu3PypoZG4cZpxp0qOSQBXYgBjYDo4YihzpuRyVxg8QhIKKloGFgAKIhoUCEYABKIHzJIwVhiQw0CDAE40W7-FAAOlhYHQSHOEB+OVUPwA2kgALROAC6wJyjAANFAUOxWCgCbUySjgHAAKpgSA0R444HAqBISiNBaQ8LKDhVKIAeTaACsIJdRRDXgIPnAFUrgKw2FBodwCQBpQa3ADWEBAcEksCFIvBWBNADJPvQmMwyUDjWSOMpwsczpdrrdNYrlQ63Gr3pRQ9rmD9Q0DQVA5WHgCqvFDDOcbtQoHATsAQkhiCA4mI-YY0rIfjniHmCWbaQA3Mn5m2p7UokhfCDkBMKgX6wL5wsE+6ePk-M3Att65vhbiS7iw+GI0fACVSut5sDC+7octLDo0EK1aZ+3qbAZDMTHzohYgnFBtGSSnfAO5NOKx8MeDA-Hu5AHsC4R9FslBiFA5R7I+z6vrI765p+zYOHEE4YCiMGdD04E3pQT4vjIHAflAqHoLMeoYegWGtCei48IxTE8H0AB+7EcaxUAAAo0HAPKgFALRwMsXRQKQcB9lAxBwJ+BDFJ+Nz9JAI7McxfRqUJUHYae0nwTI2TKMkKJQAAInQpBQFaJx0ootzCXsyRGBwQA">complete playground</a>.</p><h2 id="What-can-should-you-do-with-template-literal-types"><a href="#What-can-should-you-do-with-template-literal-types" class="headerlink" title="What can should you do with template literal types?"></a>What <del>can</del> should you do with template literal types?</h2><p>After template literal types landed, the TypeScript Twittersphere went crazy. I shared a use case around <a href="https://expressjs.com/en/guide/routing.html">express</a>, which quickly became the most popular tweet I&#39;ve ever posted:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">Another use of <a href="https://twitter.com/typescript?ref_src=twsrc%5Etfw">@TypeScript</a> 4.1&#39;s template literal types: extracting the URL parameters from an express route. Pretty amazing you can do this in the type system! <a href="https://t.co/gfZQy70whg">https://t.co/gfZQy70whg</a> <a href="https://t.co/aEyfMwjjqX">pic.twitter.com/aEyfMwjjqX</a></p>&mdash; Dan Vanderkam (@danvdk) <a href="https://twitter.com/danvdk/status/1301707026507198464?ref_src=twsrc%5Etfw">September 4, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>A <a href="https://twitter.com/buildsghost/status/1301976526603206657">JSON parser</a> made the rounds and then someone <a href="https://github.com/codemix/ts-sql">implemented a full SQL engine</a> in the type system. Hacker news <a href="https://news.ycombinator.com/item?id=24615185">was impressed</a>.</p><p>As with any new tool, it will take some time for the community to figure out the best ways to use it. Here are a few ideas. We&#39;ll see how they pan out!</p><ul><li><p>Dotted access: <strong>easy win</strong></p><p>Lodash allows you to write <a href="https://stackoverflow.com/a/43395675/388951">&quot;iteratee&quot; expressions</a> like <code>xs.map(&#39;a.b.c&#39;)</code>, which is roughly the same as <code>xs.map(x =&gt; x.a.b.c)</code>. Template literal types will make it possible for this sort of API to be typed.</p><p>I&#39;ve never been a big fan of this style. I&#39;d prefer to write <code>x =&gt; x.a.b.c</code>. But perhaps some of this is just bias from not being able to type these properly in the past. Using string literals for enums, for example, is frowned upon in Java as unsafe, <a href="https://cocoacasts.com/the-danger-of-string-literals-and-stringly-typed-code">stringly typed</a>, code. But it turns out to be fine in TypeScript because the type system is rich enough to capture it. So we&#39;ll see!</p></li><li><p>Parsing routes: <strong>huge win!</strong></p><p>See my <code>ExtractRouteParams</code> tweet above. Parsing <code>&#123;userId: string&#125;</code> out of <code>/users/:userId</code> will be a big win for express users.</p><p>Going the other direction is also compelling. In a server I use at work, we issue API calls via something like <code>get(&#39;/users/:userId&#39;, &#123;userId: &#39;id&#39;&#125;)</code>. We have types defined for the parameters for each route. But now we can just let TypeScript infer them to ensure that nothing will ever get out of sync.</p><p>Similar considerations apply to routes with <a href="https://reactrouter.com/web/example/url-params">react-router</a>.</p></li><li><p>Better types for <code>querySelector</code> / <code>querySelectorAll</code>: <strong>nice win</strong></p><p>The <a href="https://github.com/microsoft/TypeScript/blob/b5b0437a86661c8d7bc76c5860c07305df17899c/lib/lib.dom.d.ts#L11341-L11349">DOM typings</a> are clever enough to infer a subtype of <code>Element</code> here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.queryQuerySelector(<span class="hljs-string">&#x27;input&#x27;</span>);<br><span class="hljs-comment">// Type is HTMLInputElement | null</span><br></code></pre></td></tr></table></figure><p>But once you add anything more complex to the selector, you lose this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.queryQuerySelector(<span class="hljs-string">&#x27;input.my-class&#x27;</span>);<br><span class="hljs-comment">// Type is Element | null</span><br></code></pre></td></tr></table></figure><p>With template literal types, it will be possible to fix this. I wouldn&#39;t be surprised if it becomes common practice to replace calls to <code>getElementById</code> with equivalent calls to <code>querySelector</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> el1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-comment">// type is Element | null</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div#foo&#x27;</span>);<br><span class="hljs-comment">// type is HTMLDivElement | null</span><br></code></pre></td></tr></table></figure><p>This will no doubt require me to rewrite Item 55 of <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a> (&quot;Understand the DOM hierarchy&quot;). Oh well!</p></li><li><p>Parsing options in <a href="https://www.npmjs.com/package/commander">Commander</a> or <a href="https://github.com/docopt/docopt.coffee">docopt</a>: <strong>a small win</strong></p><p>With <a href="https://www.npmjs.com/package/commander">Commander</a>, you define your command line tool&#39;s arguments using something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">program<br>  .option(<span class="hljs-string">&#x27;-d, --debug&#x27;</span>, <span class="hljs-string">&#x27;output extra debugging&#x27;</span>)<br>  .option(<span class="hljs-string">&#x27;-s, --small&#x27;</span>, <span class="hljs-string">&#x27;small pizza size&#x27;</span>)<br>program.parse(process.argv);<br><span class="hljs-built_in">console</span>.log(program.debug, program.small);<br></code></pre></td></tr></table></figure><p>Setting aside the mutation style, which is hard to model in TypeScript, template literal types should make it possible to extract the parameter names from the calls to <code>.option</code>.</p></li><li><p>Parsing SQL or GraphQL: <strong>I could go either way!</strong></p><p>The <a href="https://github.com/codemix/ts-sql">ts-sql</a> demo <a href="https://news.ycombinator.com/item?id=24615185">raised some eyebrows</a>, but it also made a real point about the power of template literal types. Given a TypeScript version of your database schema (which can be generated using <a href="https://github.com/PSYT/schemats">schemats</a> or <a href="https://github.com/danvk/schemats">pg-to-ts</a>), it should be possible to infer result types for a SQL query:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;Schema&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudentsByAge</span>(<span class="hljs-params">db: Pool, age: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> db.query&lt;Schema&gt;(<span class="hljs-string">`</span><br><span class="hljs-string">  SELECT first_name, last_name FROM students</span><br><span class="hljs-string">  WHERE age = $1;</span><br><span class="hljs-string">  `</span>, [age]);  <span class="hljs-comment">// checks that type of age is number</span><br>  <span class="hljs-keyword">return</span> result.rows;<br>  <span class="hljs-comment">// type is &#123;first_name: string, last_name: string&#125;[]</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This seems potentially amazing, but also perhaps brittle. You&#39;d have to work in the subset of SQL that your types understood: presumably you wouldn&#39;t want to implement all of <a href="https://en.wikipedia.org/wiki/PL/pgSQL">PL/pgSQL</a> in the type system. But I could imagine getting a large class of queries, including joins, to work.</p><p>So I&#39;m on the fence on this one! Similar considerations apply to GraphQL queries, which would be a bit easier to join with a schema in the type system than raw SQL.</p></li></ul><p>Template literal types open up many new doors for TypeScript library authors and should improve the overall experience of using TypeScript for everyone by capturing more JavaScript patterns in the type system.</p><p>I&#39;d like to conclude by pointing out that this is a very <em>TypeScripty</em> solution to this problem. TypeScript is full of &quot;puns&quot; between value and type syntax. Depending on the context, <code>&quot;foo&quot;</code> could either be the literal value <code>&quot;foo&quot;</code> or a type consisting of the single value <code>&quot;foo&quot;</code>. (I explore this in Item 8 of <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a>, &quot;Know How to Tell Whether a Symbol Is in the Type Space or Value Space&quot;). Another famous example is <a href="https://basarat.gitbook.io/typescript/type-system/index-signatures">index types</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">12</span>&#125;;<br><span class="hljs-keyword">const</span> value = obj[<span class="hljs-string">&#x27;x&#x27;</span>];  <span class="hljs-comment">// JS index operator, value at runtime is 12.</span><br><span class="hljs-keyword">type</span> T = (<span class="hljs-keyword">typeof</span> obj)[<span class="hljs-string">&#x27;x&#x27;</span>];  <span class="hljs-comment">// TS index operator, type is number.</span><br></code></pre></td></tr></table></figure><p>Template literal types continue this pattern by repurposing a runtime JavaScript syntax (template strings) into something that makes sense in the type system (template literal types). The <code>concat</code> function really hammers this home:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concat</span>&lt;<span class="hljs-title">A</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>&gt;(<span class="hljs-params">a: A, b: B</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span><span class="hljs-subst">$&#123;B&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>On the return line, <code>`$&#123;a&#125;$&#123;b&#125;`</code> is the runtime JavaScript template literal and <code>`$&#123;A&#125;$&#123;B&#125;`</code> is the TypeScript type. It&#39;s not an accident that they look identical!</p><p>I never would have thought to do it this way, but kudos to Anders and the TypeScript team for coming up with such an on-brand solution!</p><p><em>Image credit: modified version of <a href="https://commons.wikimedia.org/wiki/File:Nuclear_fission_chain_reaction.svg">File:Nuclear fission chain reaction.svg</a> from Wiki Commons</em></p><!--Good use cases for template literal types:- Parsing express routes (my tweet)  - Also react-router routes- Type-safe lodash accessors ('a.b.c')- Better type inference for querySelector- Parsing options in CommanderOnes I'm less sure of:- Parsing SQL to infer result typesreach deep into domainsThis is a very TypeScript-y solution to the problem.link to the awesome list somewhere-->]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;https://effectivetypescript.com/images/split-atom.png&quot; width=&quot;324&quot; height=&quot;298&quot; alt=&quot;Splitting a string type&quot; style=&quot;max-height: 100%; float: right&quot;&gt;

&lt;p&gt;TypeScript&amp;#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/40124&quot;&gt;TypeScript 4.1 release&lt;/a&gt; includes a particularly exciting new &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/40336&quot;&gt;addition&lt;/a&gt; to the type system: &lt;em&gt;template literal types&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Template literal types solve a &lt;a href=&quot;https://github.com/microsoft/TypeScript/issues/12754&quot;&gt;long-standing gap&lt;/a&gt; in TypeScript&amp;#39;s type system and, as I&amp;#39;ll argue at the end of the post, they solve it in a particularly &lt;em&gt;TypeScripty&lt;/em&gt; way.&lt;/p&gt;
&lt;p&gt;To understand template literal types, let&amp;#39;s start with a seemingly simple question: what can&amp;#39;t you type?&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Finding dead code (and dead types) in TypeScript</title>
    <link href="https://effectivetypescript.com/2020/10/20/tsprune/"/>
    <id>https://effectivetypescript.com/2020/10/20/tsprune/</id>
    <published>2020-10-20T22:20:56.000Z</published>
    <updated>2020-11-11T15:15:19.922Z</updated>
    
    <content type="html"><![CDATA[<p>Software engineering is a battle against complexity. Without any planning or care, it&#39;s easy to build programs where everything interacts with everything else (the &quot;big ball of yarn&quot; model). With a ball of yarn, if you double the number of components, you quadruple the number of interactions:</p><img src="https://effectivetypescript.com/images/quadratic.png" alt="Complexity increases with the number of interactions, i.e. quadratically" width="439" height="262"><p>One of the best ways to fight against this ramp-up of complexity is to simply reduce N, i.e. to write fewer lines of code. Using a higher level programming language or depending on well-tested third-party libraries are common ways to do this. But one of the easiest ways is to find code you don&#39;t need any more and delete it.</p><a id="more"></a><p>Or, to quote <a href="https://en.wikipedia.org/wiki/Ken_Thompson" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Ken_Thompson', event);">Ken Thompson</a>:</p><blockquote><p>One of my most productive days was throwing away 1000 lines of code.</p></blockquote><p>So how do you find dead code (and dead types) in a TypeScript project? There are a few ways to do it, but my current solution involves the <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/compiler-options.html', event);"><code>--noUnusedLocals</code></a> compiler option and the <a href="https://github.com/nadeesha/ts-prune" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune', event);">ts-prune</a> tool from <a href="https://nadeeshacabral.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://nadeeshacabral.com/', event);">Nadeesha Cabral</a>.</p><h3 id="noUnusedLocals"><a href="#noUnusedLocals" class="headerlink" title="noUnusedLocals"></a>noUnusedLocals</h3><p>First, <code>--noUnusedLocals</code>. This is typically set this in your <code>tsconfig.json</code> file. It&#39;s on by default so its behavior should be familiar. In addition to detecting unused local variables in function bodies, it also detects unused symbols at the module level:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>      <span class="hljs-comment">// ~~~ 'foo' is declared but its value is never read.</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>(In VS Code, unused symbols typically appear in a lighter color instead of getting the red squiggly underline error treatment. This is because it&#39;s often only a temporary state until you write the code that uses the symbol.)</p><p>In this example nothing calls <code>foo</code> or otherwise references it, so it&#39;s dead code. And while <code>bar</code> is unused in this module, it&#39;s exported, so there&#39;s at least the possibility that another module could import it and call it.</p><p>Since imported symbols are local variables inside their module, <code>noUnusedLocals</code> will also catch unused imports for you.</p><h3 id="ts-prune"><a href="#ts-prune" class="headerlink" title="ts-prune"></a>ts-prune</h3><p>But what about exported symbols? They&#39;re still dead code if they&#39;re unused, but determining whether that&#39;s the case is harder. It requires analysis of your whole program and it&#39;s a little trickier than you might expect at first blush. To see why, let&#39;s first look at an incorrect way to do it.</p><p>What if we just look at all the <code>import</code>s in a program and pair them up with the <code>export</code>s? With this approach, an <code>export</code>ed symbol is unused if it&#39;s never <code>import</code>ed.</p><p>There are several problems with this approach. Here are a few:</p><ol><li>Code can be <code>import</code>ed but still dead. Here are three ways this can happen:<ol><li>A function is only imported by its test.</li><li>Two functions call each other (mutual recursion), but are otherwise unused.</li><li>A function is only used by other dead code.</li></ol></li><li>An <code>export</code>ed symbol can be alive even if it&#39;s never <code>import</code>ed. This happens if it&#39;s used in its own module.</li></ol><p>This is all a little easier to understand in picture form:</p><img src="https://effectivetypescript.com/images/dead-code-depgraph.png" alt="Dependency graph showing dead code" width="678" height="353" style="max-height: 100%"><p><em>Dead code is in gray, live code is bold. Code can be dead despite being referenced. Examples are if it&#39;s referenced from other dead code (<code>recA</code>/<code>recB</code>), or code that is not relevant for &quot;liveness&quot; like a test (<code>deadA</code>).</em></p><p>I&#39;m saying &quot;functions&quot; here, but the same considerations apply to types and interfaces, too.</p><p>The first category of problems (imported but still dead) is reminiscent of a problem in <a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)', event);">garbage collection</a>: if you do pure <a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Reference_counting', event);">reference counting</a>, then you have a problem with cycles, where two objects reference each other but are otherwise dead. The solution there is to start with some known &quot;live&quot; objects and follow all the references from them. This is known as <a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Tracing_garbage_collection#Na%C3%AFve_mark-and-sweep', event);">mark and sweep</a>.</p><p>We can do something similar with ts-prune. To get the most value out of it, you create a special <code>tsconfig.json</code> file with a list of entrypoints to your program:</p><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">"files"</span>: [<br>    <span class="hljs-string">"src/entry1.ts"</span>,<br>    <span class="hljs-string">"src/entry2.ts"</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>I usually call this <code>tsconfig.ts-prune.json</code>. What constitutes an entrypoint depends on your program. For a Node program like a server, it&#39;s the file you run (perhaps <code>server.ts</code> or <code>main.ts</code> or <code>app.ts</code>). For a web application, it&#39;s the entrypoint you list in your webpack or equivalent config. For a library, it&#39;s any file you want your users to be able to import from the resulting distribution (typically <code>index.ts</code> / <code>index.js</code>).</p><p>Once you&#39;ve created that file, you run something like this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ ts-prune -p tsconfig.ts-prune.json | grep -v &#39;used in module&#39;<br>src&#x2F;example.ts:4 - bar<br></code></pre></td></tr></table></figure><p>The <code>-p</code> points <code>ts-prune</code> at your special <code>tsconfig.json</code>. Since you never <code>import</code> tests, they wind up being ignored for purposes of detecting alive vs. dead code. The same goes for un-<code>import</code>ed modules.</p><p>The <code>grep</code> filters out the second category of problems from the above list. I have no problem exporting symbols that are never imported (in fact, I recommend it in Item 47 <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a>: Export All Types That Appear in Public APIs).</p><p><em>(Sidebar: why? Two main reasons. First, you often wind up needing to import them later, and exporting them makes it possible for tsserver to offer auto-import. Second, you&#39;re effectively exporting them already if they&#39;re part of a public API. You may as well make it easy.)</em></p><p>The output of ts-prune tells us that the <code>bar</code> symbol is unused despite being exported. This is exactly what we wanted to know!</p><p>I highly recommend setting up ts-prune for your project. You might find some dead code that you&#39;d forgotten about! It also works great with more exotic setups like media imports and generated code. Two examples of this from my own projects:</p><ol><li>My team has a file, <code>icons.ts</code>, that imports all the images in my web app, either from PNGs in my project or from Material-UI, and re-exports them. In this case running ts-prune finds the unused images, which shrinks your bundle! (Tree shaking would help here, too.)</li><li>We use codegen to <a href="https://github.com/danvk/schemats" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/schemats', event);">produce TypeScript types from our Postgres schema</a>. In this case an unused export may correspond to a dead <em>database table</em>, which should definitely be dropped!</li></ol><p>As with most dead code elimination tool, when you delete some dead code that it&#39;s surfaced, you should immediately run <code>tsc</code> and <code>ts-prune</code> again. Running <code>tsc</code> will surface dead references to the dead code (e.g. its tests), which you should delete. In the process, you might have deleted the last reference to something, which will surface even more dead code. Repeat until convergence (or until you have no code left!).</p><p>References:</p><ul><li><a href="https://github.com/nadeesha/ts-prune" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune', event);">ts-prune</a> is a zero config CLI tool by <a href="https://nadeeshacabral.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://nadeeshacabral.com/', event);">Nadeehsa Cabral</a>. I <a href="https://github.com/nadeesha/ts-prune/pull/74" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/nadeesha/ts-prune/pull/74', event);">added</a> the &quot;used in module&quot; output to make it more useful for finding dead code in addition to unused imports.</li><li><a href="https://github.com/pzavolinsky/ts-unused-exports" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky/ts-unused-exports', event);">ts-unused-exports</a> is a related tool by <a href="https://github.com/pzavolinsky" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky', event);">Patricio Zavolinsky</a>. I <a href="https://github.com/pzavolinsky/ts-unused-exports/issues/2" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/pzavolinsky/ts-unused-exports/issues/2', event);">ran into issues</a> with this tool that eventually led me to ts-prune, but you may prefer it if you don&#39;t like ts-prune. It certainly has many options!</li><li>I&#39;m not aware of any tools for finding dead code in <em>JavaScript</em>. But since TypeScript is a superset of JavaScript, ts-prune should, in theory, be able to work on JS projects. I&#39;ve never tried this, but, if you get it to work, I&#39;d love to hear about it.</li></ul><!--It seems that there aren't god tools available in JavaScript:<https://www.google.com/search?q=javascript+find+dead+code>Anecdotes:- When I first ran ts-prune, it incorrectly reported dead code.  It turned out I hadn't ported all of my tests to TS yet!- Unused asset imports let you delete unused images.- If you can eliminate third-party imports, this shrinks your bundle.- Your test utils should only be imported by tests.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Software engineering is a battle against complexity. Without any planning or care, it&amp;#39;s easy to build programs where everything interacts with everything else (the &amp;quot;big ball of yarn&amp;quot; model). With a ball of yarn, if you double the number of components, you quadruple the number of interactions:&lt;/p&gt;
&lt;img src=&quot;https://effectivetypescript.com/images/quadratic.png&quot; alt=&quot;Complexity increases with the number of interactions, i.e. quadratically&quot; width=&quot;439&quot; height=&quot;262&quot;&gt;

&lt;p&gt;One of the best ways to fight against this ramp-up of complexity is to simply reduce N, i.e. to write fewer lines of code. Using a higher level programming language or depending on well-tested third-party libraries are common ways to do this. But one of the easiest ways is to find code you don&amp;#39;t need any more and delete it.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Repeat yourself a little less: Strategies for mitigating prop drilling with React and TypeScript</title>
    <link href="https://effectivetypescript.com/2020/10/01/prop-drilling/"/>
    <id>https://effectivetypescript.com/2020/10/01/prop-drilling/</id>
    <published>2020-10-02T01:30:00.000Z</published>
    <updated>2020-10-02T01:28:03.357Z</updated>
    
    <content type="html"><![CDATA[<p>I have a new post up on the LogRocket blog this week: <a href="https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescript/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescript/', event);">Repeat yourself a little less:Strategies for mitigating prop drilling with React and TypeScript</a>.</p><p>It presents the problem of &quot;prop drilling&quot; in React, where you want to add a prop to a component somewhere deep down in your hierarchy and you have to add it in ten other places to get it there. It then looks at five different solutions, all of which work in TypeScript. Give it a read and let me know what you think!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;I have a new post up on the LogRocket blog this week: &lt;a href=&quot;https://blog.logrocket.com/mitigating-prop-drilling-with-react-and-typescr
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Exercises</title>
    <link href="https://effectivetypescript.com/2020/09/10/problem-sets/"/>
    <id>https://effectivetypescript.com/2020/09/10/problem-sets/</id>
    <published>2020-09-10T13:25:00.000Z</published>
    <updated>2020-09-10T13:23:34.549Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;d never describe problem sets as &quot;fun,&quot; but there&#39;s a reason teachers assign them. It&#39;s one thing to nod your head as you read a book (&quot;yes, that makes sense&quot;) but quite another to apply what you&#39;ve learned. Software is very much a &quot;learn by doing&quot; field. You retain knowledge better when you actively use it.</p><p>I would have liked to include exercises in <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> but never quite got around to it. Fortunately, there are several excellent sources of TypeScript exercises and puzzles online. Here are a few:</p><a id="more"></a><h2 id="TypeScript-Exercises"><a href="#TypeScript-Exercises" class="headerlink" title="TypeScript Exercises"></a>TypeScript Exercises</h2><p><img src="/images/typescript-exercises.png" alt="TypeScript Exercises"></p><p>I can&#39;t recommend <a href="https://twitter.com/mdevils" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://twitter.com/mdevils', event);">Marat Dulin</a>&#39;s <a href="https://typescript-exercises.github.io/" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://typescript-exercises.github.io/', event);">TypeScript Exercises</a> enough. The problems all build on one another, starting very simple and getting very complex. They have a story and a theme to them that I found thoroughly enjoyable (&quot;CEO&#39;s friend Nick told us that if we randomly swap user names from time to time in the community, it would be very funny and the project would definitely succeed!&quot;) Marat&#39;s latest update includes a hosted version, so you can complete the exercises without leaving your browser. My solutions and commentary on a previous version are <a href="https://github.com/typescript-exercises/typescript-exercises/pull/11" target="_blank" rel="noopener" onclick="return trackOutboundLink('typescript exercises', 'https://github.com/typescript-exercises/typescript-exercises/pull/11', event);">here</a>.</p><h2 id="Type-Challenges"><a href="#Type-Challenges" class="headerlink" title="Type Challenges"></a>Type Challenges</h2><p><img src="/images/type-challenges.png" alt="Type Challenges"></p><p>The <a href="https://github.com/type-challenges/type-challenges#challenges" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://github.com/type-challenges/type-challenges#challenges', event);">Type Challenges</a> project was created by <a href="https://antfu.me/" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://antfu.me/', event);">Anthony Fu</a> and others. (It&#39;s also available in Chinese!) These challenges are independent puzzles and can be done in any order. Each challenge takes you to a TypeScript playground with infuriating red squiggles that must be fixed. This project is very community-oriented: you&#39;re encouraged to submit your solutions and suggest other puzzles. I expect that over time it will grow to include many, many more challenges.</p><p>If you&#39;ve read <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('type challenges', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> and want to apply what you&#39;ve learned, these are both great resources. Are there others I&#39;ve missed? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I&amp;#39;d never describe problem sets as &amp;quot;fun,&amp;quot; but there&amp;#39;s a reason teachers assign them. It&amp;#39;s one thing to nod your head as you read a book (&amp;quot;yes, that makes sense&amp;quot;) but quite another to apply what you&amp;#39;ve learned. Software is very much a &amp;quot;learn by doing&amp;quot; field. You retain knowledge better when you actively use it.&lt;/p&gt;
&lt;p&gt;I would have liked to include exercises in &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; but never quite got around to it. Fortunately, there are several excellent sources of TypeScript exercises and puzzles online. Here are a few:&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Golden Rule of Generics</title>
    <link href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/"/>
    <id>https://effectivetypescript.com/2020/08/12/generics-golden-rule/</id>
    <published>2020-08-12T19:30:00.000Z</published>
    <updated>2022-02-25T16:31:14.987Z</updated>
    
    <content type="html"><![CDATA[<img src="/images/ruler.png" alt="Golden Ruler" style="float:right" width="300" height="180"><p>The <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/">New TypeScript Handbook</a> has some real gems in it. Here&#39;s <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions">what it has to say about generics</a>:</p><blockquote><p>Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren&#39;t needed can make inference less successful, frustrating callers of your function.</p></blockquote><p>It goes on to offer a few specific pieces of advice about how to use generics, including one that I&#39;ve started to think of as the <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice">&quot;Golden Rule of Generics&quot;</a>:</p><blockquote><h5 id="Type-Parameters-Should-Appear-Twice"><a href="#Type-Parameters-Should-Appear-Twice" class="headerlink" title="Type Parameters Should Appear Twice"></a>Type Parameters Should Appear Twice</h5><p>Type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it&#39;s not relating anything.</p><p><strong>Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it.</strong></p></blockquote><p>I love this rule because it&#39;s so concrete. It gives you a specific way to tell whether any use of generics is good or bad.</p><span id="more"></span><p>But it&#39;s not always obvious how to apply this rule, and it doesn&#39;t offer much guidance about how rework your code if you&#39;re using generics poorly. So in a nod to the <a href="https://fivethirtyeight.com/features/politics-podcast-good-use-of-polling-or-bad-use-of-polling-in-the-west-wing/">folks at 538</a>, let&#39;s play the &quot;good use of generics or bad use of generics&quot; game. The examples that follow have been edited to protect the innocent, but they are all based on real code I&#39;ve encountered either in blog posts or in print.</p><p>Let&#39;s start with the identity function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>Good use of generics or bad use? In this example the generic argument, <code>T</code>, appears in two places after its declaration:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">arg: T</span>): <span class="hljs-title">T</span> </span>&#123;<br>             <span class="hljs-comment">// (dec)     1   2</span><br>  <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><!-- Via TS handbook hb-generics --><p>So this passes the test and is a good use of generics. And rightly so: it relates two types because it says that the input parameter&#39;s type and the return type are the same.</p><p>How about this one?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">third</span>&lt;<span class="hljs-title">A</span>, <span class="hljs-title">B</span>, <span class="hljs-title">C</span>&gt;(<span class="hljs-params">a: A, b: B, c: C</span>): <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><p>The generic parameter <code>C</code> appears twice, so it&#39;s fine. But <code>A</code> and <code>B</code> only appear once (other than in their declarations), so this function fails the test. In fact, we can rewrite it using only one generic parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">third</span>&lt;<span class="hljs-title">C</span>&gt;(<span class="hljs-params">a: unknown, b: unknown, c: C</span>): <span class="hljs-title">C</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br></code></pre></td></tr></table></figure><!--Source: <https://www.digitalocean.com/community/tutorials/typescript-generics-in-typescript>--><p>Here&#39;s a function that parses <a href="https://en.wikipedia.org/wiki/YAML">YAML</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Is this a good use of generics or a bad use of generics? The type paramter <code>T</code> only appears once, so it must be bad. How to fix it? It depends what your goal is. These so-called &quot;return-only generics&quot; are dangerous because they&#39;re equivalent to <code>any</code>, but don&#39;t use the word <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Weight &#123;<br>  pounds: <span class="hljs-built_in">number</span>;<br>  ounces: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> w: Weight = parseYAML(<span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p>The <code>Weight</code> here could be any type and this code would type check. If that&#39;s what you want, you may as well just be explicit about your <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">any</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>But the recommended way to do this is by returning <code>unknown</code> instead:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseYAML</span>(<span class="hljs-params">input: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">unknown</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will force users of the function to perform a type assertion on the result:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> w = parseYAML(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-keyword">as</span> Weight;<br></code></pre></td></tr></table></figure><p>This is actually a good thing since it forces you to be explicit about your unsafe type assertion. There are no illusions of type safety here!</p><p>How about this one?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(obj[key]);<br>&#125;<br></code></pre></td></tr></table></figure><p>Since <code>K</code> only appears once, this is a bad use of generics (<code>T</code> appears both as a parameter type and as a constraint on <code>K</code>). Fix it by moving the <code>keyof T</code> into the parameter type and eliminating <code>K</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">printProperty</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: keyof T</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(obj[key]);<br>&#125;<br></code></pre></td></tr></table></figure><p>This function looks superficially similar:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">obj: T, key: K</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> obj[key];<br>&#125;<br></code></pre></td></tr></table></figure><p>This one, however, is actually a good use of generics! The trick is to look at the return type of this function. Hovering over it in your editor, you can see its full type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getProperty</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T, key: K</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">T</span>[<span class="hljs-title">K</span>]</span><br></code></pre></td></tr></table></figure><p>The return type is inferred as <code>T[K]</code>, so <code>K</code> <em>does</em> appear twice! This is a good use of generics: <code>K</code> is related to <code>T</code>, and the return type is related to both <code>K</code> and <code>T</code>.</p><p>What about a class?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassyArray</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  arr: T[];<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">arr: T[]</span>)</span> &#123; <span class="hljs-built_in">this</span>.arr = arr; &#125;<br><br>  get(): T[] &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.arr; &#125;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">item: T</span>)</span> &#123; <span class="hljs-built_in">this</span>.arr.push(item); &#125;<br>  <span class="hljs-function"><span class="hljs-title">remove</span>(<span class="hljs-params">item: T</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.arr = <span class="hljs-built_in">this</span>.arr.filter(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el !== item)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is fine since <code>T</code> appears many times in the implementation (I count 5). When you instantiate a <code>ClassyArray</code>, you bind the type variable and it relates the types of all the properties and methods on the class.</p><p>This class, on the other hand, fails the test:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Joiner</span>&lt;<span class="hljs-title">T</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">string</span> | <span class="hljs-title">number</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">join</span>(<span class="hljs-params">els: T[]</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + el).join(<span class="hljs-string">&#x27;,&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>First of all, <code>T</code> only applies to <code>join</code>, so it can be moved down onto the method, rather than the class:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Joiner</span> </span>&#123;<br>  join&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>&gt;(els: T[]) &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + el).join(<span class="hljs-string">&#x27;,&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>By moving the declaration of <code>T</code> closer to its use, we make it possible for TypeScript to infer the type of <code>T</code>. Generally this is what you want!</p><!--It would be nice to provide an example of this, but it requires an examplethat's actually a good use of generics!--><p>But in this case, since <code>T</code> only appears once, you should make it non-generic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Joiner</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">join</span>(<span class="hljs-params">els: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[]</span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + el).join(<span class="hljs-string">&#x27;,&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Finally, why does this need to be a class at all? This noun-ing feels like a <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">Java-ism</a>. Just make it a standalone function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">join</span>(<span class="hljs-params">els: (<span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>)[]</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> els.map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + el).join(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>How about this function to get the length of any array-like object?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Lengthy &#123;<br>  length: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Lengthy</span>&gt;(<span class="hljs-params">x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>Since <code>T</code> only appears once after its definition, this is a bad use of generics. It could be written as:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: Lengthy</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>or even:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: &#123;length: <span class="hljs-built_in">number</span>&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>Or, since TypeScript has a <a href="https://github.com/microsoft/TypeScript/blob/9ff24b6fc87dd4a376a434d1019d356dfe743c53/lib/lib.es5.d.ts#L1451-L1454">built-in <code>ArrayLike</code> type</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>(<span class="hljs-params">x: ArrayLike</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x.length;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you&#39;ve made it this far, you should have a good sense for how to apply the golden rule of generics and how to fix the declarations that break it. As you read and write generic functions, think about whether they follow this rule! If you&#39;re having trouble telling or aren&#39;t sure how to fix one, <a href="https://twitter.com/danvdk">tweet at me</a>!</p><p><em>(Credit for this rule <a href="https://twitter.com/danvdk/status/1288201956759146496">goes to</a> TypeScript engineering lead <a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a>. If you like it, be sure to thank him! If you <strong>really</strong> like it, consider turning it into an <a href="https://eslint.org/docs/developer-guide/">eslint rule</a>. Golden ruler is from <a href="https://freesvg.org/molumen-ruler">FreeSvg</a>.)</em></p>]]></content>
    
    <summary type="html">
    
      &lt;img src=&quot;/images/ruler.png&quot; alt=&quot;Golden Ruler&quot; style=&quot;float:right&quot; width=&quot;300&quot; height=&quot;180&quot;&gt;

&lt;p&gt;The &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/&quot;&gt;New TypeScript Handbook&lt;/a&gt; has some real gems in it. Here&amp;#39;s &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/#guidelines-for-writing-good-generic-functions&quot;&gt;what it has to say about generics&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Writing generic functions is fun, and it can be easy to get carried away with type parameters. Having too many type parameters or using constraints where they aren&amp;#39;t needed can make inference less successful, frustrating callers of your function.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;It goes on to offer a few specific pieces of advice about how to use generics, including one that I&amp;#39;ve started to think of as the &lt;a href=&quot;https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice&quot;&gt;&amp;quot;Golden Rule of Generics&amp;quot;&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;h5 id=&quot;Type-Parameters-Should-Appear-Twice&quot;&gt;&lt;a href=&quot;#Type-Parameters-Should-Appear-Twice&quot; class=&quot;headerlink&quot; title=&quot;Type Parameters Should Appear Twice&quot;&gt;&lt;/a&gt;Type Parameters Should Appear Twice&lt;/h5&gt;&lt;p&gt;Type parameters are for relating the types of multiple values. If a type parameter is only used once in the function signature, it&amp;#39;s not relating anything.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rule: If a type parameter only appears in one location, strongly reconsider if you actually need it.&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I love this rule because it&amp;#39;s so concrete. It gives you a specific way to tell whether any use of generics is good or bad.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Writing a safe querySelector: the one-way street from values to types</title>
    <link href="https://effectivetypescript.com/2020/07/27/safe-queryselector/"/>
    <id>https://effectivetypescript.com/2020/07/27/safe-queryselector/</id>
    <published>2020-07-27T13:57:32.000Z</published>
    <updated>2022-02-25T15:56:43.588Z</updated>
    
    <content type="html"><![CDATA[<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelector"><code>querySelector</code></a> method lets you retrieve DOM elements from JavaScript using CSS selectors:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> codeBlockEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;p.intro code&#x27;</span>);<br></code></pre></td></tr></table></figure><p>This API is ubiquitous in JavaScript, but it presents some challenges in a TypeScript context. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl.textContent);<br>   <span class="hljs-comment">// ~~~~~~~~~~~ const codeBlockEl: Element | null</span><br>   <span class="hljs-comment">//             Object is possibly &#x27;null&#x27;.</span><br></code></pre></td></tr></table></figure><p>There&#39;s no guarantee that the selector will match any element, in which case it returns <code>null</code>. If you know from context that such an element does exist, you can use a non-<code>null</code> assertion (<code>!</code>) to silence the error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl!.textContent);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p><code>codeBlockEl!</code> is shorthand for <code>(codeBlockEl as Element)</code> and is just as unsafe as any type assertion. If you <em>don&#39;t</em> know that the selector will match, you can use a conditional to narrow its type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (codeBlockEl) &#123;<br>  alert(codeBlockEl.textContent);  <span class="hljs-comment">// also ok</span><br>&#125;<br></code></pre></td></tr></table></figure><p>You can also use the optional chaining operator to allow <code>undefined</code>s to bubble up:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(codeBlockEl?.textContent);  <span class="hljs-comment">// ok, might alert null or undefined</span><br></code></pre></td></tr></table></figure><p>But <code>null</code> isn&#39;t the only problem. You might also get a type that&#39;s not specific enough. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input.first-name&#x27;</span>);<br>alert(nameEl!.value);<br>           <span class="hljs-comment">// ~~~~~ Property &#x27;value&#x27; does not exist on type &#x27;Element&#x27;.</span><br></code></pre></td></tr></table></figure><p><code>document.querySelector</code> returns an <code>Element</code>, but the <code>value</code> property is only defined on <code>HTMLInputElement</code>, which is a subtype. The solutions to this problem are similar. You can either use an unsafe type assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl =<br>  <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input.first-name&#x27;</span>) <span class="hljs-keyword">as</span> HTMLInputElement;<br>alert(nameEl.value);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Or you can use an <code>instanceof</code> check to narrow the type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nameEl = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input.first-name&#x27;</span>);<br><span class="hljs-keyword">if</span> (!(nameEl <span class="hljs-keyword">instanceof</span> HTMLInputElement)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Something has gone very, very wrong.&#x27;</span>);<br>&#125;<br>alert(nameEl.value);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>If you plug this last example into the <a href="https://www.typescriptlang.org/play/#code/MYewdgzgLgBGCGBbApgUQDYwLwwCYmAFcUwoA6AR0OQCcBPAZWXWWChBoAoByASzAAOhcgDNeNaAFoEKbgEoA3ACheImJwCEnGWkz9o8MMGQg1ACQAqAWQAyASUHCMyElDlyYAbyUwYUABY0IADucMihqDRBXNwMICgB-ADmMP7wEDBJ4MgwAG60dAA0eQUwwUFgSWTyygC+SvAsNFDaSLpkuY3Uir4A9L0wIADWSkA">TypeScript playground</a> and mouse over <code>nameEl</code> on the last line, you&#39;ll see that its TypeScript type is <code>HTMLInputElement</code>. Every other type would have made the code throw.</p><p>Writing these sorts of checks out every time you use <code>querySelector</code> quickly becomes tedious. Let&#39;s try to write a generic version instead!</p><p>The <code>null</code> checking is easy to abstract:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkedQuerySelector</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Element | Document, selector: <span class="hljs-built_in">string</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Element</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> el = parent.querySelector(selector);<br>  <span class="hljs-keyword">if</span> (!el) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> didn&#x27;t match any elements.`</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> el;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can swap this in for any use of <code>querySelector</code> to exclude <code>null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">alert(checkedQuerySelector(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;p.intro code&#x27;</span>).textContent);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>But what about the case where you need a more specific type? It&#39;s tempting to plug in a generic type parameter and try to implement something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeQuerySelector</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Document|Element, selector: <span class="hljs-built_in">string</span></span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">const</span> el = checkedQuerySelector(parent, selector);<br>  <span class="hljs-keyword">if</span> (!(el <span class="hljs-keyword">instanceof</span> T)) &#123;<br>                   <span class="hljs-comment">// ~ &#x27;T&#x27; only refers to a type, but is</span><br>                   <span class="hljs-comment">//    being used as a value here.</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> returned the wrong type.`</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> el;<br><span class="hljs-comment">// ~~~~~~~~~ Type &#x27;Element&#x27; is not assignable to type &#x27;T&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The error on the <code>instanceof</code> check is a fundamental one that cannot be worked around. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/instanceof"><code>instanceof</code></a> is an operator that is evaluated at runtime. As Item 3 of <a href="https://amzn.to/38s1oCK"><em>Effective TypeScript</em></a> (&quot;Understand That Code Generation Is Independent of Types&quot;) and <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html">many other sites</a> explain, TypeScript types <em>do not exist at runtime</em>. So referencing them in a runtime expression is nonsensical. You can&#39;t get a value at runtime from a TypeScript type. It just won&#39;t work.</p><p>You <em>can</em> go the other way, however! Given a value, you can get a TypeScript type using <code>typeof</code>. And fortunately for us, there are runtime values corresponding to all the DOM types, just as there are for all classes. <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLButtonElement"><code>HTMLButtonElement</code></a> in TypeScript can refer to either a type or a value depending on the context.</p><p>So instead of passing in the type we want, let&#39;s pass in a value. Here&#39;s a sketch:</p><!-- verifier:skip because it's incomplete --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">safeQuerySelector</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> ???&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  parent: Document | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): ??? </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> buttonEl = safeQuerySelector(<br>  <span class="hljs-built_in">document</span>, HTMLButtonElement, <span class="hljs-string">&#x27;button.save&#x27;</span><br>);  <span class="hljs-comment">// type should be HTMLButtonElement</span><br></code></pre></td></tr></table></figure><p>Don&#39;t let the name fool you: <code>type</code> here is a <em>value</em>. We&#39;ve got a few blanks to fill in, but this declaration at least has the great advantage of not going against TypeScript&#39;s design principles!</p><p>Every value has a type. So what&#39;s the type of <code>HTMLButtonElement</code> in the previous function call? It&#39;s <code>typeof HTMLButtonElement</code>, of course! You can see what this really is by hovering over <code>T</code> in the following sample:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> HTMLButtonElement;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    new (): HTMLButtonElement;</span><br><span class="hljs-comment">//    prototype: HTMLButtonElement;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>This definition comes from <a href="https://github.com/microsoft/TypeScript/blob/73b268ec5b7b31f7065b77c20b6a8d759e0b7091/lib/lib.dom.d.ts#L6610-L6613"><code>lib.dom.d.ts</code></a>. It says that you can <code>new</code> an instance of <code>typeof HTMLButtonElement</code> to get an instance of the <code>HTMLButtonElement</code> type. The other DOM element classes (such as <code>HTMLElement</code>) have similar types.</p><p>We can use this to place a constraint on the generic parameter, <code>T</code>:</p><!-- verifier:skip because it's incomplete --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryElement</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">typeof</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  container: Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): ??? </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The <code>Element</code> in <code>T extends typeof Element</code> refers to a value, but <code>typeof Element</code> is a type. If <code>HTMLButtonElement</code> is a subtype of <code>Element</code>, then <code>typeof HTMLButtonElement</code> is a subtype of <code>typeof Element</code>. Passing in <code>HTMLButtonElement</code> will work, but passing in <code>RegExp</code> or <code>console</code> won&#39;t. And by using a generic parameter, we&#39;ll be able to infer a precise type based on the value of the <code>type</code> parameter at the call site.</p><!--<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Test of the claim in the previous paragraph.</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>: <span class="hljs-keyword">typeof</span> Element</span>) </span>&#123;&#125;<br><br>test(Element);<br>test(HTMLElement);<br>test(HTMLButtonElement);<br>test(HTMLDivElement);<br>test(<span class="hljs-regexp">/foo/</span>);<br>  <span class="hljs-comment">// ~~~~~ Type RegExp is not assignable to type typeof Element</span><br>test(<span class="hljs-built_in">console</span>);<br>  <span class="hljs-comment">// ~~~~~ Type Console is not assignable to type typeof Element</span><br></code></pre></td></tr></table></figure><p>--&gt;</p><p>What about the return type? How do we go from <code>typeof Element</code> to <code>Element</code> (the type)? This is precisely what TypeScript&#39;s built-in <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#instancetypet"><code>InstanceType</code></a> generic does:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = <span class="hljs-keyword">typeof</span> HTMLButtonElement;<br><span class="hljs-keyword">type</span> U = InstanceType&lt;T&gt;;  <span class="hljs-comment">// type is HTMLButtonElement</span><br></code></pre></td></tr></table></figure><p>With that in place, we can finally implement the function:</p><!-- verifier:prepend-to-following --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queryElement</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">typeof</span> <span class="hljs-title">Element</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  container: Document | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">type</span>: T,</span></span><br><span class="hljs-function"><span class="hljs-params">  selector: <span class="hljs-built_in">string</span>,</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">InstanceType</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">const</span> el = checkedQuerySelector(container, selector);<br>  <span class="hljs-keyword">if</span> (!(el <span class="hljs-keyword">instanceof</span> <span class="hljs-keyword">type</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<br>      <span class="hljs-string">`Selector <span class="hljs-subst">$&#123;selector&#125;</span> matched <span class="hljs-subst">$&#123;el&#125;</span> which is not an <span class="hljs-subst">$&#123;<span class="hljs-keyword">type</span>&#125;</span>`</span><br>    );<br>  &#125;<br>  <span class="hljs-keyword">return</span> el <span class="hljs-keyword">as</span> InstanceType&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>And this works exactly as you&#39;d hope:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> el = queryElement(<br>  <span class="hljs-built_in">document</span>, HTMLTextAreaElement, <span class="hljs-string">&#x27;textarea.deep-thoughts&#x27;</span><br>);<br>alert(el.value);  <span class="hljs-comment">// ok, el&#x27;s type is HTMLTextAreaElement</span><br></code></pre></td></tr></table></figure><p>(If you know how to get rid of the type assertion on the <code>return</code> line, please <a href="https://twitter.com/danvdk">let me know</a>!)</p><p>If you preferred the syntax of the explicit generic argument, where the <code>Element</code> subtype is more clearly separated from the usual <code>querySelector</code> parameters, you can get close by <a href="https://wiki.haskell.org/Currying">currying</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> curryQueryElement = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">typeof</span> <span class="hljs-attr">Element</span>&gt;</span>(</span><br><span class="xml">  type: T,</span><br><span class="xml">) =&gt; (</span><br><span class="xml">  container: Document | Element,</span><br><span class="xml">  selector: string,</span><br><span class="xml">) =&gt; queryElement(container, type, selector);</span><br><br><span class="xml">const el = curryQueryElement(HTMLTextAreaElement)(</span><br><span class="xml">  document, &#x27;textarea.deep-thoughts&#x27;</span><br><span class="xml">);</span><br><br><span class="xml">// Or:</span><br><span class="xml">const textareaQuery = curryQueryElement(HTMLTextAreaElement);</span><br><span class="xml">const el2 = textareaQuery(document, &#x27;textarea.deep-thoughts&#x27;);</span><br></code></pre></td></tr></table></figure><p>If you ever find yourself wanting to use a TypeScript type at runtime, STOP ! Remember that TypeScript types get erased when your code is converted to JavaScript, leaving only the values. But if your goal is to check the runtime type <em>and</em> narrow the TypeScript type, there may still be hope. Types and values are a one-way street: you can go from a value to a type (with <code>typeof</code>), but not from a type to a value. So the solution is often to rework your API to pass around values and derive the types from those. The safe <code>querySelector</code> we&#39;ve built in this post is one example of doing that. In future posts we&#39;ll look at a few more examples of how this strategy can play out in practice.</p><p>Related material:</p><ul><li>Item 3: &quot;Understand That Code Generation Is Independent of Types&quot; or Evan Martin&#39;s <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html">TypeScript&#39;s type independent output</a>.</li><li>Item 8: &quot;Know How to Tell Whether a Symbol Is in the Type Space or Value Space&quot; or Florian Reuschel&#39;s <a href="https://dev.to/loilo/typescript-s-secret-parallel-universe-54i6">TypeScript&#39;s Secret Parallel Universe</a></li><li>Item 55: &quot;Understand the DOM hierarchy&quot;</li></ul>]]></content>
    
    <summary type="html">
    
      The DOM&#39;s &lt;code&gt;document.querySelector&lt;/code&gt; method is ubiquitious in JavaScript but somewhat tricky to type in a safe way. This post walks through how you can create a safe &lt;code&gt;querySelector&lt;/code&gt; for use in TypeScript code and explains how this is an example of a general pattern of using values (which exist at runtime) as a source of truth, rather than types (which don&#39;t).

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Type-safe blogs and books with literate-ts</title>
    <link href="https://effectivetypescript.com/2020/06/30/literate-ts/"/>
    <id>https://effectivetypescript.com/2020/06/30/literate-ts/</id>
    <published>2020-06-30T21:00:00.000Z</published>
    <updated>2020-07-04T20:52:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>Years ago when Brett Slatkin wrote <a href="https://effectivepython.com/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://effectivepython.com/', event);"><em>Effective Python</em></a>, he <a href="https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html', event);">blogged about</a> creating a tool call <a href="https://github.com/bslatkin/pyliterate" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/bslatkin/pyliterate', event);">pyliterate</a> to run all the code samples in his book and verify that their output matched what he&#39;d written in the text. The idea stuck with me and when I started writing <a href="https://amzn.to/38s1oCK" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://amzn.to/38s1oCK', event);"><em>Effective TypeScript</em></a> in early 2019, I thought I&#39;d do something similar. If nothing else, static analysis of a book seems very much in the spirit of TypeScript. Creating <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> wound up being a lot of work, but in the end I think it more justified itself, though not quite for the reasons I expected!</p><a id="more"></a><p>TypeScript presents a few challenges for verification. You can compile and run a TypeScript program through Node to check its output, sure, but then you&#39;re not testing anything relating to the errors or inferred types. Usually you see these by mousing over a symbol or an error in your editor. But what&#39;s &quot;mousing over&quot; in a printed book? Still, inferred types and errors are both essential parts of the TypeScript experience and I wanted to both show them in <em>Effective TypeScript</em> and check them with a verifier.</p><p>As I wrote, I eventually settled on a system. To show an error in a code sample, I&#39;d put tildes and the error message in a comment under the line on which the error occurred. This is meant to evoke the squiggly red lines under an error in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> str = <span class="hljs-string">'not a number'</span>;<br><span class="hljs-keyword">let</span> num: <span class="hljs-built_in">number</span> = str;<br><span class="hljs-comment">//  ~~~ Type 'string' is not assignable to type 'number'.</span><br></code></pre></td></tr></table></figure><p>In addition to conveying the error to the reader, there are a few things for that can be verified here:</p><ol><li>When you run it through <code>tsc</code>, does the code sample produce that one error <em>and no others</em>?</li><li>Do the tildes line up with the true error?</li><li>Do the error messages match?</li></ol><p>For inferred types, I used a slightly different comment syntax, always starting with &quot;type is&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> x = <span class="hljs-number">12</span>;  <span class="hljs-comment">// type is number</span><br><span class="hljs-string">'four score'</span>.split(<span class="hljs-string">' '</span>);  <span class="hljs-comment">// type is string[]</span><br></code></pre></td></tr></table></figure><p>This indicates that if you mouse over <code>x</code> you&#39;ll see that the inferred type is <code>number</code>. For the second line, you need to assign the expression to a variable or mouse over <code>split</code> to see the <code>string[]</code> type. It&#39;s usually quite intuitive which symbol the &quot;type is&quot; refers to, but getting this right in the verifier took a bit of care. The main thing to verify here, of course, is the type of the symbol or expression. The string representations of the types are matched, character-for-character, ala <a href="https://github.com/microsoft/dtslint" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/dtslint', event);">dtslint</a>.</p><p>If the types don&#39;t line up, or the errors aren&#39;t quite right, <code>literate-ts</code> will complain:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ cat sample.asciidoc<br>TypeScript will infer types in the absence of annotations:<br><br>[source,ts]<br>----<br>const n &#x3D; 10;  &#x2F;&#x2F; type is number<br>----<br><br>$ literate-ts --alsologtostderr sample.asciidoc<br>Verifying with TypeScript 4.0.0-dev.20200629<br><br>Code passed type checker.<br>sample-4: Failed type assertion for const n &#x3D; 10; (tested n)<br>  Expected: number<br>    Actual: 10<br>  0&#x2F;1 type assertions matched.<br></code></pre></td></tr></table></figure><p>(The issue is here is that the inferred type is the numeric literal type <code>10</code> rather than <code>number</code>. Either the comment should be changed or the variable should be declared with <code>let</code>.)</p><p>Overall I&#39;m pretty happy with how things turned out! You can check out the results over at the <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> repo. All in all, there are about 600 code samples in <em>Effective TypeScript</em> that all get checked. Running these checks takes 510 minutes on my Macbook.</p><p>So what sorts of errors did literate-ts turn up? Initially not many! I&#39;d been pretty careful about running code samples through VS Code or the TypeScript playground before committing them. Here was the first mistake that it caught (at the end of Item 7, &quot;Think of Types as Sets of values&quot;):</p><blockquote><p>Finally, it&#39;s worth noting that not all sets of values correspond to TypeScript types. There is no TypeScript type for all the integers, or for all the objects which have <code>x</code> and <code>y</code> properties but no others. You can sometimes subtract types using <code>Exclude</code>, but only when it would result in a proper TypeScript type:</p></blockquote><!-- verifier:skip because this is an example of a mistake --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Exclude&lt;<span class="hljs-built_in">string</span>|<span class="hljs-built_in">Date</span>, <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span>&gt;;  <span class="hljs-comment">// type is number</span><br><span class="hljs-keyword">type</span> NonZeroNums = Exclude&lt;<span class="hljs-built_in">number</span>, <span class="hljs-number">0</span>&gt;;  <span class="hljs-comment">// type is still just number</span><br></code></pre></td></tr></table></figure><p>It should be &quot;type is Date&quot;, not &quot;type is number&quot;. Not a major mistake (the argument is still valid) but a nice validation of literate-ts nonetheless. There were a handful of small mistakes like this.</p><p>Where literate-ts <em>really</em> shone was when I started <del>refactoring</del> editing the text. It&#39;s exactly the same as in coding. Writing it right the first time isn&#39;t nearly so hard as changing things and <em>keeping</em> them right. As I incorporated feedback from my editors and reworked Items, I constantly found myself introducing real mistakes that were caught by the verifier. Score one for literate-ts!</p><p>This was doubly true when the O&#39;Reilly editors started editing the text directly in the run-up to publication. Inevitably some mistakes were made, e.g. dropping quotes or comment markers. literate-ts caught all of these. (Since the book is stored in a git repo, <code>git log</code> and <code>git diff</code> were also extremely useful tools for catching these sorts of problems.)</p><p>But the biggest benefit came when new TypeScript versions were released. In the week before <em>Effective TypeScript</em> came out, the beta of TypeScript 3.7 was announced. As Anders Hejlsberg has said, semantic versioning isn&#39;t very meaningful when it comes to <code>tsc</code>: the whole <em>point</em> of new versions of TypeScript is to break your code! (Or rather to reveal ways in which it was already broken.) So as a book author, this was a bit terrifying. But no big deal, I just updated literate-ts and ran all the code samples.</p><p>The biggest issue I found was that I had a code sample showing that <code>interface</code>s could be recursive but <code>type</code> aliases couldn&#39;t. And that was true until <a href="https://github.com/microsoft/TypeScript/pull/33050" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/microsoft/TypeScript/pull/33050', event);">TypeScript 3.7!</a>. So I knew exactly what I had to fix. But just as importantly for my peace of mind, I knew that the rest of the book was OK. As new versions of TypeScript have come out since the book&#39;s publication in October of 2019, I&#39;ve continued to re-run the verifier and make minor revisions as needed.</p><p>So what sorts of mistakes <em>didn&#39;t</em> literate-ts catch? It&#39;s the classic case of <a href="https://www.destroyallsoftware.com/talks/ideology" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.destroyallsoftware.com/talks/ideology', event);">tests vs. types</a>. Here&#39;s a particularly egregious example:</p><!-- #binary-search-sorted-list --><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SortedList&lt;T&gt; = T[] &amp; &#123;_brand: <span class="hljs-string">'sorted'</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSorted</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">xs: T[]</span>): <span class="hljs-title">xs</span> <span class="hljs-title">is</span> <span class="hljs-title">SortedList</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; xs.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (xs[i] &lt; xs[i - <span class="hljs-number">1</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">binarySearch</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">xs: SortedList&lt;T&gt;, x: T</span>): <span class="hljs-title">boolean</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This comes from Item 37, which discusses &quot;brands&quot;, a way of simulating nominal typing in TypeScript to create types for things like &quot;non-empty sets&quot; or &quot;sorted sets&quot; that can&#39;t be represented directly.</p><p>The implementation of <code>binarySearch</code> is listed earlier in the text and assumes a list that&#39;s sorted in ascending order. The <code>isSorted</code> type guard checks that the list is sorted but in descending order. Oops! This all type checks great, but it produces incorrect results. A type checker can&#39;t tell you that <code>&lt;</code> should be <code>&gt;</code> (Haskell people, please tell me if I&#39;m wrong!). You really need a unit test.</p><p>At some point I realized that you <em>could</em> create a unit test with literate-ts! The trick is to write some code that calls the function and <code>console.log</code>s the results. Then literate-ts can check the expected output against the actual output. This can all go in a comment so that the reader doesn&#39;t see it.</p><p>Basically all of the <a href="https://www.oreilly.com/catalog/errata.csp?isbn=0636920261544" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.oreilly.com/catalog/errata.csp?isbn=0636920261544', event);">errata</a> have been variations on this: things that weren&#39;t checked by the verifier. I&#39;m not aware of a single mistake having to do with the type system itself.</p><p>I&#39;ve recently published <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);"><code>literate-ts</code></a> to npm and added support for Markdown sources (O&#39;Reilly books are written in Asciidoc). And I&#39;ve started applying it to this blog. If you&#39;re writing a TypeScript book or blog yourself, head over to the <a href="https://github.com/danvk/literate-ts" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/danvk/literate-ts', event);">literate-ts</a> repo, give it a try and let me know how it goes!</p><p>If you prefer videos, literate-ts comes up in my 2019 tsconf talk on Testing Types:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/nygcFEwOG8w?start=1198" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><!--Reviewing _Mastering TypeScript_ is probably a good opportunity to polish this up and publicize it.literate-ts repo to-do:- To what extent have literate-ts and verifier diverged?- Make it use node_modules from the asciidoc directory  (or make this configurable?)- Speed it up (don't rebuild compiler on every sample)- Less verbose logging- Type check ets-site (i.e. support markdown)-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Years ago when Brett Slatkin wrote &lt;a href=&quot;https://effectivepython.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://effectivepython.com/&#39;, event);&quot;&gt;&lt;em&gt;Effective Python&lt;/em&gt;&lt;/a&gt;, he &lt;a href=&quot;https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://www.onebigfluke.com/2014/07/how-im-writing-programming-book.html&#39;, event);&quot;&gt;blogged about&lt;/a&gt; creating a tool call &lt;a href=&quot;https://github.com/bslatkin/pyliterate&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/bslatkin/pyliterate&#39;, event);&quot;&gt;pyliterate&lt;/a&gt; to run all the code samples in his book and verify that their output matched what he&amp;#39;d written in the text. The idea stuck with me and when I started writing &lt;a href=&quot;https://amzn.to/38s1oCK&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://amzn.to/38s1oCK&#39;, event);&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; in early 2019, I thought I&amp;#39;d do something similar. If nothing else, static analysis of a book seems very much in the spirit of TypeScript. Creating &lt;a href=&quot;https://github.com/danvk/literate-ts&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; onclick=&quot;return trackOutboundLink(&#39;&#39;, &#39;https://github.com/danvk/literate-ts&#39;, event);&quot;&gt;literate-ts&lt;/a&gt; wound up being a lot of work, but in the end I think it more justified itself, though not quite for the reasons I expected!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
