<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2023-06-27T20:41:34.046Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes on TypeScript 5.1</title>
    <link href="https://effectivetypescript.com/2023/06/27/ts-51/"/>
    <id>https://effectivetypescript.com/2023/06/27/ts-51/</id>
    <published>2023-06-27T20:40:00.000Z</published>
    <updated>2023-06-27T20:41:34.046Z</updated>
    
    <content type="html"><![CDATA[<p>Every three months we get a new TypeScript release and <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/">TypeScript 5.1</a> landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&#39;s take a look!</p><span id="more"></span><h2 id="Performance-Improvements"><a href="#Performance-Improvements" class="headerlink" title="Performance Improvements"></a>Performance Improvements</h2><p>When you hear &quot;new TypeScript version&quot;, the natural tendency is to think about new language features. But what would you be more excited about: an exciting new feature like <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">template literal types</a> or a 10% faster compiler? Sorry, you can&#39;t have both!</p><p>The TypeScript team takes compiler performance incredibly seriously and every single set of release notes includes a few performance optimizations. A recent theme has been improving build times for projects that use complex libraries like Material-UI. The 5.1 release includes several <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#optimizations">optimizations</a> that add up to a big win.</p><p>As readers of this blog may recall, <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> is itself type-checked using <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. The idea is that when new versions of TypeScript come out, I can quickly check whether any of the hundreds of code samples in the book produce new and unexpected errors. This is a great confidence booster that my book still matches reality, but it also means that <em>Effective TypeScript</em> can serve as a good gauge of what&#39;s changed between releases.</p><p>First let&#39;s look at performance:</p><ul><li>Checking Effective TypeScript (TS 5.0.4): 180.6s average</li><li>Checking Effective TypeScript (TS 5.1.3): 170.9s average</li></ul><p>That&#39;s about a 5% speedup. Not bad!</p><h2 id="Improved-Error-Messages"><a href="#Improved-Error-Messages" class="headerlink" title="Improved Error Messages"></a>Improved Error Messages</h2><p>literate-ts is very sensitive to how error messages and types <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a>. TypeScript 5.1 includes a <a href="https://github.com/microsoft/TypeScript/issues/52934">nice change</a> in how type errors on <code>return</code> statements are displayed that didn&#39;t make it into the release notes. In previous versions of TypeScript, if you returned an expression of the wrong type, you&#39;d get the dreaded red squiggles under both the <code>return</code> keyword and the entire expression. For multiline expressions, this could be a lot of red!</p><img src="/images/red-return.png" alt="Code sample showing lots of red"><p>With TypeScript 5.1, the red squiggles only appear under the <code>return</code> keyword:</p><img src="/images/red-return-less-red.png" alt="Code sample showing much less red"><p>This is less distracting and makes it easier for you to inspect your code to find the source of the error. Not a huge change, but a nice win nonetheless. Next time you&#39;re debugging a type error in a <code>return</code> statement, thank Mateusz Burzy≈Ñski for the <a href="https://github.com/microsoft/TypeScript/pull/52943">change</a>!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Upgrading TypeScript often uncovers existing mistakes in your code and TS 5.1 was no exception. There was one new error that came up in a few of my projects.</p><p>TypeScript has long flagged duplicate keys in object literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>    foo: <span class="hljs-number">12</span>,<br>    bar: <span class="hljs-number">34</span>,<br>    foo: <span class="hljs-number">56</span>,<br><span class="hljs-comment">//  ~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>But if you used <em>computed</em> keys, this error would go away:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> FOO = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">const</span> BAR = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,  <span class="hljs-comment">// (not an error in TS 5.0)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>With TS 5.1, this is an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,<br><span class="hljs-comment">// ~~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>This check only occurs for single-valued literal types.</p><!-- Error messages for `Expression4` have improved! --><!--Performance stats- TS 5.1.3:  - yarn verify  170.84s user 13.34s system 151% cpu 2:01.52 total (7/601 failed)  - yarn verify  171.54s user 13.09s system 151% cpu 2:01.72 total (4/601 failed)  - yarn verify  170.26s user 13.19s system 151% cpu 2:01.19 total (3/601 failed)- TS 5.0.4:  - yarn verify  180.57s user 13.05s system 145% cpu 2:12.67 total (3/601 failed)  - yarn verify  181.27s user 12.56s system 144% cpu 2:13.70 total (3/601 failed)  - yarn verify  180.83s user 13.00s system 145% cpu 2:12.92 total (3/601 failed)--><h2 id="Notes-on-other-changes"><a href="#Notes-on-other-changes" class="headerlink" title="Notes on other changes"></a>Notes on other changes</h2><p>The &quot;headline&quot; features in the official release notes for TS 5.1 are mostly niche changes that won&#39;t affect many users immediately. Here&#39;s a quick rundown:</p><ul><li><strong>Easier Implicit Returns for undefined-Returning Functions</strong> I&#39;ve never personally run across a function that was declared to return <code>undefined</code> rather than <code>void</code>. But if you work with such functions, your life gets easier with TS 5.1.</li><li><strong>Unrelated Types for Getters and Setters</strong> This <em>seems</em> like a bad idea though as the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#unrelated-types-for-getters-and-setters">CSS example</a> in the release notes makes clear, this is an established pattern in the wild that TypeScript needs to model. I tend to avoid getters and setters (and classes in general). This relates to <em>Effective TypeScript</em>&#39;s Item 29: Be Liberal in What You Accept and Strict in What You Produce.</li><li><strong>Decoupled Type-Checking Between JSX Elements and JSX Tag Types</strong> This seems quite in the weeds, but the gist is that it&#39;s future-proofing for async React components, which may land sometime in the future. When these eventually land, we&#39;ll be happy that TypeScript supports them out of the box.</li></ul><p>I was extremely excited about one other change in the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/#move-declarations-to-existing-files">TypeScript 5.1 RC</a> that sadly got cut for the release: a &quot;move to existing file&quot; refactor. There&#39;s a nice video of this in action in the RC release notes. This has been a long-standing and much-upvoted <a href="https://github.com/microsoft/TypeScript/issues/29988">feature request</a>. You can move a symbol to a <em>new</em> file, but not to an existing file.</p><p>I have a workaround, but it&#39;s a bit gross. Say you want to move a symbol to an existing file <code>src/utils/my-utils.ts</code>. Instead, move it to a new file <code>src/utils/new-file.ts</code>. This will update all the imports for the symbol to point to the new file. Then cut/paste the definition of your symbol into <code>my-utils.ts</code>, delete <code>new-file.ts</code> and run a big Find/Replace to update all the imports:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git ls-files | xargs perl -i -pe <span class="hljs-string">&#x27;s,new-file.ts,my-utils.ts,`</span><br></code></pre></td></tr></table></figure><p>Like I said, gross! Hopefully this feature lands more permanently in TypeScript 5.2.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>TypeScript 5.1 is not a major release when it comes to new language features, but it does include some performance wins, it may catch some new errors in your project, and it lays the groundwork for more changes in the future. Keep your eyes out for the TypeScript 5.2 beta which should be landing <a href="https://github.com/microsoft/TypeScript/issues/54298">any day now</a> and looks to have some <a href="https://www.totaltypescript.com/type-argument-placeholders-typescript-5-2-most-discussed-feature">exciting new features</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Every three months we get a new TypeScript release and &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/&quot;&gt;TypeScript 5.1&lt;/a&gt; landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&amp;#39;s take a look!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 30: Don‚Äôt Repeat Type Information in Documentation</title>
    <link href="https://effectivetypescript.com/2023/05/31/jsdoc-repeat/"/>
    <id>https://effectivetypescript.com/2023/05/31/jsdoc-repeat/</id>
    <published>2023-05-31T15:36:00.000Z</published>
    <updated>2023-06-26T16:02:57.861Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!</em></p><p>What‚Äôs wrong with this code?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string with the foreground color.</span><br><span class="hljs-comment"> * Takes zero or one arguments. With no arguments, returns the</span><br><span class="hljs-comment"> * standard foreground color. With one argument, returns the foreground color</span><br><span class="hljs-comment"> * for a particular page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> page === <span class="hljs-string">&#x27;login&#x27;</span> ? &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">127</span>&#125; : &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>The code and the comment disagree! Without more context it‚Äôs hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &quot;when your code and your comments disagree, they‚Äôre both wrong!&quot;</p><span id="more"></span><p>Let‚Äôs assume that the code represents the desired behavior. There are a few issues with this comment:</p><ul><li>It says that the function returns the color as a <code>string</code> when it actually returns an <code>&#123;r, g, b&#125;</code> object.</li><li>It explains that the function takes zero or one arguments, which is already clear from the type signature.</li><li>It‚Äôs needlessly wordy: the comment is longer than the function declaration <em>and</em> implementation!</li></ul><p>TypeScript‚Äôs type annotation system is designed to be compact, descriptive, and readable. Its developers are language experts with decades of experience. It‚Äôs almost certainly a better way to express the types of your function‚Äôs inputs and outputs than your prose!</p><p>And because your type annotations are checked by the TypeScript compiler, they&#39;ll never get out of sync with the implementation. Perhaps <code>getForegroundColor</code> used to return a string but was later changed to return an object. The person who made the change might have forgotten to update the long comment.</p><p>Nothing stays in sync unless it&#39;s forced to. With type annotations, TypeScript&#39;s type checker is that force! If you put type information in annotations and not in documentation, you greatly increase your confidence that it will remain correct as the code evolves.</p><p>A better declaration and comment might look like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123;<br>  r: <span class="hljs-built_in">number</span>;<br>  g: <span class="hljs-built_in">number</span>;<br>  b: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">/** Get the foreground color for the application or a specific page. */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Color</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>If you want to describe a particular parameter, use an <code>@param</code> JSDoc annotation. For more on this, see Item 48: Use TSDoc for API Comments.</p><p>Comments about a lack of mutation are also suspect. Don&#39;t just say that you don&#39;t modify a parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** Does not modify nums */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Instead, declare it <code>readonly</code> (See Item 17: Use readonly to Avoid Errors Associated with Mutation) and let TypeScript enforce the contract:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>What&#39;s true for comments is also true for variable names. Avoid putting types in them: rather than naming a variable <code>ageNum</code>, name it <code>age</code> and make sure it&#39;s really a <code>number</code>.</p><p>An exception to this is for numbers with units. If it&#39;s not clear what the units are, you may want to include them in a variable or property name. For instance, <code>timeMs</code> is a much clearer name than just <code>time</code>, and <code>temperatureC</code> is a much clearer name than <code>temperature</code>. Item 37 describes &quot;brands,&quot; which provide a more type-safe approach to modeling units.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst it will lead to conflicting information.</li><li>Consider including units in variable names if they aren&#39;t clear from the type (e.g., <code>timeMs</code> or <code>temperatureC</code>).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Chapter 4 of &lt;a href=&quot;https://amzn.to/3HIrQN6&quot;&gt;Effective TypeScript&lt;/a&gt; covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What‚Äôs wrong with this code?&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Returns a string with the foreground color.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Takes zero or one arguments. With no arguments, returns the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * standard foreground color. With one argument, returns the foreground color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * for a particular page.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getForegroundColor&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;page?: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; page === &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;login&amp;#x27;&lt;/span&gt; ? &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;&amp;#125; : &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;The code and the comment disagree! Without more context it‚Äôs hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &amp;quot;when your code and your comments disagree, they‚Äôre both wrong!&amp;quot;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A first look at Deno through the Advent of Code 2022</title>
    <link href="https://effectivetypescript.com/2023/04/27/aoc2022/"/>
    <id>https://effectivetypescript.com/2023/04/27/aoc2022/</id>
    <published>2023-04-27T21:00:00.000Z</published>
    <updated>2023-04-27T21:16:24.172Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">Every year I do the <a href="https://adventofcode.com/">Advent of Code</a> in a different programming language. If you aren&#39;t familiar, it&#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&#39;s a great way to learn a language and bond over coding. In <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">2019</a> I used Python, in <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">2020</a> I used Rust and in <a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/">2021</a> I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&#39;s 2022! (As a partial excuse, I have been writing on a <a href="https://danvk.org/catskills/">very different blog</a>!)</p><p>This past December I chose TypeScript, specifically <a href="https://deno.land">Deno</a>, which <a href="https://www.youtube.com/watch?v=1gIiZfSbEAE">brands itself</a> as &quot;a new way to TypeScript&quot;. While TypeScript certainly isn&#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.</p><p>This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&#39;s Advent of Code.</p><span id="more"></span><p>My code and more notes on each day&#39;s puzzles can be found on GitHub at <a href="https://github.com/danvk/aoc2022">danvk/aoc2022</a>.</p><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><p>Deno brands itself as a more secure JavaScript runtime that&#39;s more standards-compliant and easier to use. The comparison here is obviously Node.js. Deno was created by <a href="https://en.wikipedia.org/wiki/Ryan_Dahl">Ryan Dahl</a>, who also created Node.js, and it&#39;s fair to think of it as a &quot;take two&quot; on Node that avoids some of its questionable decisions.</p><p>Overall these claims hold up well. Deno is much easier to set up than Node: it already uses TypeScript, it has a built-in linter and formatter, and it comes with a system for unit tests. These are all things you <em>can</em> set up with Node, but it takes an extra step. That&#39;s a hurdle for beginners, and an opportunity for mistakes for all of us. For the most part, writing code in Deno feels just like writing TypeScript in any other environment, only with much less configuration.</p><p>(Just like a browser, Deno <a href="https://deno.com/manual@v1.32.1/advanced/typescript/overview">doesn&#39;t run your TypeScript directly</a>. It translates it to JavaScript first using <a href="https://swc.rs/">swc</a> and then runs that.)</p><p>Deno&#39;s sandboxing is a great security feature. Unless you specifically allow a capability (such as reading or writing to the file system), Deno won&#39;t allow it. This makes it safer to run programs that you download from the internet. Since I was running mostly my own code for the Advent of Code, in practice this meant that every solution started with this <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang line</a>:</p><pre><code>#!/usr/bin/env -S deno run --allow-read --allow-write</code></pre><p>Deno tries to embrace web standards to the extent that it makes sense. Rather than using a library to make HTTP requests, you use <code>fetch</code>, just like you would in a web browser. Perhaps the most notable example of this comes with dependencies. Rather than a <code>require</code> statement or running <code>npm install</code>, you depend on third-party libraries by using a standard ES <code>import</code> statement from a URL:</p><pre><code>import &#123; assert &#125; from &quot;https://deno.land/std@0.166.0/testing/asserts.ts&quot;;</code></pre><p>The version goes right there in the import URL. If you&#39;re used to npm, you probably have a few objections in your head right now! Rest assured, the Deno folks have thought through them:</p><ul><li>What if someone takes over deno.land and swaps in a malicious version of the library? You can use a <a href="https://deno.com/manual@v1.32.5/basics/modules/integrity_checking">lock file</a> for integrity checking.</li><li>Won&#39;t this be unwieldy? In practice, the Deno team recommends <a href="https://deno.com/manual@v1.32.5/basics/modules#it-seems-unwieldy-to-import-urls-everywhere">creating a <code>deps.ts</code> file</a> that consolidates all these imports in one place. This replaces <code>package.json</code>. It&#39;s a good example of Deno&#39;s preference using JS standards. I have some misgivings about this, though, see below.</li><li>What about dev dependencies? I haven&#39;t seen anything written about this explicitly, but I assume the suggestion is to have a <code>dev-deps.ts</code> file or some such.</li><li>Won&#39;t this cause an explosion of versions in transitive dependencies?</li></ul><p>To see why this might happen, imagine that module A depends on <code>lodash@4.17.20</code> and module B depends on <code>lodash@4.17.21</code>. With deno imports, you wind up with two versions of lodash:</p><p><img src="/images/aoc2022/deps-deno.png" alt="Dependencies in Deno yield two copies of lodash"></p><p>When you import from a URL that includes the full version, all your (transitive) dependencies are pinned. Node.js avoids this by specifying compatible ranges in dependencies. Perhaps A just requires <code>lodash&gt;=4</code> and B requires <code>lodash&gt;=4.10</code>. In that case, we can get down to a single version:</p><p><img src="/images/aoc2022/deps-node.png" alt="Dependencies in Node.js yield one copy of lodash"></p><p>The Deno answer to this dilemma is an <a href="https://deno.com/manual@v1.32.5/basics/import_maps">import map</a>, which lets you reach in and tweak the versions. Again, this is a <a href="https://github.com/WICG/import-maps">JavaScript standard</a>, but it feels a bit unwieldy. Would you actually do this to reduce the number of dependencies in your code? And how would you know which versions of <code>lodash</code> a module is compatible with unless it specifies.</p><p>I didn&#39;t personally run into any issues with this in the Advent of Code since I only had one or two dependencies. But projects I&#39;ve worked on professionally have had thousands, and I&#39;m nervous about any patterns that would lead to an even greater proliferation of dependencies. If you have experience building larger projects in Deno and have run into this (or not), I&#39;d love to hear about it in the comments.</p><p>I also have some concerns about the <code>deps.ts</code> system. It&#39;s clever to use a plain old TypeScript file as a <code>package.json</code> replacement in this way. But because it&#39;s a TypeScript file, my concern is that you&#39;ll be tempted to write real code in it, i.e. logic. Why is this a problem? Just look at the mess that is <code>setup.py</code> in Python land. In general it&#39;s impossible to know how a package is configured without executing <code>setup.py</code>, which could cause any number of side effects. This makes analysis harder, for example writing tools like dependabot. Simpler configuration enables more accurate, powerful tools. (<a href="https://deno.com/blog/v1.31#packagejson-support">Deno 1.31</a> added support for <code>package.json</code> to ease transitioning from Node but still recommends using import maps.)</p><p>While Deno works best when you import other Deno modules (from <code>deno.land</code>), the headline feature of <a href="https://deno.com/blog/v1.28">Deno 1.28</a> was support for npm modules. Here&#39;s what this looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; chalk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:chalk@5&quot;</span>;<br></code></pre></td></tr></table></figure><p>Easy, right? But what about TypeScript? Often the type declarations for npm libraries are hosted in a different package via DefinitelyTyped. I struggled mightily to get typings for lodash (see some <a href="https://stackoverflow.com/questions/64979829/deno-import-lodash-from-deno-land-x/66073607#66073607">crazy solutions</a> on Stack Overflow) before asking for help <a href="https://twitter.com/danvdk/status/1598502672319057925">on Twitter</a>. Here&#39;s where I wound up:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// @deno-types=&quot;npm:@types/lodash&quot;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> ld&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:lodash&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> _ = ld;<br></code></pre></td></tr></table></figure><p>So much for standards! But in fairness to Deno, once I had this magic in place I never had to think about it again.</p><p>Another pain point: I ran into <a href="https://github.com/denoland/deno/issues/17055">several</a> different <a href="https://github.com/denoland/deno/issues/17056">issues</a> with the VS Code extension, including one that changed my code to give me a wrong answer! To the Deno team&#39;s credit, they fixed both issues that I reported quickly, before Christmas. Deno is a relatively new project that is moving fast, but this also means you&#39;re more likely to run into glitches like this.</p><p>In the end, Deno is pretty nice to work with. If we were starting from scratch, it would be a much better choice than Node.js. But the Node/npm ecosystem has a ten year headstart on Deno, and I&#39;d like to give the npm integration story a bit more time to play out before I commit to using Deno on a larger project.</p><p>For a more glowing endorsement of Deno, see <a href="https://matklad.github.io/2023/02/12/a-love-letter-to-deno.html">A Love Letter to Deno</a> by <a href="https://matklad.github.io/">Alex Kladov</a>.</p><h2 id="TypeScript-JavaScript-for-Coding-Competitions"><a href="#TypeScript-JavaScript-for-Coding-Competitions" class="headerlink" title="TypeScript/JavaScript for Coding Competitions"></a>TypeScript/JavaScript for Coding Competitions</h2><p>TypeScript is a more natural fit for web programming and servers than for coding competitions, which are more the home turf for Python. So I was curious to see how doing AoC in TypeScript would feel.</p><p>JavaScript is famous for its <a href="https://en.wiktionary.org/wiki/footgun">footguns</a> and TypeScript/Deno inherit many of these. One of them got me on the <a href="https://adventofcode.com/2022/day/1">very first problem</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> sums = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>];<br>sums.sort();<br><span class="hljs-built_in">console</span>.log(sums);<br><span class="hljs-comment">// logs [1, 10, 2] -- the sort is lexicographic!</span><br></code></pre></td></tr></table></figure><p>Yes, this is one of many reasons why we always use lodash!</p><p>I&#39;d hoped that this year&#39;s Advent of Code would force me to play around more with <code>BigInt</code> (for huge numbers) and web workers (for parallelism), but neither of these proved to be necessary this year.</p><p>I did make extensive use of ES2015&#39;s <code>Set</code> and <code>Map</code> classes. These make amends for the &quot;original sin of JavaScript&quot;, namely the conflation of objects and associative arrays. While <code>Set</code> and <code>Map</code> do fix many of the issues with objects (accessing <code>prototype</code>, supporting non-<code>string</code> keys), they have some footguns of their own.</p><p>For example, I learned back in 2019 that a map with (x, y) tuples as keys is often a <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">more convenient way</a> to represent a grid than a 2D array. Python handles this pattern nicely with its built-in tuple type:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">grid = &#123;&#125;<br>grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">3</span><br>print(grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)])<br><span class="hljs-comment"># prints 3</span><br></code></pre></td></tr></table></figure><p>The equivalent in JS/TS doesn&#39;t work as you&#39;d hope:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], <span class="hljs-built_in">number</span>&gt;();<br>grid.set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs undefined</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>Map</code> and <code>Set</code> keys are (<a href="https://stackoverflow.com/questions/56195369/how-does-same-value-zero-algorithm-works">roughly</a>) compared using <code>===</code>, which tests for reference equality, not value equality:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br></code></pre></td></tr></table></figure><p>This situation will be improved greatly if the <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a> is ratified by TC39 (<a href="https://rickbutton.github.io/record-tuple-playground/#eyJjb250ZW50IjoiY29uc29sZS5sb2coI1sxLCAyXSA9PT0gI1sxLCAyXSk7XG5cbmNvbnN0IGdyaWQgPSBuZXcgTWFwKCk7XG5ncmlkLnNldCgjWzEsIDJdLCAzKTtcbmNvbnNvbGUubG9nKGdyaWQuZ2V0KCNbMSwgMl0pKTtcbiIsInN5bnRheCI6Imhhc2giLCJkb21Nb2RlIjpmYWxzZX0=">playground link</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">console</span>.log(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] === #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-comment">// logs true</span><br><br><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>grid.set(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs 3</span><br></code></pre></td></tr></table></figure><p>Here&#39;s hoping! Without this, my implementations of standard algorithms like <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">shortest path</a> required lots of <a href="https://github.com/danvk/aoc2022/blob/da3b5af9aef99cff8c1f739d07958d7c75a5794a/dijkstra.ts#L18-L19">serialization and deserialization code</a>.</p><p>Another JS/TS feature that I really embraced was Iterators and Generators. Say you have a <code>sum</code> function that takes an array of numbers:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>What if you want this to accept the output of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">squares</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">yield</span> n ** <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript will give you an error if you try to compose these:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));<br><span class="hljs-comment">//                 ~~~~~~~~~~ Argument of type &#x27;Generator&lt;number, void, unknown&gt;&#x27;</span><br><span class="hljs-comment">//                            is not assignable to parameter of type &#x27;number[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>Interestingly, though, this works at runtime and gives the correct answer (125)! To make it type check, we just need to loosen the parameter type for <code>sum</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: Iterable&lt;<span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Whenever I write functions that accept arrays now, I&#39;m going to ask &quot;could this take an Iterable instead?&quot; Often the answer is yes, and this gives you more flexibility in how you call the function. I found this particularly nice for callbacks that returned arrays, which are often cleaner to write as generators. See <a href="https://github.com/danvk/aoc2022/commit/c81b90e25db7617f42f8e78d6b76276f9c8a039c">this commit</a>.</p><p>Iterators are a great feature, but they are somewhat held back by their <a href="https://github.com/lodash/lodash/issues/737">lack of support</a> in lodash. There&#39;s a TC39 proposal to add <a href="https://2ality.com/2022/12/iterator-helpers.html">iterator helpers</a> to the standard library.</p><p>Because JavaScript doesn&#39;t have a built-in <a href="https://immutable-js.com/docs/v4.2.2/List/">deque</a> structure, I just used an <code>Array</code> in a very suboptimal way when I implemented <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. After wrapping up the whole competition, I tried <a href="https://github.com/danvk/aoc2022/compare/57c04a892ca52a1909d872e674984d557a59c86e...08f25f52ef4d018094a08df92c38dd8f15a87aae">plugging in</a> a priority queue. Suddenly some of my code ran 100x faster! Asymptotic performance: sometimes it matters!</p><p>Overall using TypeScript for the Advent of Code was OK but not great. It was a good excuse to try out a few new features of JavaScript, but it left me really wanting a few other proposals to get adopted!</p><h2 id="Advent-of-Code-2022"><a href="#Advent-of-Code-2022" class="headerlink" title="Advent of Code 2022"></a>Advent of Code 2022</h2><p>This was probably the easiest Advent of Code I&#39;ve done (easier than 2018, 2019, 2020, 2021). Again, there were no dependencies between days. There was also no matrix math, which was a change from previous years.</p><p>I usually do some kind of warmup project in a new language before day 1, traditionally implementing a <a href="https://github.com/danvk/rusty-boggle">Boggle Solver</a>. Since I&#39;d already implemented <a href="https://github.com/danvk/bogglets">Boggle in TypeScript</a>, I decided to do the first few puzzles of the 2018 Advent of Code instead. This was fun and very effective at preparing me for the 2022 Advent of Code. But it was a dangerous decision! Once I started the 2018 puzzles, I couldn&#39;t stop. So I wound up doing two Advents of Code simultaneously. This really highlighted that the 2018 Advent of Code was more difficult than 2022.</p><p>I tend to solve AoC problems in the morning: I&#39;m usually asleep well before midnight when they&#39;re posted on the east coast. But I&#39;d always been curious to try solving one at midnight to see what my global rank would be. I finally did it on day 15 this year. It was a roller coaster experience. Debugging while sleepy was unpleasant and really took me back to college. But I did manage to finish both parts before 1 AM and got my first-ever top 1000 finish:</p><p><img src="/images/aoc2022/rank-831.png" alt="Rank #831 on Day 15 part 2"></p><p>I was lucky -- had I tried this on day 16, which was much harder, I would have been up until 3 AM! Falling asleep after racing to solve a puzzle isn&#39;t easy.</p><p>I&#39;d hoped to stay up late enough to solve the final puzzle live. I was in Costa Rica at that point so it only would have been 11 PM and the Christmas is usually an easy puzzle. But by 10 PM I was in bed and couldn&#39;t keep my eyes open, so I just wrapped things up the next morning. I was finisher #5127 overall.</p><p>There were a few standout problems this year:</p><p><img src="/images/aoc2022/dans-cube.jpg" alt="My cube for day 222"></p><ul><li><a href="https://github.com/danvk/aoc2022#day-22-8786--4298">Day 22</a>: The Cube. Not hard, just very annoying. Though I did enjoy seeing photos of everyone&#39;s <a href="https://www.reddit.com/r/adventofcode/comments/zsct8w/2022_day_22_solutions/">cubes</a>.</li><li><a href="https://github.com/danvk/aoc2022#day-24-6284--6073">Day 24</a>: Blizzards, a fun application of Dijkstra where the state space isn&#39;t just your coordinate.</li><li><a href="https://github.com/danvk/aoc2022#day-20-7780--6961">Day 20</a>: Memorable for a pernicious off-by-one error.</li><li><a href="https://github.com/danvk/aoc2022#day-19-7649--6570">Day 19</a>: Robot Factories. This was the hardest one of the year for me. I never produced a fully correct solution, but I did discover <a href="https://en.wikipedia.org/wiki/Beam_search">beam search</a> which is something that will stick with me.</li><li><a href="https://github.com/danvk/aoc2022#day-16-6564--4162">Day 16</a>: Valves; this was probably the second hardest problem.</li><li><a href="https://github.com/danvk/aoc2022#day-9-31369--23800">Day 9</a>: Snake; really have to trust your implementation on this one. I was very glad to not have a bug!</li></ul><p>Overall, though, my favorite problem was probably <a href="https://adventofcode.com/2018/day/23">2018 day 23</a>.</p><p>So there you have it, Advent of Code 2022 in Deno. See you next December (or maybe April!).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;Every year I do the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt; in a different programming language. If you aren&amp;#39;t familiar, it&amp;#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&amp;#39;s a great way to learn a language and bond over coding. In &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;2019&lt;/a&gt; I used Python, in &lt;a href=&quot;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&quot;&gt;2020&lt;/a&gt; I used Rust and in &lt;a href=&quot;https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/&quot;&gt;2021&lt;/a&gt; I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&amp;#39;s 2022! (As a partial excuse, I have been writing on a &lt;a href=&quot;https://danvk.org/catskills/&quot;&gt;very different blog&lt;/a&gt;!)&lt;/p&gt;
&lt;p&gt;This past December I chose TypeScript, specifically &lt;a href=&quot;https://deno.land&quot;&gt;Deno&lt;/a&gt;, which &lt;a href=&quot;https://www.youtube.com/watch?v=1gIiZfSbEAE&quot;&gt;brands itself&lt;/a&gt; as &amp;quot;a new way to TypeScript&amp;quot;. While TypeScript certainly isn&amp;#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&amp;#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.&lt;/p&gt;
&lt;p&gt;This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&amp;#39;s Advent of Code.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Notes on TypeScript 5.0 beta</title>
    <link href="https://effectivetypescript.com/2023/02/07/ts-50-beta/"/>
    <id>https://effectivetypescript.com/2023/02/07/ts-50-beta/</id>
    <published>2023-02-08T01:50:00.000Z</published>
    <updated>2023-06-27T19:46:20.403Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">TypeScript 5.0 beta</a> came out on January 26, 2023. Let&#39;s take a look at what&#39;s new!</p><span id="more"></span><h2 id="Why-not-TypeScript-4-10"><a href="#Why-not-TypeScript-4-10" class="headerlink" title="Why not TypeScript 4.10?"></a>Why not TypeScript 4.10?</h2><p>First, a note on version numbers. With <a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning</a>, a change in the major version typically means breaking changes. And the number after 4.9 is 4.10, not 5.0. TypeScript doesn&#39;t really do semantic versioning. The whole <em>point</em> of new TypeScript releases is to find (existing) issues in your code. So in that sense, each release contains breaking changes.</p><p>Microsoft also counts in decimal. The version after 4.9 is 5.0, not 4.10. This causes some pain every tenth release since many packages on npm declare that they require <code>typescript@4.x</code>. This can either hold you back on an old version of TypeScript or lead to fragmentation, as I noticed with TypeScript 4.0 back in 2020:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">TIL I have five copies of <a href="https://twitter.com/typescript?ref_src=twsrc%5Etfw">@typescript</a> in node_modules! <a href="https://twitter.com/orta?ref_src=twsrc%5Etfw">@orta</a> was there much debate about whether the version after 3.9 was 3.10 or 4.0? In terms of branding and math, I agree it&#39;s 4.0. But since so many packages pin tsc@~3, this seems unnecessarily disruptive‚Ä¶ <a href="https://t.co/FBiAxZBM15">pic.twitter.com/FBiAxZBM15</a></p>&mdash; Dan Vanderkam (@danvdk) <a href="https://twitter.com/danvdk/status/1319652924050595841?ref_src=twsrc%5Etfw">October 23, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>Why doesn&#39;t TypeScript do versioning in the usual way? The <a href="https://github.com/Microsoft/TypeScript/issues/14116">definitive answer</a> comes from TypeScript Tech Lead Ryan Cavanaugh:</p><blockquote><p>The trade-off for getting millions of dollars of engineering investment in the TypeScript project is that marketing gets to control version numbers to a certain extent.</p></blockquote><p>So there you go. Every 2.5 years we have to deal with this extra pain. At least marketing didn&#39;t decide that the version after 3.1 was 95!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Every new version of TypeScript has the potential to surface new errors in your code. As long-time readers of this blog know, the code samples in <em>Effective TypeScript</em> <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">are all type-checked</a>. One of the benefits of this is that when new TS versions come out, I can type-check my book against them. Sometimes I learn that <a href="https://twitter.com/danvdk/status/1414343269522227207">my book is out of date</a> and sometimes I <a href="https://twitter.com/danvdk/status/1513629136790634497">find new bugs in TypeScript</a>.</p><p>TypeScript 5.0 didn&#39;t surface any new errors in <em>Effective TypeScript</em>. Huzzah! üéâ</p><p>There <em>were</em> a few new errors in my work project. All of them involved <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#forbidden-implicit-coercions-in-relational-operators">comparing <code>string|number</code> to <code>number</code></a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">error TS2365: Operator &#39;&gt;&#x3D;&#39; cannot be applied to types &#39;string | number&#39; and &#39;number&#39;.<br><br>96       (val &gt;&#x3D; minVal) &amp;&amp;<br>          ~~~~~~~~~~~~~<br></code></pre></td></tr></table></figure><p>The full code looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (val &gt;= minVal &amp;&amp; val &lt;= maxVal) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here <code>val</code> has type <code>string | number</code> while <code>minVal</code> and <code>maxVal</code> have type <code>number</code>. JavaScript is notoriously eager to coerce types so that operations make sense:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; 10 &gt; &quot;9&quot;<br>true<br>&gt; 10 &gt; &quot;x&quot;<br>false<br></code></pre></td></tr></table></figure><p>Not helpful, JS! TypeScript has always barred comparisons between strings and numbers. Now the noose has tightened just a bit more and you may have to be more explicit about conversions.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>The TypeScript team claims a <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">10-20% speedup in build times</a> with TypeScript 5.0 beta. I was able to confirm this both on my work project (<a href="https://delve.sidewalklabs.com">Delve</a>) and in running literate-ts against <em>Effective TypeScript</em>:</p><ul><li>literate-ts / Effective TypeScript:<ul><li>TS 4.9.5: 194.12s</li><li>TS 5.0-beta: 181.31s (6.6% speedup)</li></ul></li><li>Delve:<ul><li>TS 4.9.5: 46.36s</li><li>TS 5.0-beta: 38.27s (17.5% speedup)</li></ul></li></ul><p>Compiler speed is <a href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/">important</a> and these are both welcome improvements! You can read the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">release notes</a> for more details on how these speedups were achieved.</p><h2 id="const-type-parameters"><a href="#const-type-parameters" class="headerlink" title="const type parameters"></a><code>const</code> type parameters</h2><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#const-type-parameters"><code>const</code> type parameters</a> are the one new language feature in this release. These are like <code>as const</code> but applied on the function declaration, rather than at the call site.</p><p>The applications I see for this in my own code are mostly small quality of life wins. For example, my work project has a <code>DropdownList</code> component that takes a list of options and a selected option. The list of options should be a tuple of string literals, and the selected option should be one of those literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    dropdownOptions=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>With TypeScript 5.0 we can move the <code>const</code> into the declaration of <code>DropdownList</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> DropdownList = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">const</span> <span class="hljs-attr">DropdownOption</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">string</span>&gt;</span>(</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    options: readonly DropdownOption[];</span><br><span class="xml">    selectedOption: DropdownOption;</span><br><span class="xml">  &#125;</span><br><span class="xml">) =&gt; &#123;</span><br><span class="xml">  // ...</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>And drop the <code>as const</code> at the callsite:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    options=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>]&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you inspect <code>options</code> here, you can see that its type is inferred as <code>readonly (&quot;Option A&quot; | &quot;Option B&quot; | &quot;Option C&quot;)[]</code> whereas before it would have been inferred as <code>readonly string[]</code>. Nice! If you factor the list of options out into a variable, though, the context will be lost and you&#39;ll be back to using <code>as const</code>.</p><p>What else is this useful for? Back in 2020 I talked about the <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/"><code>tuple</code> helper function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>[]&gt;</span>(...args: T): T =&gt; args;</span><br><br><span class="xml">const p1 = [1, 2];  // type is number[]</span><br><span class="xml">const p1 = tuple(3, 4);  // type is [number, number]</span><br></code></pre></td></tr></table></figure><p>What if we use a <code>const</code> type parameter on <code>tuple</code>? Interestingly, it becomes a sort of &quot;deep tuple&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tuple</span>&lt;<span class="hljs-title">const</span> <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">unknown</span>[]&gt;(<span class="hljs-params">...x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">const</span> coords1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br><span class="hljs-comment">//    ^? number[][]</span><br><br><span class="hljs-keyword">const</span> coords2 = tuple([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><span class="hljs-comment">//    ^? readonly [readonly [1, 2], readonly [3, 4], readonly [5, 6]]</span><br></code></pre></td></tr></table></figure><p>Is this useful? Maybe. There are always compelling applications of new language features and I&#39;m sure I&#39;m missing some here. Do you have a use for <code>const</code> type parameters? Let me know in the comments!</p><h2 id="Enums-are-unions"><a href="#Enums-are-unions" class="headerlink" title="Enums are unions"></a>Enums are unions</h2><p>In <em>Effective TypeScript</em> Item 53 (&quot;Prefer ECMAScript Features to TypeScript Features&quot;) I discourage using enums since they&#39;re not an ECMAScript feature and generally break the mold of how TypeScript relates to JavaScript (&quot;JavaScript + Types&quot;).</p><p>With TypeScript 5.0, enums become a little more sane. Whereas this <a href="https://www.typescriptlang.org/play?ts=4.9.5#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">was OK</a> in TypeScript 4.9:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> E &#123;<br>  a = <span class="hljs-number">1</span>,<br>  b = <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>It&#39;s <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">an error</a> in TypeScript 5.0:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;<br><span class="hljs-comment">//    ~ Type &#x27;30&#x27; is not assignable to type &#x27;E&#x27;. (2322)</span><br></code></pre></td></tr></table></figure><p>So are enums OK now? As it turns out, the newfound sanity is <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iiANsAC5QikDMADANyIDGA9iADOTYAC5YpEJxQB6GVD4BrKKIAUiIA">only surface deep</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> n = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> e: E = n;  <span class="hljs-comment">// ok :(</span><br></code></pre></td></tr></table></figure><p>TypeScript enums are complicated and problematic. While they become slightly saner with TypeScript 5.0, I still say &quot;avoid them.&quot;</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>There are more changes in the new release than what I&#39;ve written about here. Check out the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">release notes</a> for full details. With any luck, a release candidate (RC) will arrive on February 28th and the final cut of TypeScript 5.0 will be out on March 14th.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/&quot;&gt;TypeScript 5.0 beta&lt;/a&gt; came out on January 26, 2023. Let&amp;#39;s take a look at what&amp;#39;s new!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>All I Want for Christmas Is‚Ä¶ These Seven TypeScript Improvements</title>
    <link href="https://effectivetypescript.com/2022/12/25/christmas/"/>
    <id>https://effectivetypescript.com/2022/12/25/christmas/</id>
    <published>2022-12-25T19:00:00.000Z</published>
    <updated>2022-12-25T20:26:56.229Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://freesvg.org/vector-clip-art-of-cartoon-presents-under-christmas-tree"><img src="https://effectivetypescript.com/images/christmas-tree.png" width="200" height="200" style="float: right" alt="Christmas tree with presents"></a> It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s <a href="https://adventofcode.com">Advent of Code</a> in Deno (look forward to a blog post in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?</p><h2 id="A-faster-language-service"><a href="#A-faster-language-service" class="headerlink" title="A faster language service"></a>A faster language service</h2><p>When you install TypeScript, you get two executables:</p><ul><li><code>tsc</code>, which checks your code for type errors and converts it to executable JavaScript</li><li><code>tsserver</code>, which provides language services for your editor.</li></ul><p>(This is discussed in Item 6 of <em>Effective TypeScript</em>: Use Your Editor to Interrogate and Explore the Type System.)</p><p>The faster these two programs can do their job, the happier you&#39;ll be as a developer. The TypeScript team is acutely aware of this: the release notes for new versions of TypeScript always talk about performance improvements in addition to new language features. The sluggishness of <code>tsc</code> remains a pain point for many developers, though. One of them even got so frustrated that he <a href="https://www.totaltypescript.com/rewriting-typescript-in-rust">decided to rewrite <code>tsc</code> in Rust!</a>.</p><p>Personally, I don&#39;t care much about the performance of <code>tsc</code>. I only tend to run as part of a continuous integration service or in &quot;watch&quot; mode without type checking via <code>webpack</code> or <code>ts-node</code>. The performance there is good enough for me.</p><p>What I <em>do</em> care about is the performance of <code>tsserver</code>. When you apply a refactor or change a type and have to wait for the red squiggly lines to catch up, that&#39;s <code>tsserver</code> being slow. Here&#39;s a GIF showing the language service having trouble keeping up:</p><img src="https://effectivetypescript.com/images/sluggish-ts-comment-with-user.gif" with=636 height=488 alt="A type error appearing and disappearing slowly after changing an import" style="max-height: 488px"><p>These performance issues impact your moment-to-moment experience of TypeScript: did that red squiggle go away because I fixed the error, or because I&#39;m waiting for <code>tsserver</code> to catch up? They&#39;re also hard to isolate for a bug report. If <code>tsc</code> is slow, I can point the TS team at my repo and report how long <code>tsc</code> takes to run. But to reproduce language server issues, you have to open a repo in your editor and then perform a particular action. It&#39;s not automated. And performance is inconsistent since it depends on caching.</p><p>So for 2023, I&#39;d love to see a faster <code>tsserver</code>. Maybe we should rewrite that in Rust, too!</p><h2 id="A-typed-pipe"><a href="#A-typed-pipe" class="headerlink" title="A typed pipe"></a>A typed <code>pipe</code></h2><p>When you compose several functions:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">f(g(h(x)))<br></code></pre></td></tr></table></figure><p>the functions are run in the right-to-left order: first <code>h</code> then <code>g</code> then <code>f</code>. This is counter to how code typically executes: top to bottom, left to right.</p><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">pipeline proposal</a> aims to offer a more readable alternative by introducing a new operator, <code>|&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">x<br>|&gt; h<br>|&gt; g<br>|&gt; f<br></code></pre></td></tr></table></figure><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">proposal page</a> has lots of great material about why this is a good idea and is well worth reading. Unfortunately, though, there are two competing operator proposals and I don&#39;t anticipate this making it into JavaScript (and hence TypeScript) anytime soon. Axel Rauschmayer&#39;s blog has a good writeup on the <a href="https://2ality.com/2022/01/pipe-operator.html">current state of things</a>.</p><p>There&#39;s an alternative, though: we can implement a function (commonly called <a href="https://ramdajs.com/docs/#pipe"><code>pipe</code></a>, or <a href="https://lodash.com/docs/4.17.15#flow"><code>flow</code></a> in lodash) that composes the functions in the order we expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n ** <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> add1 = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> halve = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> f = pipe(square, add1, halve, <span class="hljs-built_in">String</span>);<br><span class="hljs-comment">//    ^? (arg: number) =&gt; string</span><br><span class="hljs-keyword">const</span> x = f(<span class="hljs-number">2</span>);  <span class="hljs-comment">// &quot;2.5&quot;</span><br></code></pre></td></tr></table></figure><p>Here <code>square</code> is applied first, then <code>add1</code>, then <code>halve</code> and finally <code>String</code> to convert the number to a <code>string</code>.</p><p>This solves the pipelining problem nicely but it has a problem: it&#39;s impossible to type. For details, see this <a href="https://github.com/microsoft/TypeScript/pull/39094#issuecomment-647042984">Anders comment</a>. The issue is that there needs to be a relationship between each of the arguments to <code>pipe</code>: the parameter type of each argument needs to match the return type of the previous one. And this just can&#39;t be modeled with TS.</p><p>The lodash and Ramda typings resort to the classic <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#:~:text=like%20to%20call%20%E2%80%9C-,death%20by%20a%20thousand%20overloads,-%E2%80%9D%2C%20and%20it%20doesn%E2%80%99t">&quot;death by a thousand overloads&quot;</a> solution: define safe versions for a small number of arguments (<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/266cf9b006800a1de3836257443920b828c2e589/types/lodash/common/util.d.ts#L169-L204">seven</a> in lodash&#39;s case, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/76ebb1cce06b08cc5ef2f31d718fd84cb9df7cc6/types/ramda/index.d.ts#L1458-L1513">ten in Ramda&#39;s</a>) and give up on typing larger invocations.</p><p>This probably works fine in 99% of cases, but it doesn&#39;t feel right! I&#39;d love to see the TypeScript type system expand to be able to type <code>pipe</code>, or see some form of the pipeline operator proposal adopted.</p><h2 id="Records-and-Tuples"><a href="#Records-and-Tuples" class="headerlink" title="Records and Tuples"></a>Records and Tuples</h2><p>I&#39;m cheating here since this is more of a JavaScript Christmas wish. But JS is TS, right? The <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a>, currently at Stage 2, seeks to add two new data structures to JavaScript. As the proposal puts it:</p><blockquote><p>This proposal introduces two new deeply immutable data structures to JavaScript:</p><ul><li><code>Record</code>, a deeply immutable Object-like structure #{ x: 1, y: 2 }</li><li><code>Tuple</code>, a deeply immutable Array-like structure #[1, 2, 3, 4]</li></ul></blockquote><p>TypeScript already has a notion of tuple <em>types</em> (<code>[number, number]</code>). This proposal would add tuple values, which would neatly resolve a number of ambiguities in type inference.</p><p>For example, if you write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>then what should the type of <code>pt</code> be? It could be:</p><ul><li>a tuple type (<code>[number, number]</code>)</li><li>a readonly type (<code>readonly [number, number]</code>)</li><li>a mutable list (<code>number[]</code>)</li><li>an immutable list (<code>readonly number[]</code>)</li></ul><p>Without more information, TypeScript has to guess. In this case it infers the mutable list, <code>number[]</code>. You can use a <a href="https://stackoverflow.com/questions/66993264/what-does-the-as-const-mean-in-typescript-and-what-is-its-use-case">const assertion</a> (<code>as const</code>) to get (<code>readonly [number, number]</code>) or a <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/">typed identity function</a> to get one of the others.</p><p>With this proposal, you&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>and it would be unambiguous that you want a tuple type. This is just the tip of the iceberg: functional programming and static typing work much better when you don&#39;t have to worry about mutability (see Item 27 of <em>Effective TypeScript</em>: Use Functional Constructs and Libraries to Help Types Flow).</p><p>The other great thing about this proposal is that we&#39;d be able to use <code>===</code> to do structural comparisons between tuples and records:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br>&gt; #[1, 2] &#x3D;&#x3D;&#x3D; #[1, 2]<br>true<br></code></pre></td></tr></table></figure><p>The first comparison is <code>false</code> because the two arrays aren&#39;t the same object. Tuples have a more intuitive behavior. There is some risk of the Array / Tuple distinction being confusing, but Python has this and generally it works great.</p><p>We&#39;d also be able to use tuples as keys in <code>Set</code> and <code>Map</code> structures. This is top of mind because tuples would have been wildly useful in the Advent of Code this year (see my <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">2020 post</a> about using tuples as <code>dict</code> keys in Python).</p><h2 id="Optional-generics"><a href="#Optional-generics" class="headerlink" title="Optional generics"></a>Optional generics</h2><p>While building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> and <a href="https://github.com/danvk/crudely-typed">crudely-typed</a> libraries, I frequently ran into this situation: you have a function that takes several generic arguments, you want the user to provide one of them explicitly, but you want TypeScript to infer the others.</p><p>Here&#39;s an example of what this would like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeLookup</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">k: K</span>): (<span class="hljs-params">obj: T</span>) =&gt; <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">obj: T</span>) =&gt;</span> obj[k];<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> lookupName = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupName: (obj: Student) =&gt; string;</span><br><span class="hljs-keyword">const</span> lookupAge = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupAge: (obj: Student) =&gt; number;</span><br></code></pre></td></tr></table></figure><p>TypeScript doesn&#39;t let you do this. If you <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYGsCmAZOd0gAOAPACoA0iA0opgB5SZgAmAzolgJ5zCKkB8ACnQAuagEoxguACMAVmNLjEAXn58A2lQC6iAN4BYAFCJEAJ0xQQZpNPmLlaxLLkb02gNzGAvseMwwRjNgVAhMRABlK2YmKH1jUzBUZEwxVigzAIBzLxNEVCzUxDAQZBlMM1zfI2MIBHTEABs8AkIAOWTwlRQMHBaiYiiQGMChAHIklLHxXIB6WdNTAD0AfkQ6sAbm-CIOlKkXMSGRqEd1dMywHNr6uO3WgEFC1R6sXB2SY9jxgsxpuYWi1W61uTX6hCeRTsCki0ViZ2KpXKlSAA">try it on the TypeScript playground</a> you&#39;ll get this error: &quot;Expected 2 type arguments, but got 1.&quot; Generics are all or nothing.</p><p>I wrote about two workarounds back in 2020: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a>. But these are workarounds. I&#39;d really love to have a way to do this without having to change my API!</p><p>The canonical issue for this feature request is <a href="https://github.com/microsoft/TypeScript/issues/10571">#10571</a>. There was <a href="https://github.com/microsoft/TypeScript/pull/26349">some work on it in 2018</a> and I put up a <a href="https://github.com/microsoft/TypeScript/issues/42388">proposal</a> two years ago, but it hasn&#39;t seen much attention recently.</p><h2 id="quot-Evolving-quot-function-types"><a href="#quot-Evolving-quot-function-types" class="headerlink" title="&quot;Evolving&quot; function types"></a>&quot;Evolving&quot; function types</h2><p>TypeScript typically does a great job of inferring function parameter types from whatever context it has:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">//                            ^? (parameter) x: number</span><br></code></pre></td></tr></table></figure><p>The key point here is that you don&#39;t need to write <code>(x: number) =&gt; x ** 2</code>: TypeScript is able to infer that <code>x</code> is of type <code>number</code> from the types of <code>[1, 2, 3]</code> and the type of <code>Array.prototype.map</code>.</p><p>Now try factoring out a <code>square</code> function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Parameter &#x27;x&#x27; implicitly has an &#x27;any&#x27; type. (7006)</span><br><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(square);<br></code></pre></td></tr></table></figure><p>What worked so well in the first example completely fails here. This code is correct and is a simple refactor of the other code, but TypeScript demands a type annotation here. This is a frequent source of frustration in React components, where factoring out a callback can require writing out some very complex types. I wrote a blog post about this in 2019: <a href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/">How TypeScript breaks referential transparency‚Ä¶and what to do about it</a>.</p><p>Why doesn&#39;t TypeScript infer the type of <code>square</code> (and hence <code>x</code>) from its usage on the next line? Anders is famously skeptical of &quot;spooky action at a distance&quot; where changing code in one place can cause a type to change and produce errors in other places that aren&#39;t obviously related.</p><p>But it does have one limited form of this: &quot;evolving <code>any</code>&quot;, which is discussed in <em>Effective TypeScript</em> Item 41: <a href="https://effectivetypescript.com/2020/03/09/evolving-any/">Understand Evolving any</a>. The gist is that TypeScript will sometimes let the type of a symbol change based on subsequent usage:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> out = [];<br>out.push(<span class="hljs-number">1</span>);<br>out.push(<span class="hljs-number">2</span>);<br> out<br><span class="hljs-comment">// ^? const out: number[]</span><br></code></pre></td></tr></table></figure><p>I have a <a href="https://github.com/microsoft/TypeScript/issues/38083">three year old proposal</a> to expand this behavior to local function variables and make the <code>square</code> example valid. React developers around the world don&#39;t know that they want this feature for Christmas, but they do!</p><h2 id="ES-Module-clarity"><a href="#ES-Module-clarity" class="headerlink" title="ES Module clarity"></a>ES Module clarity</h2><p>The JavaScript world is finally moving to ES modules (<code>import</code> and <code>export</code>). I&#39;ve been blissfully ignoring some of the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#control-over-module-detection">changes</a> that Node.js and TypeScript have been making to support them, but I get the <a href="https://github.com/microsoft/TypeScript/issues/51302">sense</a> that this is an awkward transition for both of them. Hopefully we&#39;ll be through this by the end of 2023!</p><h2 id="A-canonical-types-‚Üí-runtime-path"><a href="#A-canonical-types-‚Üí-runtime-path" class="headerlink" title="A canonical types ‚Üí runtime path"></a>A canonical types ‚Üí runtime path</h2><p>One of the keys to really understanding TypeScript is recognizing that TypeScript types don&#39;t exist at runtime. They are <em>erased</em>. This is so fundamental that it&#39;s Item 1 in <em>Effective TypeScript</em> (&quot;Understand the Relationship Between TypeScript and JavaScript&quot;).</p><p>But sometimes you really do want access to your TypeScript types at runtime, perhaps to do validation on untrusted inputs. There&#39;s a proliferation of libraries that let you define types in JavaScript and derive TypeScript types from them: <a href="https://github.com/colinhacks/zod">zod</a>, <a href="https://github.com/jquense/yup">yup</a>, <a href="https://github.com/gcanti/io-ts">io-ts</a> and <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">React PropTypes</a> are just a few. Here&#39;s how you&#39;d define a <code>Student</code> type with Zod, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Student = z.object(&#123;<br>  name: z.string(),<br>  age: z.number(),<br>&#125;);<br><br><span class="hljs-keyword">type</span> Student = z.infer&lt;<span class="hljs-keyword">typeof</span> Student&gt;;<br><span class="hljs-comment">// type Student = &#123; name: string; age: number; &#125;</span><br></code></pre></td></tr></table></figure><p>The advantage of defining a type in this way (rather than with a TypeScript <code>interface</code>) is that you can do runtime validation using the <code>Student</code> value (which you cannot do with the <code>Student</code> <em>type</em>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> missingAge = Student.parse(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bobby&quot;</span>&#125;);<br><span class="hljs-comment">// throws an error at runtime.</span><br></code></pre></td></tr></table></figure><p>I prefer a different approach, though. TypeScript already has a great language for defining types and the relationships between them. Why learn another one? In <a href="https://github.com/danvk/crosswalk">crosswalk</a>, I use <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a> to generate JSON Schema from my TypeScript type declarations. This JSON Schema is used to validate requests and generate Swagger/OpenAPI documentation.</p><p>But again, all these approaches are workarounds for the root issue: there&#39;s no way to get access to a TypeScript type at runtime. I&#39;d love it if there were a canonical solution to this problem, so that we could all use the same solution. Perhaps <a href="https://2ality.com/2022/10/javascript-decorators.html">decorators</a> can help.</p><p>This would be a big change for TypeScript, and would generally go against its design philosophy. So while I have some hope for my other wishes, I have very little hope for this last one.</p><hr><p>Would you be excited about any of these changes? What&#39;s on the top of your TypeScript Christmas list? Let me know in the comments or <a href="https://twitter.com/danvdk">on Twitter</a>.</p>]]></content>
    
    <summary type="html">
    
      It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s Advent of Code in Deno (look forward to a blog post in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>What&#39;s TypeScript compiling? Use a treemap to find out.</title>
    <link href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/"/>
    <id>https://effectivetypescript.com/2022/07/30/treemap-for-source-files/</id>
    <published>2022-07-30T18:30:00.000Z</published>
    <updated>2022-07-30T18:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>What would you be most excited to see in the next set of TypeScript <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/">release notes</a>? Perhaps a fancy new language feature that makes generic types <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">more powerful</a>? A new way to do <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">type inference</a>? Or maybe a <a href="https://github.com/microsoft/TypeScript/issues/29988">new refactor</a> in the language service?</p><p>Now would you rather have that shiny new feature, or would you rather have TypeScript build your code 20% faster? In terms of your daily happiness and productivity, the speedup will almost certainly be the bigger win.</p><p>TypeScript performance is an important and sometimes frustrating part of the developer experience. Projects tend to start small and fast, but as they grow, type checking (<code>tsc</code>) and editor interactions (<code>tsserver</code>) get slower and TypeScript becomes less of a joy to use.</p><p>How can you make TypeScript run faster? Microsoft has a <a href="https://github.com/microsoft/TypeScript/wiki/Performance">guide</a> to TypeScript performance, and that&#39;s a great place to start. This post will talk about one particularly easy and effective way to debug performance issues: looking at what TypeScript is compiling using a treemap visualization.</p><p>Before we get started, let&#39;s be clear what we mean by performance. This is <em>not</em> the runtime performance of your code. For the most part, TypeScript is compiled to JavaScript by stripping out all the type annotations. So it cannot affect the runtime performance of your code. (If you see claims that TS affects runtime performance, for example this <a href="https://hackaday.com/2021/11/18/c-is-the-greenest-programming-language/">notoriously shoddy</a> paper, be very skeptical!) When I say &quot;performance&quot;, I mean compiler performance and language service performance: How long does it take <code>tsc</code> to compile your code and report type errors? And how long does it take after you edit a source file for errors to appear and disapper in your editor? These affect developer experience (DX) directly, but not user experience (UX).</p><p>One of the best ways to be fast is to do less stuff. In the case of TypeScript, that means compiling fewer lines of code.</p><p>The <code>tsc</code> command has a handy <code>--listFiles</code> option that will show you exactly what it&#39;s looking at when it compiles your code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ tsc --listFiles<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2015.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2016.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2017.d.ts<br>...<br></code></pre></td></tr></table></figure><p>If TypeScript has gotten sluggish on your project, then you should look at this list! There might be source files that surprise you.</p><p>For a large project, this list can include thousands of source files, so you&#39;ll want some way to visualize it. My preferred approach is a <a href="https://en.wikipedia.org/wiki/Treemapping">treemap</a>, which you can quickly generate using the <a href="https://www.npmjs.com/package/webtreemap-cli">webtreemap-cli</a> package. Since <code>tsc</code> will spend more time on a large file than a small file, we&#39;ll want to visualize the number of bytes in each file being compiled.</p><p>Here&#39;s the magic incantation (see <a href="https://unix.stackexchange.com/a/22227/139786">here</a> for the &quot;stat&quot; syntax):</p><pre><code># macOS / BSDtsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli# Linux:tsc --noEmit --listFiles | xargs stat -c &quot;%s %n&quot; | npx webtreemap-cli</code></pre><p>For my project, here&#39;s what that looks like:</p><img src="https://effectivetypescript.com/images/googleapis-treemap.png" alt="Treemap visualization showing googleapis contribution 80MB of source" style="max-height: 458px; max-width: 100%" /><p>First off: that&#39;s a <em>lot</em> of code! Over 111 megabytes. With that much source to churn through, it&#39;s no wonder TypeScript has gotten sluggish.</p><p>Second: my project is mostly <code>googleapis</code>? That&#39;s surprising. We do use the Google Cloud Storage API and the Google Sheets API, but that&#39;s it. And yet <code>tsc</code> reports that it&#39;s pulling in 80+ MB of Google APIs, including multiple versions of APIs that I never use (e.g. compute alpha, beta, v1).</p><p>This is exactly the sort of insight that treemaps are good at producing! Before I saw that visualization, I hadn&#39;t thought much about my project&#39;s usage of <code>googleapis</code>. Now I can&#39;t think about anything else!</p><p>The root issue here is that Google distributes all 300+ of its APIs as a single npm package. This has been a <a href="https://github.com/googleapis/google-api-nodejs-client/issues/806">long-standing issue</a> with Google&#39;s Node.js APIs. Fortunately for us, the issue was <a href="https://github.com/googleapis/google-api-nodejs-client/pull/2557">recently fixed</a>! Google now publishes individual packages for each API. Instead of depending on all of <code>googleapis</code>, you can now depend on just <code>@googleapis/sheets</code>.</p><p>After this change, the treemap for my project looks substantially different:</p><img src="https://effectivetypescript.com/images/treemap-after.png" alt="Treemap showing many fewer googleapis" style="max-height: 459px; max-width: 100%"/><p>The most important change is the top-line number: there&#39;s 80MB (70%) less source code for <code>tsc</code> to churn through. It&#39;s interesting to note that many of the large blocks that remain (<code>@octokit</code>, <code>csstype</code>, <code>firestore</code>) have the same problem as <code>googleapis</code>, if less egregiously so: they ship a single giant source file containing every API you could ever depend on.</p><p>Now for the big question‚Ä¶ did this make my build faster? At least in this case, the answer is a clear &quot;yes&quot;. I ran:</p><pre><code>time tsc --noEmit --incremental=false</code></pre><p>five times before and after my change. The average time went from 35.7s ‚Üí 28.9s, a 20% speedup. Not bad! And while it&#39;s harder to measure language service (<code>tsserver</code>) performance, one hopes that this change will help there, too. It&#39;s notable that the 20% speedup doesn&#39;t match the 70% reduction in source code. Just reading all those unused type declarations doesn&#39;t take as much time as type checking the code that is used. Still, this is a nice win.</p><p>Try running the magic command to visualize your TypeScript code as a treemap. You might be surprised what&#39;s making it into your build!</p><pre><code>tsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli</code></pre><p>In a future post, we&#39;ll look at strategies for reducing how much code you have to import, both as a library author and a consumer.</p>]]></content>
    
    <summary type="html">
    
      Has TypeScript gotten slow for you? Run this one magic command to visualize what TypeScript is compiling, and maybe get to the root of the issue.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A new way to test types</title>
    <link href="https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/"/>
    <id>https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/</id>
    <published>2022-05-28T21:55:00.000Z</published>
    <updated>2022-05-28T23:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Readers of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> and followers of this blog will know that testing types is a long-standing interest of mine:</p><ul><li><a href="https://github.com/danvk/typings-checker">typings-checker</a> (2017) implemented <code>$ExpectType</code> and <code>$ExpectError</code> directives and helped to influence <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, which is used to test types on DefinitelyTyped.</li><li>I gave a talk at TSConf 2019 entitled <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">Testing Types: An Introduction to dtslint</a>.</li><li>I included Item 52: Be Aware of the Pitfalls of Testing Types in <em>Effective TypeScript</em> (2019)</li><li>I created <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a> (2020) to type check Effective TypeScript and this blog.</li></ul><p>There are many tools out there for testing types, from tricks with <code>tsc</code> to <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, <a href="https://github.com/SamVerschueren/tsd">tsd</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. But I can&#39;t say I really love any of them. I&#39;ve always felt like I was writing tests because I should do it, rather than because it was fun and I wanted to.</p><p>When I started working on <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>, I wondered whether there might be a better way. In the years since <em>Effective TypeScript</em> came out, largely thanks to Orta&#39;s advocacy, <a href="https://shikijs.github.io/twoslash/">twoslash</a> has become a widespread standard. You can <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBGCuBbCMC8MDaBGANDATHgMx4AsAugNwCwAUKJLAB5pxIQB0ATgKYAm8YDwAUwpngCeASjQA+GCwDUMaTVoB6dTG0wAegH46QA">see this</a> on the TypeScript playground: if you write a twoslash comment (<code>// ^?</code>) then the TypeScript language service&#39;s &quot;quick info&quot; appears next to it:</p><img src="https://effectivetypescript.com/images/twoslash-play.png" title="twoslash comment showing an inferred type on the TypeScript playground" width="364" height="69" /><p>This <a href="https://twitter.com/danvdk/status/1505209336414547968">got me thinking</a>: what if we used this same syntax to do type assertions?</p><p>So rather than <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y); <span class="hljs-comment">// $ExpectType number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://github.com/SamVerschueren/tsd">tsd</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br>expectType&lt;<span class="hljs-built_in">number</span>&gt;(x);<br></code></pre></td></tr></table></figure><p>you could just write a twoslash comment:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">//    ^? const x: number</span><br></code></pre></td></tr></table></figure><p>And have something enforce that this comment matched the real Quick Info.</p><p>This has a few nice properties:</p><ol><li>It&#39;s a syntax that&#39;s already widely used.</li><li>It&#39;s unambiguous which symbol the assertion refers to: it&#39;s the one one the caret (<code>^</code>) points at. (This is a source of ambiguity for dtslint and literate-ts.)</li><li>It&#39;s clearly distinct from runtime code and is making an assertion about the <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a> of the type, rather than its structure. (Structural checks will happily let you replace a nice-looking type with something cryptic but equivalent, or even with <code>any</code>.)</li></ol><p>There was an existing eslint plugin, <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type"><code>eslint-plugin-expect-type</code></a>, which did something similar. So I set about <a href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/">adding support for twoslash syntax</a>. One really nice thing came out of this: eslint makes it easy to write and test auto-fixers, so doing type assertions has some of the same feel as Jest&#39;s <a href="https://jestjs.io/docs/snapshot-testing">snapshot testing</a>.</p><p>Here&#39;s a GIF of the autofixing in action:</p><p><img src="https://user-images.githubusercontent.com/98301/162592605-184fe6e5-e069-4a63-aa87-387f4e1b85df.gif" alt="Animation of eslint-plugin-expect-type filling in the correct type assertion"></p><p>More than anything else, this autofixer is what&#39;s made writing type tests fun!</p><p>Here&#39;s an example of a type test from <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedDb = <span class="hljs-keyword">new</span> TypedSQL(tables);<br><span class="hljs-keyword">const</span> docTable = typedDb.table(<span class="hljs-string">&#x27;doc&#x27;</span>);<br><span class="hljs-keyword">const</span> update = docTable.update(&#123;<span class="hljs-attr">where</span>: [<span class="hljs-string">&#x27;title&#x27;</span>]&#125;);<br><span class="hljs-comment">//    ^? const update: (db: Queryable, where: &#123;</span><br><span class="hljs-comment">//           title: string | null;</span><br><span class="hljs-comment">//       &#125;, update: Partial&lt;Doc&gt;) =&gt; Promise&lt;Doc[]&gt;</span><br><span class="hljs-keyword">const</span> newDoc = <span class="hljs-keyword">await</span> update(<br>    mockDb,<br>    &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Great Expectations&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">created_by</span>: <span class="hljs-string">&#x27;Charles Dickens&#x27;</span>&#125;,<br>);<br>newDoc;<br><span class="hljs-comment">// ^? const newDoc: Doc[]</span><br></code></pre></td></tr></table></figure><p>crudely-typed uses <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">many</a> of the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">fancy types</a> that I&#39;ve <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">written about</a> on this blog. But users of the library should never be aware of any of this chicanery. The types that come out should make sense in the context of the types that go in. They shouldn&#39;t require you to understand the internals of the library. It&#39;s easy to <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">accidentally break</a> this property while refactoring, for example to make the type of <code>newDoc</code> display as something more complicated than <code>Doc[]</code> in the example above. Testing how types <em>display</em> gives you the freedom to refactor without the fear that you&#39;ll inadvertently worsen the experience of your library&#39;s users. And the autofixer makes it a delight to do so!</p><p>If you&#39;re writing a TypeScript library that makes use of any heavy type machinery, I&#39;d highly recommend writing tests with <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type">eslint-plugin-expect-type</a>. You&#39;re using eslint already (you are, aren&#39;t you?) so adding this plugin it doesn&#39;t require new tooling. You can see examples of how to wire it up on <a href="https://github.com/danvk/crudely-typed/pull/18/files#diff-46e9201b2cf8dec2bcf89b7b86965fdbfe1210504118198f3b33b2cb9b94dc27">crudely-typed</a> and <a href="https://github.com/danvk/crosswalk/pull/35">crosswalk</a>.</p>]]></content>
    
    <summary type="html">
    
      Readers of Effective TypeScript and followers of this blog will know that testing types is a long-standing interest of mine. In this post I show how eslint-plugin-expect-type provides new syntax and tooling to make testing types so easy and fun that you&#39;ll &lt;i&gt;want&lt;/i&gt; to do it!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>My Twitch Debut (eslint-plugin-expect-type with Josh Goldberg)</title>
    <link href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/"/>
    <id>https://effectivetypescript.com/2022/04/18/twitch-expect-type/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-05-28T21:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/twitch-screengrab.jpg" title="Screengrab from Twitch" width="320" height="180" style="float: right; margin-left: 10px;">I made my <a href="https://www.twitch.tv/videos/1455722291">Twitch debut</a> last week with <a href="https://twitter.com/JoshuaKGoldberg">Josh Goldberg</a>, who&#39;s writing O&#39;Reilly&#39;s upcoming <a href="https://learning.oreilly.com/library/view/learning-typescript/9781098110321/"><em>Learning TypeScript</em></a> title.</p><p>We talked through a <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47">recent PR</a> I created to add TwoSlash support for Josh&#39;s expect-type eslint plugin. That syntax looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> four = <span class="hljs-number">4</span>;<br><span class="hljs-comment">//  ^? let four: number</span><br></code></pre></td></tr></table></figure><span id="more"></span><p>The eslint plugin will then check that TypeScript reports <code>let four: number</code> when you get quickinfo for <code>four</code>. This lets you write tests for <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">the display of types</a>. The idea is similar to <a href="https://github.com/microsoft/dtslint">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, but with a few key advantages:</p><ol><li>It uses a widely-adopted syntax (TwoSlash is even supported on the TypeScript playground).</li><li>It&#39;s implemented through an eslint plugin, so you don&#39;t need another tool to make type assertions.</li><li>It has an autofixer, which makes this pleasant to use.</li></ol><p>Once the PR is merged, this will be my new preferred way to test types, and I&#39;ll have to update the recommendations from my <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">TSConf 2019 talk</a> as well as Item 52 in <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> (&quot;Be Aware of the Pitfalls of Testing Types&quot;). I&#39;m already using it on my latest open source project, <a href="https://github.com/danvk/crudely-typed/">crudely-typed</a> (more on that soon!).</p><p>I had a great time chatting with Josh, and I think we both learned a thing or two. Hopefully you will, too!</p><!-- Add a placeholder for the Twitch embed --><div id="twitch-embed"></div><!-- Load the Twitch embed script --><script src="https://player.twitch.tv/js/embed/v1.js"></script><!-- Create a Twitch.Player object. This will render within the placeholder div --><script type="text/javascript">  new Twitch.Player("twitch-embed", {    video: "1455722291",    width: 620,    height: 378,    autoplay: false,  });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/twitch-screengrab.jpg&quot; title=&quot;Screengrab from Twitch&quot; width=&quot;320&quot; height=&quot;180&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;I made my &lt;a href=&quot;https://www.twitch.tv/videos/1455722291&quot;&gt;Twitch debut&lt;/a&gt; last week with &lt;a href=&quot;https://twitter.com/JoshuaKGoldberg&quot;&gt;Josh Goldberg&lt;/a&gt;, who&amp;#39;s writing O&amp;#39;Reilly&amp;#39;s upcoming &lt;a href=&quot;https://learning.oreilly.com/library/view/learning-typescript/9781098110321/&quot;&gt;&lt;em&gt;Learning TypeScript&lt;/em&gt;&lt;/a&gt; title.&lt;/p&gt;
&lt;p&gt;We talked through a &lt;a href=&quot;https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47&quot;&gt;recent PR&lt;/a&gt; I created to add TwoSlash support for Josh&amp;#39;s expect-type eslint plugin. That syntax looks like this:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; four = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//  ^? let four: number&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The display of types</title>
    <link href="https://effectivetypescript.com/2022/02/25/gentips-4-display/"/>
    <id>https://effectivetypescript.com/2022/02/25/gentips-4-display/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2022-02-28T14:14:19.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: The display of types</li></ul><p>We talk all the time about how to define and use types in TypeScript, but we rarely talk about how TypeScript chooses to <em>display</em> our types. There are often several possible ways to display the same type, and the choice can have a big impact on the usability of your library. TypeScript tries to make good decisions on its own about type display, but it also gives us a few levers by which we can control it ourselves.</p><p>Let&#39;s dive in to the strange world of type display!</p><!-- more --><p>Suppose you have a <code>Comments</code> table in your database and you&#39;ve defined a <code>selectComments</code> function. As you prepare to call it, TypeScript shows you some type information:</p><img src="https://effectivetypescript.com/images/type-bad.png" width="579" height="98" title="Cryptic type display"><p>This leaves something to be desired. One issue is that it feels a bit &quot;implementation-y&quot;: why should I care that the parameter is constructed using <code>Pick</code> and an intersection (<code>&amp;</code>)? It&#39;s also a bit opaque. Is <code>author_id</code> nullable? What about <code>metadata</code> in the return type? What&#39;s its type? And is <em>it</em> nullable?</p><p>It&#39;s hard to answer these questions without wading through some type declarations or experimenting.</p><p>Here&#39;s an alternative display of exactly the same types:</p><img src="https://effectivetypescript.com/images/type-better.png" width="565" height="94" title="Clearer type display"><p>This is much better. All hints of the metaprogramming that went into deriving this type are gone, and you can see exactly what the type of each field is. <code>author_id</code> is not nullable, but <code>metadata</code> is. The type of <code>metadata</code> is <code>CommentMetadata | null</code>.</p><p>When you&#39;re writing code that works with types, you should consider safety and correctness first and foremost. But once you have those, you should <em>also</em> consider how your types display. The rest of this post walks through some of the techniques that you can use to change how TypeScript displays a type.</p><h2 id="Resolving-a-type"><a href="#Resolving-a-type" class="headerlink" title="Resolving a type"></a>Resolving a type</h2><p>This is the situation described above. TypeScript is showing a generic type expression (often involving <code>Pick</code>) and you&#39;d like it to do a little more work to resolve that type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;</span>;<br><br><span class="hljs-keyword">const</span> c: Color = &#123; <span class="hljs-attr">r</span>: <span class="hljs-number">255</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">0.5</span>&#125;;<br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: Pick&lt;Color, &quot;r&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>Here&#39;s the magic incantation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Resolve&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span> ? T : &#123;[K <span class="hljs-keyword">in</span> keyof T]: T[K]&#125;;<br></code></pre></td></tr></table></figure><p>(<code>Resolve</code> is my choice of name. This type alias also goes by <code>Simplify</code> or <code>NOP</code> or <code>NOOP</code>.)</p><p>This is an odd-looking type to be sure. Both cases of the conditional type are variations on the identity function. It doesn&#39;t look like it should do anything at all! But our goal isn&#39;t to change the type so much as to change how it&#39;s displayed, and, for whatever reason, this does the trick:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Resolve</span>&lt;<span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: &#123; r: number; &#125;</span><br></code></pre></td></tr></table></figure><p>(The conditional type <em>does</em> seem to be necessary: <code>type Resolve&lt;T&gt; = &#123;[K in keyof T]: T[K]&#125;</code> does not resolve this type in the same way.)</p><p>This trick is also helpful in resolving the intersection types like <code>T[K &amp; keyof T]</code> described in part 2 of this series: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a>. For example, here&#39;s the code from the start of this post:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Select&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>&gt; &#123;<br>  (<br>    where:<br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectComments: Select&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectComments()<br><span class="hljs-comment">// ^? let selectComments: Select</span><br><span class="hljs-comment">//    (where: Pick&lt;Comment, &quot;author_id&quot; | &quot;doc_id&quot;&gt; &amp; &#123;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>The <code>Select</code> function takes a table type and two sets of keys: one containing the columns that have to be set to a specific value and one containing the columns that may be any value in a set. The resulting function call has a parameter with that tell-tale implementation-y look.</p><p>As you&#39;d hope, <code>Resolve</code> makes short work of this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">interface</span> SelectResolved&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>  &gt; &#123;<br>  (<br>    where: Resolve&lt;        <span class="hljs-comment">// &lt;-- Resolve added here</span><br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>    &gt;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectCommentsResolved: SelectResolved&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectCommentsResolved()<br><span class="hljs-comment">// ^? let selectCommentsResolved: SelectResolved</span><br><span class="hljs-comment">//    (where: &#123;</span><br><span class="hljs-comment">//        author_id: string;</span><br><span class="hljs-comment">//        doc_id: string;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>All vestiges of the implementation of this type are gone and we&#39;re left with a clean display. Hooray! (Full example on the <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osE4EWANJ2XBwVXARDe4ol6LFedlnIWavIVCuiIZgAKAjQqtb4rnHYYcHPl+vcAXADJl6v12395MnC5UAAypowAjs2kilOUwDFKKkgAOpCg8HhyIMPZ4H2H5rgKEEKNBkhATASEoSAvaDCumElGUOFMB2oSsAAFJIrByghwCRIxrAPheV7YVB4rwVkwCER2r7sawM7zoucD4YRm5SYoraUVBEnvmR66KRuHZ5KwACU0SnlAWAesACmQe2uSWBoaByDwqBaDEwEjky+BENEQEKKBTkwOK3CnOcUCXJwUjqNsAXecsnDfkwGbuQRVTOXR2m1EUAB645MEAA">playground</a>.)</p><p>The <code>Resolve</code> alias can sometimes resolve <code>keyof</code> expressions. More on this below.</p><p><em>h/t to <a href="https://stackoverflow.com/users/5827215/tadhg-mcdonald-jensen">Tadhg McDonald-Jensen</a> on Stack Overflow for <a href="https://stackoverflow.com/a/69976234/388951">introducing</a> me to this helpful type alias!</em></p><h2 id="Special-casing-important-types"><a href="#Special-casing-important-types" class="headerlink" title="Special-casing important types"></a>Special-casing important types</h2><p>Sometimes the display of a type is bad for a specific, important case of your generic. In these situations it can be worthwhile to handle those cases specially using a conditional type.</p><p>For example, say you have a function that can either select all the columns from a table or just a few specific columns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Pick&lt;TableT, Cols&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br></code></pre></td></tr></table></figure><p>It makes sense that the <code>Cols</code> type parameter defaults to <code>keyof TableT</code> since that corresponds to selecting all the columns and <code>Pick&lt;T, keyof T&gt; = T</code>.</p><p>The type <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMSZOFyoADKmmAaBgAHlcMAADylcrAYrijxyQagXmiQaq4CIb09hTFRhwCdTgUzvsAPkWrFYAAo5UKHtFgntrodjDkAJTRAAKAjQqu7ZVnA4gQ9XuUsGjQch4qC0cGMiiZfAACFEAASSuRsFBbdsu0AmBX0sDBzXgbN4AYP8AKqYCwNELdDyuTgAEYACYAGZOHPCxCk3OAAD0AH4gA">doesn&#39;t display very cleanly</a> when we use the function, though:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Pick&lt;Comment, keyof Comment&gt;</span><br></code></pre></td></tr></table></figure><p>This is cryptic and quite implementation-y. And the <code>Resolve</code> trick doesn&#39;t quite do what we want here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- Resolve</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: &#123;id: string; doc_id: string; author_id: string, ...&#125;</span><br></code></pre></td></tr></table></figure><p><code>Resolve</code> has fully inlined this type. What it&#39;s displaying is exactly equivalent to <code>Comment</code>, but that&#39;s hard to tell without a careful comparison. It would be much nicer if it just said <code>Comment</code>!</p><p>You can improve the display here by explicitly checking for the default case:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>  (where: &#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> &#125;):<br>    keyof TableT <span class="hljs-keyword">extends</span> Cols       <span class="hljs-comment">// &lt;-- conditional type</span><br>    ? TableT                        <span class="hljs-comment">// &lt;-- special case</span><br>    : Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- default case</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Comment</span><br></code></pre></td></tr></table></figure><p>Much better! Here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osEiwBpOy4OCq4CIb3FEvRYpzks5CxMSZOFyoADKmmAI4A8rhgK2ygpiuKPHJBj28H2lyu13fgMVO8vVwKpTlD+HahKwrAABRykKDzTns1yHMYOQAJTRP+X7Ab+r4GIMT6DJOQH3nA0T1kQjYtgACgIaCqremGPo2RBtm2uSWBoaByDwqBaHAxiKEy+AAEKIAAklcp4KJe17NgJMAsZYGDmvA2bwAwvH8VUQmiaIEHBPBnAAIwAEwAMycChFiFOBcAAHrjmx56cQ8cA8XxMCyXh0QSeeMBXjesnipwyycFI6jbJcIVqHSrJkJF0g2jm9qcPJimeipx4oGgAhAmgeGdm5HmMbp+nGWZFm1EU4F2UwQA">full playground</a> for this example.</p><h2 id="Other-techniques-that-don-39-t-work-as-well"><a href="#Other-techniques-that-don-39-t-work-as-well" class="headerlink" title="Other techniques that don&#39;t work as well"></a>Other techniques that don&#39;t work as well</h2><p>There are a few other techniques I&#39;ve run across for simplifying type display that don&#39;t work as well as <code>Resolve</code>. They&#39;re included here for completeness. If you&#39;re using them, you may as well just use <code>Resolve</code> instead.</p><h3 id="Exclude-lt-keyof-T-never-gt"><a href="#Exclude-lt-keyof-T-never-gt" class="headerlink" title="Exclude&lt;keyof T, never&gt;"></a><code>Exclude&lt;keyof T, never&gt;</code></h3><p>This can be used to inline the display of <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> Chan = keyof Color;<br><span class="hljs-comment">//   ^? type Chan = keyof Color</span><br><span class="hljs-keyword">type</span> ChanInline = Exclude&lt;keyof Color, <span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">//   ^? type ChanInline = &quot;r&quot; | &quot;g&quot; | &quot;b&quot; | &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>The <code>Resolve</code> trick <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIHsA26rIN7JQBcyIArgLYBG0A3MgOYnnV3JXOU1T1yeu4AvrQBQIsAE8ADigBKEAM5YAbhAA8AFQB8yALzINyCAA9IIACYLkAMTIgEYYOhDIA-AeQk8AbQDSyUGQAawgJdBgDAF0SDT9I4XFpFFQACzgXfXklTFU1ELCIjGwoLVEAejLkKoA9d0kZNDSM5AAiKBbkAB9Whg7ulqo+1rgWsQRnBTBkBBIinD18QhIAJgBWVYAaRhIARmWADi2OZAAGLb5TgDpVhPMIBEw4KBQYOwcnFwYIMFT0kAhMAAKGZoLA4LYIJokLIqdT5cKg4paACU-G4ojGEymuH0Xx+TX+QIQGzEFWQAAUyFMwmRcAhaUpcHApmAUigIBZkAjWSgpM9lE4yFZMKAUOlzMgaQByTCYZAKCAQIgiMl434gQnA2ZgqAQqHBUIIuZQVGkLjQFVlS3IADubOecCsAEkpRKRSFkGB0PLFcrVd91ZqQca9ekSG0hi1el1WoMYy0RqaWNwREA">works just as well</a> in this case, and can resolve many types that excluding <code>never</code> cannot. So just use <code>Resolve</code>.</p><p>Side note: why does TypeScript display <code>keyof</code> types in this way? Prior to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">TypeScript 4.2</a>, TypeScript <em>always</em> inlined <code>keyof</code> display. This sometimes led to comical results:</p><img src="https://effectivetypescript.com/images/keyof-button.png" width="907" height="78" title="keyof HTMLButtonElement showing a union of 260 string literal types"><p>Count &#39;em, that&#39;s a union of 260 string literal types! Newer versions of TypeScript simply display this as <code>keyof HTMLButtonElement</code>, which seems like a win. But I think they <a href="https://github.com/microsoft/TypeScript/issues/42322">threw the baby out with the bathwater</a> here; for the common case of small unions (say less than 10 strings), it&#39;s clearer to <a href="https://twitter.com/danvdk/status/1414343269522227207">just show the type union</a>. This makes the behavior of <code>keyof</code> much easier to understand. Perhaps someday this will improve and we won&#39;t need to <code>Resolve</code> this type.</p><h3 id="unknown-amp-T"><a href="#unknown-amp-T" class="headerlink" title="unknown &amp; T"></a><code>unknown &amp; T</code></h3><p>I learned about this one from Titian&#39;s <a href="https://stackoverflow.com/a/56416192/388951">classic answer about typing <code>_.invert</code></a> on Stack Overflow. Sometimes you can replace <code>TypeExpr</code> with <code>&#123;&#125; &amp; TypeExpr</code> or <code>unknown &amp; TypeExpr</code> to force TypeScript to resolve a type.</p><p>You can see an example of this technique working in <a href="https://www.typescriptlang.org/play?#code/PTAEBUEsBdIQwHYHIDOpoE8AOBTNAzAJwHsBbUAC2mixQC4QVo4BjAa2IDcdD8AbYgHcAdCzLA4wAKwA2ACwBGGQoCcAJmABmABzaVUhQChMuUAEE+fAGpw+AVzwAecKBwAPaDgQATNACUcMUJvRwAFElxCTABpHAwAGlBw4kiYuIA+dNAAXlAAb0NQItAAbVDQSARQNjjifAgAXTp86rjm0MTOWwdm8DKG0ABfQ0GSmow6xoBuY2wcUABJBG4ogJQ7PmhnVw8vX1AAoJDk1IxYhKSInjSMTJz8wuKyiqqLa26ncHSSpC77HCQDSaoAAoh5CKwtm8bP8UM50ok8qA-j0kkNvkhxoCZoMZoYxAgmKBiPcCsVQHBmkg3Eh4o8igAjKkYWkjCloAlMPEmeYuXJLFbQNYbLY8ybEdIzEBFAB6AH5DLNTALrsLNgAhHDUHjbdyeHz+QLEYJhK5RM5xRIna4W25ZXJ2BBsBBCKoAMge5OelXMlhhDjhXx+KIBQOaYOgEJYUL9H0DCJaIfa6J+WIaOLx3kCfDghHm+Ed0cgxCqlUFut2BoORpN1vN5ytZpumQAFMQGQArXoASmaKtWeBF8JmWZYObzoALCCLJZegs12sIFf1+0OxuOTdtjZSNvOrfbXYgvcWy1Vg41Ws8S6+I+zufzhdgs7LZ5QxD43BCLj1e0NR1NO71palyAc26Rtp2PbNGs77cI4-ZCueWxfJKirSuAFCQGgFBwGgiCgAARJApBYHwOCkF4zBPggGAEegcygN4WGkXAGDCKAADqOHQKgJ6Cmq0AKpy0BzvcL5RG23ZSmAxTymhYBmN4TEIAA5hSoCCDglgALQsSwODeKAAAGjrOq6oBukZoCkHANRoDAjHMTmGDWca8xjjgiB8BgdD4iWRJlmoYmnlEC5XpJ0nknJhjSmY1Zvh+OCOFkrCYTg3BoNAFDzCgcAUaAebrJsvnCXOmjBfxeCwQZEUxTJsoKvJECYfZeFVLYV4IHAsDcBUJFkRRCBUcWVQoBQQiVGpWXzN4EKCAyrBsGgkwmU6LqCO6Vn4O+AiCJNdWUNQtAMMAOD4PggQ9VqcwoCwhCQFg0CiOIagAAxvcAr1SMACgaI6I2QAAXjg2kHpdkD4BgwCKjyoAAKoIADwPLr+xKdpd9qeqUbAvK0Ez1OAwJ5GwzRsFMyK9GMDTDKM4yTIT3IMdEVihHAkCEKSJMgac5zk5wzSmetCDDLDADy6NFpDKNVszrPs5jZLY7jfSYoCwIRlGyGIlzbCDBinCAiMjOmAAyoIcBYMz8I5I836VvsxPNJUF0c9EnROwgLugFYwxFHK+Rc1YfPNNE5ODEU0qONp2mgC6njoNloAoObWAAISPM0CDpTwxvzDBiXW7kdsrmgABij4jaA-suM0eQlNEuN0wTwJ9NE1MzLDCFw6L0v7GD0aY+LHbg1LZsW1bCNI0lKEWaAsts4QqFKvMXei-nn698tEvQJj69JUPI8YI4Y+W1YjiTyWQPT3cHrz-LS+juOD7TtRc7XN3m-Vv+dY3NuPMZOBA8UE+Lvx7jeQwj97yTgrs+EK0Bu57y-DsEuX91wAX-hcH+tp9yQSPH2OBCCqqJS-EvdCLUKR8DfJQXCFIqhEX6uRSi3URq0XoqYJiKAWI+T8oSESZY4YklyOJeBotarSlko1aUe9kqTkgG4PAFRoCJAZHYESEw7CgBYIgJAIk4BKWMoLcyllaEYEENlCc0ASTeBJDAYQPCArLAEUFIRBC15EM-GI+qoA5JAA">this playground</a>. I&#39;ll spare you the full details, but from hard-earned experience I&#39;ve learned that this trick is much more finnicky than <code>Resolve</code>. Just use <code>Resolve</code> instead.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While it may seem that you&#39;re stuck with however TypeScript chooses to display your type, that&#39;s not actually the case! You do have a few levers at your disposal. The <code>Resolve</code> alias is wonderful for removing implementation details from generic types. And where it doesn&#39;t work, you can sometimes add a special case to get the display that you want.</p><p>Remember that <a href="https://twitter.com/SeaRyanC/status/1414347018646921216">all representations are equally valid</a>, and that the TypeScript team might choose to change the display of your type at any time (as <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">happened</a> with <code>keyof</code> in TypeScript 4.2). So once you&#39;ve got your types displaying the way you like, it&#39;s worth writing some tests to make sure they stay that way. Tools like <a href="https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, which make assertions about the textual display of types, are the way to go here.</p><p>Do you have other tricks for controlling type display? Let me know <a href="https://twitter.com/danvdk">on Twitter</a> or in the comments below.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We talk all the time about how to define and use types in TypeScript, but we
rarely talk about how TypeScript chooses to &lt;i&gt;display&lt;/i&gt; our types. There
are often several possible ways to display the same type, and the choice can
have a big impact on the usability of your library. TypeScript tries to make
good decisions on its own about type display, but it also gives us a few very
obscure levers by which we can control it ourselves.&lt;/p&gt;
&lt;p&gt;Let&#39;s dive in to the strange world of type display!&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A TypeScript Perspective on Go: the 2021 Advent of Code</title>
    <link href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/"/>
    <id>https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/</id>
    <published>2022-02-06T23:00:00.000Z</published>
    <updated>2023-04-27T21:20:42.900Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">It&#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.</p><p>My favorite way to learn a new language is through the annual <a href="https://adventofcode.com">Advent of Code</a> (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. In 2019 I <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">did it in Python</a> (not a new language for me) and in 2020 I <a href="https://effectivetypescript.com/2021/03/24/advent-of-code/">did it in Rust</a> (which was a new language). This year, I did it in Go (aka Golang).</p><p>This post has three parts:</p><ul><li>My impressions of Go (coming from a TypeScript perspective)</li><li>My impressions of this year&#39;s Advent of Code</li><li>Notes and links for each day</li></ul><span id="more"></span><h2 id="My-Impressions-of-Go"><a href="#My-Impressions-of-Go" class="headerlink" title="My Impressions of Go"></a>My Impressions of Go</h2><p>I first used Go when I was working at Google in 2011. C++ was my main language at the time, so Go wasn&#39;t such a big shift. I remember finding it quite confusing until I really &quot;got&quot; the idea of duck typing: the consumer of an interface defines what it needs and the producer doesn&#39;t need to declare that it implements this interface. I didn&#39;t have much use for Go in my work or personal projects, so I mostly forgot about it.</p><p>Some parts of Go&#39;s design that seemed strange in 2011 have aged quite well: automatic formatting of source code is very standard now, and I certainly didn&#39;t mind Go complaining about unused symbols. One thing that I found confusing in 2011 and still found confusing today: Go&#39;s insistence on where you put your source code on disk. I usually put all my GitHub repos in <code>~/github/reponame</code>. But Go wants them under <code>$GOROOT</code>, which is <code>~/go</code> (or <code>~/gotip</code>) on my system. This made my setup experience a bit frustrating, but once I gave up and put my code in <code>$GOROOT</code> everything worked OK and I moved on.</p><p>Last year my pattern was to solve the puzzle, then look at how more experienced Rust developers solved it on <a href="https://reddit.com/r/adventofcode">r/adventofcode</a>. I almost invariably learned something from this. That didn&#39;t work this year. In Go, the straightforward approach is usually the canonical one. There are just fewer surprises. Go takes pride in being a <a href="https://www.capitalone.com/tech/software-engineering/go-is-boring/">&quot;boring&quot; language</a>. I learned more about Go from having <a href="https://github.com/danvk/aoc2021/commit/a3b38546680c52e1c9c29365a712c834214082cf#r62160234">@derat review my code</a> and make more specific suggestions.</p><p>I&#39;m aware that the Advent of Code doesn&#39;t particularly play to Go&#39;s strengths: there&#39;s no concurrency, for example. But I still found it to be a good way to force myself to learn the basics of the language and use it to solve real problems.</p><p>Here are a few differences between Go and TypeScript that stood out to me.</p><h3 id="Implicit-copies"><a href="#Implicit-copies" class="headerlink" title="Implicit copies"></a>Implicit copies</h3><p>I&#39;m not aware of any situation in which JavaScript makes a copy of an object without your asking it to. In Go, however, this happens all the time. Building a mental model for when these copies happens is always relevant for performance, and sometimes relevant for correctness.</p><p>In TypeScript, we can create a <code>Student</code> type with a name and age, and <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMpgK4BMLmQbwFgAoZZEOAWwgC5kBnMKUAcwG4Sy4XbyNKARtA7EAviRIwMIBGGAB7EMgCCPZQE0IcKAAp6ddNlxgAlAU4MAdNxQBqALzIAjCXHESCRY2QD5AgQCeBpg4eI745FS8AOQAQn6B0QA0yDZ0TgBMyKIiqhAaWrq+-gEmIp4g9PIANhCW1fIsOsWB1jxlZAD0ncgACszg9M4AzCRAA">write a function</a> to make a student age by a year:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AgeAYear</span>(<span class="hljs-params">s: Student</span>) </span>&#123;<br>  s.age += <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-keyword">const</span> bobby: Student = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Bobby&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">12</span> &#125;;<br>AgeAYear(bobby);<br><span class="hljs-built_in">console</span>.log(bobby.age);  <span class="hljs-comment">// Prints 13</span><br></code></pre></td></tr></table></figure><p>In JavaScript, objects are always passed by reference. There&#39;s only one <code>Student</code> floating around and <code>AgeAYear</code> modifies it, which is why this code logs 13. (Are primitive types like <code>string</code> are passed by value or by reference? It&#39;s irrelevant because they&#39;re immutable.)</p><p>In Go, <a href="https://go.dev/play/p/zhTqc1-SP1J">something very different happens</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AgeAYear</span><span class="hljs-params">(s Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)  <span class="hljs-comment">// prints 13</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bobby := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>AgeAYear(bobby)<br>fmt.Printf(<span class="hljs-string">&quot;Bobby&#x27;s age is %d\n&quot;</span>, bobby.age)  <span class="hljs-comment">// prints 12</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go passes objects by <em>value</em>, not by reference, so <code>AgeAYear</code> is actually operating on a <em>copy</em> of <code>bobby</code>, not the original. This copy&#39;s <code>age</code> increases, but then the copy gets thrown away when the function returns. C++ has a similar behavior and calls this &quot;value semantics.&quot;</p><p>If you want to mutate <code>bobby</code>, you can use a pointer instead:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetOlder</span><span class="hljs-params">(s *Student)</span></span> &#123;<br>s.age += <span class="hljs-number">1</span><br>fmt.Printf(<span class="hljs-string">&quot;Age is %d\n&quot;</span>, s.age)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bob := Student&#123;<span class="hljs-string">&quot;Bobby&quot;</span>, <span class="hljs-number">12</span>&#125;<br>GetOlder(&amp;bob)<br>fmt.Printf(<span class="hljs-string">&quot;Bob&#x27;s age is %d\n&quot;</span>, bob.age)<br>&#125;<br></code></pre></td></tr></table></figure><p>Now this logs <code>13</code> twice. Working with pointers has some famous drawbacks, of course, but it&#39;s much easier in Go than it is in C or C++ because there&#39;s garbage collection.</p><p>Pointers in Go have a way of being contagious. Once you use a pointer to a structure in one place, you can get into trouble if you ever pass it by value someplace else. For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SelfReference <span class="hljs-keyword">struct</span> &#123;<br>  name <span class="hljs-keyword">string</span><br>  self *SelfReference<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeSelfReference</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">SelfReference</span></span> &#123;<br>  me := SelfReference &#123;name: name&#125;<br>  me.self = &amp;me<br>  fmt.Printf(<span class="hljs-string">&quot;References self? %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// true</span><br>  <span class="hljs-keyword">return</span> me<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  me := MakeSelfReference(<span class="hljs-string">&quot;me&quot;</span>)<br>  fmt.Printf(<span class="hljs-string">&quot;References self?: %v\n&quot;</span>, me.self == &amp;me)  <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://go.dev/play/p/wCiNfPlX75W">This code</a> logs:</p><pre><code>References self? trueReferences self? false</code></pre><p>I scratched my head a good long time over an issue like this before realizing that when <code>MakeSelfReference</code> <em>returns</em>, it makes a copy of the object but of course doesn&#39;t update the <code>self</code> pointer. So the two get out of sync. If you want to keep them in sync, you want to return a <code>*SelfReference</code> instead.</p><p>It took me some time to build an intuition for this because the rules about what&#39;s copied can be surprising. An array (which always has a fixed size in Go) is copied by value, but passing a slice (which is like a small struct with a pointer, length and cap) does not make a copy of the underlying array. Another wrinkle (which I won&#39;t dive into here) is that depending on how a method is declared, invoking it can implicitly copy the object, too.</p><p>All these implicit copies are important and eventually this became intuitive, but it&#39;s quite a shift if you&#39;re coming from JS!</p><h3 id="Batteries-not-included"><a href="#Batteries-not-included" class="headerlink" title="Batteries not included"></a>Batteries not included</h3><p>Go is definitely not a &quot;batteries included&quot; language: there are many very common and familiar functions that are missing from its standard library, notably <a href="https://stackoverflow.com/questions/19239449/how-do-i-reverse-an-array-in-go/19239832">reversing a list</a>, the standard <code>map</code> / <code>filter</code> / <code>reduce</code> functions, taking the min/max of two numbers or <a href="https://stackoverflow.com/questions/57648933/why-doesnt-go-have-a-function-to-calculate-the-absolute-value-of-integers">taking the absolute value of an integer</a>. The argument is that these functions are easy to write, so if you want them, you should just write them. But that does lead to some strange interactions. This VS Code shortcut is a real gem:</p><p><img src="https://effectivetypescript.com/images/golang-reverse.gif" alt="VS Code Reverse"></p><p>I guess this beats copy/pasting from Stack Overflow? My old coworker Dan suggested that this was a way to push you towards reverse iteration, which is faster and requires less memory than allocating a new list. The Go team tends to have very strong opinions about things like this. If you agree with them, then it&#39;s fun to watch them take a stand. But if you don&#39;t, you wind up having to settle for weird workarounds like this one.</p><p>The omission of <code>map</code> / <code>filter</code> / <code>reduce</code> is likely because these functions aren&#39;t that useful without generics. And there is some exciting news on that front!</p><h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><p>The Go team <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">accepted a propsal</a> to add generics to the language in mid-2021 and the Go 1.18 beta, which included support for them, came out in the middle of this year&#39;s AoC. Generics are a big part of TypeScript, so I was curious to see Go&#39;s take on them. I did most of the puzzles using <a href="https://pkg.go.dev/golang.org/dl/gotip">gotip</a> so that I could use generics before they were officially released. Overall this was a pretty smooth process. I found that Go with Generics is a much more pleasant language to use than Go without.</p><p>Here&#39;s what a <a href="https://github.com/danvk/aoc2021/blob/ba0936c804ff9c2a170472c77de029712baa069f/util/util.go#L159-L170">generic <code>min</code> function</a> looks like in Go:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;constraints&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span>[<span class="hljs-title">T</span> <span class="hljs-title">constraints</span>.<span class="hljs-title">Ordered</span>]<span class="hljs-params">(nums []T)</span> <span class="hljs-title">T</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(nums) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(nums)<br>&#125;<br>min := nums[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> nums[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> v &lt; min &#123;<br>min = v<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> min<br>&#125;<br></code></pre></td></tr></table></figure><p>Aside from some syntax differences, this is quite similar to how you&#39;d <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWRmAPAFQHwAoBuAhgDYDOAXIpgNoC6AlJZogN4CwAUIojMIgSVIA6YgFMwAcygALRAF4FiAAz1WnbtxkAnOAHdEYUfoCiWnVtwByAMKEwYOFERRCAa1GIAtmkRw+ozwAHKABPRGIYUihLegBudUQAXwSxJ28kOUQiMmolWniuRGA4LX4IBCis3z5s4VIIiFFcAEZ6VXZC7l5+fER0LzR2hI0BjKyCkeTCqe4tUSgQLSR0gsSgA">write this code</a> in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (vals.length === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Cannot take min of empty list&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> min = vals[<span class="hljs-number">0</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> vals.slice(<span class="hljs-number">1</span>)) &#123;<br>    <span class="hljs-keyword">if</span> (v &lt; min) &#123;<br>      min = v;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> min;<br>&#125;<br></code></pre></td></tr></table></figure><p>The most interesting bit in the Go code is the <code>[T constraints.Ordered]</code>, which would be similar to <code>T extends Ordered</code> in TypeScript. Go comes with a <code>constraints.go</code> module that <a href="https://cs.opensource.google/go/go/+/master:src/constraints/constraints.go;l=44-50?q=constraints.go&ss=go%2Fgo">defines <code>Ordered</code></a> and many other constraints that can be placed on type parameters:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Ordered is a constraint that permits any ordered type: any type</span><br><span class="hljs-comment">// that supports the operators &lt; &lt;= &gt;= &gt;.</span><br><span class="hljs-comment">// If future releases of Go add new ordered types,</span><br><span class="hljs-comment">// this constraint will be modified to include them.</span><br><span class="hljs-keyword">type</span> Ordered <span class="hljs-keyword">interface</span> &#123;<br>Integer | Float | ~<span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Both <code>Integer</code> and <code>Float</code> are themselves constraints (while JS/TS just has <code>number</code>, there are many numeric types in Go such as <code>uint32</code> or <code>float64</code>). The tilde in <code>~string</code> is also interesting. It matches any type whose &quot;underlying type&quot; is <code>string</code>. This confused me for a while until I realized that, unlike TypeScript, Go has nominal types! For example:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> EnglishWord <span class="hljs-keyword">string</span><br><span class="hljs-keyword">type</span> GermanWord <span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><p>This would create two types that are not comparable or assignable to one another. But you can certainly take the min or max of a list of <code>EnglishWord</code>s. This is a feature that has been <a href="https://github.com/Microsoft/Typescript/issues/202">much discussed</a> in TypeScript but is not natively supported. I found nominal types less useful in the Advent of Code than I would have expected. (I only used them to create distinct types for <code>Digit</code> and <code>ScrambledDigit</code> on <a href="https://github.com/danvk/aoc2021#day-8-seven-segment-search-33759--24434">Day 8</a>).</p><p>So is the Go generic code equivalent to this TypeScript?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Orderable = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Min</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">Orderable</span>&gt;(<span class="hljs-params">vals: T[]</span>): <span class="hljs-title">T</span> </span>&#123; ... &#125;<br></code></pre></td></tr></table></figure><p>Not quite. This TypeScript definition would allow you to take the min of a mixed list of <code>string</code>s and <code>number</code>s, which should be an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> mixedList = [<span class="hljs-number">42</span>, <span class="hljs-string">&#x27;forty two&#x27;</span>];  <span class="hljs-comment">// type is (string | number)[]</span><br><span class="hljs-keyword">const</span> min = Min(mixedList);  <span class="hljs-comment">// T is string|number, returns a string|number</span><br></code></pre></td></tr></table></figure><p>There&#39;s no notion of a union type in Go (more on that in a moment), so <code>T</code> has to be exactly one of the types enumerated in the constraint (or a type with exactly one of those underlying types).</p><p>I found Go generics to mostly work as expected and be quite intuitive. They let me factor out some of the repetitive boilerplate that bothered me when I first started with the language.</p><p>For example, this is a very common pattern to map a function over a slice:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go">nums := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;<br><span class="hljs-keyword">var</span> squares []<span class="hljs-keyword">int</span><br><span class="hljs-keyword">for</span> _, num := <span class="hljs-keyword">range</span> nums &#123;<br>  squares = <span class="hljs-built_in">append</span>(squares, num * num)<br>&#125;<br></code></pre></td></tr></table></figure><p>With generics, you can factor out a <code>Map</code> function and <a href="https://go.dev/play/p/boWkZFquqck?v=gotip">rewrite this loop</a>:</p><figure class="highlight go"><table><tr><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Map</span>[<span class="hljs-title">T</span> <span class="hljs-title">any</span>, <span class="hljs-title">U</span> <span class="hljs-title">any</span>]<span class="hljs-params">(vals []T, fn <span class="hljs-keyword">func</span>(T)</span> <span class="hljs-title">U</span>) []<span class="hljs-title">U</span></span> &#123;<br><span class="hljs-keyword">var</span> us []U<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> vals &#123;<br>us = <span class="hljs-built_in">append</span>(us, fn(v))<br>&#125;<br><span class="hljs-keyword">return</span> us<br>&#125;<br><br>squares := Map(nums, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> num * num &#125;)<br></code></pre></td></tr></table></figure><p>This is quite verbose compared to how it would look in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">squares = nums.map(<span class="hljs-function"><span class="hljs-params">num</span> =&gt;</span> num * num);<br></code></pre></td></tr></table></figure><p>The TypeScript version is so much shorter because:</p><ol><li>JavaScript&#39;s <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">arrow functions</a> have a very compact syntax compared to Go&#39;s <code>func</code> and <code>return</code>.</li><li>TypeScript is able to infer two types: both a) the type of the function parameter (<code>num</code>), which it gets from the type of <code>nums</code> and the type of <code>Array.prototype.map</code>, and b) the return type of the arrow function, which it gets from the function body (<code>num * num</code>). Go infers neither of these, so you have to write out the types. It does infer the return type of the whole <code>Map</code> expression, though (<code>[]int</code>).</li></ol><p>I expect that having generics will greatly increase the demand for concise function definitions and better type inference. The Go team will either adopt them or declare that the users asking for them are misguided. It&#39;ll almost certainly be one of those two ‚Äî they&#39;re quite opinionated!</p><p>There&#39;s a <a href="https://research.swtch.com/generic">famous quote</a> from one of the Go developers (Russ Cox) that when it comes to generics, you can either have:</p><ol><li>Slow programmers (i.e. no generics)</li><li>Slow compilers (by emitting a different version of a generic function for every type instantiation)</li><li>Slow programs (by boxing everything and doing runtime dispatch).</li></ol><p>In this scheme, JavaScript forces TypeScript to choose &quot;slow programs&quot; (though JS JITs are quite good!). And TypeScript has a complex enough type system that it&#39;s often a slow compiler, even without C++-style compile-time specialization.</p><p>Go tries to <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md#implementation">escape this dilemma</a> by leaving it up to the compiler whether to specialize a function or box it. The whole <a href="https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md">generics proposal</a> is interesting to read. It only occurred to me halfway through the doc that runtime performance was a consideration. Clearly I&#39;ve internalized the TypeScript approach to generics!</p><p>Overall I found Go generics easy to use and a great addition to the language. It will be interesting to see how they&#39;re adopted by the community, and whether they bifurcate libraries. I wanted a Graph library, for example, but there weren&#39;t any that used generics. So I just <a href="https://github.com/danvk/aoc2021/blob/master/graph/graph.go">wrote my own</a>.</p><h3 id="Other-bits"><a href="#Other-bits" class="headerlink" title="Other bits"></a>Other bits</h3><p>Here are a few other things I found interesting about Go:</p><ul><li><p>Go has some extremely error-prone constructs. Two examples:</p><ul><li>You write a for loop over a slice as <code>for idx, el := range vals</code>. So <code>range</code> gives you the index first and then the value. This means that if you write <code>for el := range vals</code>, you&#39;ll iterate over the indices, not the values. I much prefer the JS approach of value then index, e.g. for <code>map</code> and <code>forEach</code>. It seems much more common to only care about the value than to only care about the index.</li><li>Does <code>a, b := fn()</code> introduce two new variables? It depends. If both <code>a</code> and <code>b</code> exist, then it will create two new variables. But if only <code>a</code> exists, then it will create a new <code>a</code> variable but reassign <code>b</code>. I found this quite surprising!</li></ul></li><li><p>I really missed union types. Go has <a href="https://making.pusher.com/alternatives-to-sum-types-in-go/">nothing like them</a>, and the official stance from the Go team is that they <a href="https://github.com/golang/go/issues/19412#issuecomment-284301017">&quot;do not add very much&quot;</a> to untyped solutions. ü§Æ Remember what I said about the Go team being opinionated?</p></li><li><p>You don&#39;t need regular expressions as much as you think for parsing. <code>fmt.Sscanf</code> woked great for most of the Advent of Code problems.</p></li><li><p>Like TS, Go has both <code>var</code> and <code>const</code> but <a href="https://go.dev/ref/spec#Package_initialization">they mean pretty different things</a>.</p></li><li><p>Go doesn&#39;t really have a C++-like notion of <code>const</code> or TypeScript&#39;s <code>readonly</code>.</p></li><li><p><a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">As in other years</a>, I found that using <code>map[Coord]T</code> instead of <code>[][]T</code> is almost always a good idea. It lets you create sparse arrays and accomodates unknown size or negative indices.</p></li><li><p>Go&#39;s type syntax is almost exactly backwards from TypeScript or C, which was a constant source of typos for me. For example, <code>[]T</code> instead of <code>T[]</code>. Or for function parameters, <code>min(a int, b int)</code> instead of <code>min(int a, int b)</code>. Or even <code>min(a, b int)</code>.</p></li><li><p>I still find Go&#39;s pickiness about where I put my code on disk to be weird, confusing and counterproductive. Why can&#39;t I <code>go build</code> something in a subdirectory?</p></li><li><p>Go types all have a meaningful zero value. I started to learn to work with this more and more as the month went on. For example, <code>nil</code> works perfectly well as an empty slice.</p></li><li><p>I&#39;ve always been a spaces person but Go uses tabs. It didn&#39;t bother me one bit.</p></li></ul><h2 id="My-impressions-of-this-year-39-s-Advent-of-Code"><a href="#My-impressions-of-this-year-39-s-Advent-of-Code" class="headerlink" title="My impressions of this year&#39;s Advent of Code"></a>My impressions of this year&#39;s Advent of Code</h2><p>The 2021 AoC was harder than 2020 but easier than 2019. As in 2020, none of the solutions built on one another. Each day was a completely independent puzzle. I&#39;m sure <a href="http://was.tl/">Eric Wastl</a> has his reasons for doing it this way, but I missed how 2019&#39;s puzzles encouraged you to improve the design of your previous day&#39;s solutions. With the independent puzzles, Advent of Code feels more like pure speed coding.</p><p>Days 8, 22 and 24 were the real standouts to me as a creative puzzles. For the other days, my first idea on how to solve the puzzle always turned out to be right, even if it took quite a while to implement it. Many, many of the puzzles this year could be solved with some variation on <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. It&#39;s always amazing to see how effective the standard algorithms are once you figure out how to map your problem onto them.</p><p>I continue to wish I were in a timezone where it was more reasonable for me to do the puzzles as soon as they came out. And I continue to think this is a great way to learn a language. AoC problems don&#39;t really play to Go&#39;s strengths (there&#39;s no concurrency) but I did feel much more confident writing Go by the end than I did at the start.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Once again, I had a great time doing Advent of Code this year and I enjoyed the opportunity to learn a new language. The days&#39; puzzles gave me something concrete and fun to cling to during a time of <a href="https://www.theverge.com/2021/12/16/22840028/sidewalk-labs-google-doctoroff-health-toronto-quayside">complete chaos</a> at my work.</p><p>Day 25 in particular stands out. I woke up early (6 AM) to watch the long-anticipated <a href="https://www.youtube.com/watch?v=9tXlqWldVVk">launch of the James Webb Space Telescope</a>, and I raced to collect my final stars before I had to drive off to the airport for a trip to the Dominican Republic, my first international vacation in ~2.5 years.</p><p>It&#39;s unlikely I&#39;ll use Go in my daily work, but I do enjoy the perspective on TypeScript that it gives. As always, TypeScript&#39;s relationship to JavaScript (types are erased at runtime) and its ability to infer types stand out. Which language will I try next year? I&#39;m not sure! Suggestions welcome.</p><p>If you&#39;ve made it this far and for some reason want even more, check out the <a href="https://github.com/danvk/aoc2021">notes and code</a> in my GitHub repo.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;It&amp;#39;ll surprise no one to hear that TypeScript is my favorite programming language. But I do still enjoy dabbling in other languages. It&amp;#39;s a great way to get perspective on what makes TypeScript unique, and how other language designers are thinking about the same problems.&lt;/p&gt;
&lt;p&gt;My favorite way to learn a new language is through the annual &lt;a href=&quot;https://adventofcode.com&quot;&gt;Advent of Code&lt;/a&gt; (AoC). AoC runs every year from Dec 1-25. Every day unlocks a new puzzle with two parts which build on each other. Lots of people do these puzzles (over 100,000 completed day 1 this year) and post their solutions on &lt;a href=&quot;https://reddit.com/r/adventofcode&quot;&gt;r/adventofcode&lt;/a&gt;. In 2019 I &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;did it in Python&lt;/a&gt; (not a new language for me) and in 2020 I &lt;a href=&quot;https://effectivetypescript.com/2021/03/24/advent-of-code/&quot;&gt;did it in Rust&lt;/a&gt; (which was a new language). This year, I did it in Go (aka Golang).&lt;/p&gt;
&lt;p&gt;This post has three parts:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;My impressions of Go (coming from a TypeScript perspective)&lt;/li&gt;
&lt;li&gt;My impressions of this year&amp;#39;s Advent of Code&lt;/li&gt;
&lt;li&gt;Notes and links for each day&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript Types: The First 500 Years (tsconf 2021 talk)</title>
    <link href="https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/"/>
    <id>https://effectivetypescript.com/2021/12/10/typescript-types-the-first-500-years/</id>
    <published>2021-12-10T14:25:00.000Z</published>
    <updated>2021-12-10T14:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>My talk from tsconf 2021, <a href="https://www.youtube.com/watch?v=uN1zuV4DGRY&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe"><em>TypeScript Types: The First 500 Years</em></a>, is up on YouTube (<a href="https://docs.google.com/presentation/d/1HYknblfcAnbjbdDe4MYTyRQpCw_gV72n2cj88xH7z8c/edit?usp=sharing">slides here</a>). Check it out!</p><iframe width="560" height="315" src="https://www.youtube.com/embed/uN1zuV4DGRY" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>The talk tries to answer the question &quot;what is a type?&quot; It seems simple but it&#39;s actually quite tricky! The talk explains how sets can be built constructively (<code>&quot;A&quot; | &quot;B&quot; | &quot;C&quot;</code>), but that the more common approach in TypeScript is best thought of as a subtractive process, where you start from the raw, undifferentiated <code>unknown</code> type and then whittle your way down:</p><img src="/images/unknown-marble.jpg" width="527" height="395" alt="Large block of marble with the word unknown on it" style="max-height: 395px"><p>It then talks about how TypeScript has given us the ability to &quot;carve&quot; out finer and finer details in our types over time, and how that lets us capture more and more errors in our code.</p><p>Overall I&#39;m happy with how the talk turned out. Let me know what you think! All the <a href="https://www.youtube.com/playlist?list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe">tsconf 2021</a> talks are online now. The Anders <a href="https://www.youtube.com/watch?v=V5OnAN63vls&list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&index=2">keynote</a> is always a highlight.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;My talk from tsconf 2021, &lt;a href=&quot;https://www.youtube.com/watch?v=uN1zuV4DGRY&amp;list=PL2z7rCjEG2kubUfEAHu-08-aK3Tyn9Zxe&quot;&gt;&lt;em&gt;TypeScript Ty
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Exclusive Or and the Optional never Trick</title>
    <link href="https://effectivetypescript.com/2021/11/11/optional-never/"/>
    <id>https://effectivetypescript.com/2021/11/11/optional-never/</id>
    <published>2021-11-11T22:00:00.000Z</published>
    <updated>2021-11-11T14:06:42.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>Apologies for the <a href="https://effectivetypescript.com/2021/06/03/interface/">long delay</a> between posts. I&#39;ve been busy <a href="https://www.instagram.com/p/CU8hUZwJ3be/">getting married</a> and <a href="https://www.instagram.com/p/CWBG_BGrl31/">climbing</a>. With winter setting in and the wedding behind me, I hope that I&#39;ll find more time for writing.</em></p><blockquote><p>&quot;Do you want coffee or tea?&quot;</p><p>&quot;Yes&quot;</p></blockquote><p>In ordinary speech, &quot;or&quot; means &quot;exclusive or.&quot; Only programmers and logicians use an <em>inclusive</em> or.</p><p>In TypeScript, it&#39;s easy to get mixed up between these two:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>We usually read the last line as &quot;Type <code>Thing</code> is a <code>ThingOne</code> or <code>ThingTwo</code>.&quot; But just like JavaScript&#39;s runtime or (<code>||</code>), TypeScript&#39;s type-level or (<code>|</code>) is an <em>inclusive</em> or. There&#39;s no reason a thing can&#39;t be both a <code>ThingOne</code> <em>and</em> a <code>ThingTwo</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> allThings: Thing = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Why does this work? It&#39;s because TypeScript has a structural type system. Both the <code>ThingOne</code> and <code>ThingTwo</code> types allow additional properties that aren&#39;t declared in their interface (this fact is sometimes obscured by <a href="https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks">excess property checking</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> bothThings = &#123;<br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">const</span> thing1: Thing1 = bothThings;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> thing2: Thing2 = bothThings;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>So what if you really do want an exclusive or? What if you want to keep your <code>ThingOne</code>s and <code>ThingTwo</code>s separate? How can you model that?</p><p>There&#39;s a standard trick, which is to use an <em>optional <code>never</code></em> type in your interface to disallow a property:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> OnlyThingOne &#123;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>  hairColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> OnlyThingTwo &#123;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>  shirtColor?: <span class="hljs-built_in">never</span>;<br>&#125;<br><span class="hljs-keyword">type</span> ExclusiveThing = OnlyThingOne | OnlyThingTwo;<br></code></pre></td></tr></table></figure><p>Now none of the assignments from before pass the type checker (see <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgPIgDYE8AqALUAc3RQG8BYAKGWQGcCowBhAewxagC46woiBuKjTxxgUVuygB+biAgA3aIMoBfKqEixEKdNnxEcAdxbIK1ZCLESO3WrwFC6DZmw4zkcxVGVrKYLAAOKACiAB4IGACutMCK+iCEyAC8aJi4BAkkyAA+qXoZhEYsylQILCB2yABGLGB48YS0yaaO9GIuktwA5FAQACZdADSOluKuXMhdVVEQQ1QqJZRlFWDIdUQAjNy66URZKTV1DbTKAPSnNDQAfje3yDiBEE0sMMgBUCxBjFiTo9ZQXWQcF6yFAZQAtgE4GBgNMIAA6UrlSrrBIAJm2aQaRWah3qBROVHOl2QtzuDyCz1e70+0H8kzajH+gOBKDBLEh0NhGARSJWQIwGGO3DCEWisQgDWaZmJlzJ8vujypbw+X3pXUZHQ4LJB7M5MLhiPMmv+3V6A2G5j+42600is0tCyoQA">playground</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> thing1: OnlyThingOne = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;hairColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> thing2: OnlyThingTwo = bothThings;<br><span class="hljs-comment">//    ~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br><span class="hljs-keyword">const</span> allThings: ExclusiveThing = &#123;<br><span class="hljs-comment">//    ~~~~~~~~~ Types of property &#x27;shirtColor&#x27; are incompatible.</span><br>  shirtColor: <span class="hljs-string">&#x27;red&#x27;</span>,<br>  hairColor: <span class="hljs-string">&#x27;blue&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>This works because no value is assignable to a <code>never</code> type. But because the property is <em>optional</em>, there&#39;s exactly one way out: not having that property.</p><p>This isn&#39;t just useful for unions. If you want to define a two dimensional vector type, for example, you might want to specifically disallow adding a third dimension:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>With this type, you&#39;ll get an error if you accidentally pass a three-dimensional vector to a function like <code>norm</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">norm</span>(<span class="hljs-params">v: Vector2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt(v.x ** <span class="hljs-number">2</span> + v.y ** <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-keyword">const</span> v = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">5</span>&#125;;<br><span class="hljs-keyword">const</span> d = norm(v);<br><span class="hljs-comment">//             ~ Types of property &#x27;z&#x27; are incompatible.</span><br></code></pre></td></tr></table></figure><p>This wouldn&#39;t be an error without the <code>z?: never</code> because the call is structurally valid, even though it&#39;s semantically incorrect.</p><p>&quot;Tags&quot; are another common way to make an or exclusive:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ThingOne &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;one&#x27;</span>;<br>  shirtColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">interface</span> ThingTwo &#123;<br>  <span class="hljs-keyword">type</span>: <span class="hljs-string">&#x27;two&#x27;</span>;<br>  hairColor: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Thing = ThingOne | ThingTwo;<br></code></pre></td></tr></table></figure><p>A string can&#39;t be both &quot;one&quot; <em>and</em> &quot;two&quot;, so there&#39;s no overlap between these types. This means there&#39;s no distinction between inclusive and exclusive or. This is one of many great reasons to use tagged unions when you can.</p><p>It&#39;s a fun exercise to define an exclusive or generic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;A, B&gt; = <span class="hljs-comment">/* ??? */</span>;<br></code></pre></td></tr></table></figure><p><a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwEEA0UBCA+KBeKAegCooB+CqYwgbgFgAoRgSwDtgIAnAMwEMBjaHFYAbEABUAFmwDmw6AG9GUKAGdpnYAGEA9iJ2cAXGuCdZ9Bism9mnXfs5ljrCADcuFgL4t2XPoKhhMSlZcQB3HSglSyhrW3sDY1VTc2U1DW09AycoF3dOL0ZQSCgAUQAPfhEAV1VmdxDWGXxYRCQgiWkm+QwOxplwnWwLRn4dVmSoACMdYEl+1RbolXVbTIdjAHJOCAATTbQ0uLssoyhNqZqIA8ZPEYZCQigpCFVodR1qkV2oXhERabQLicAyqUbjSZzWQARmMfS6chcLRmcwWFkeKhUAD8cbjnuBXlAdNwoGAQZBNCBzscEpxNr8dlA2GMALZgXjAZiXCAAOnBE2AUChTQATHDRJ1QhFkbN5gjVOinpjcXjxATFsTSeSuKBzqtNLT6bxGcydGyOVyRLz+ZM-iIFsYKlVavUIP0lowMcqVSr8ZANSSyToKbrNvr1gYjSbWKz2ZzuXyYuHaVsdvtDjEaactpdqtcM3dGJ6ni83gyhABpG2C8bBBGwsqVGp1BoIj0xFYZFPnNM3BiFhhjAVEiX9MWN50tt1tgjLTFZjbnXP524WIA">Give it a try!</a></p><p>Here&#39;s <a href="https://www.typescriptlang.org/play?#code/C4TwDgpgBAGg8gJQDwBUCMAaKKBMA+KAXgFgAoKCqACnSgDIoBvAbQGsoBLAOygFEAPAMYAbAK4ATCElYQQAewBm2HFhnyl6PAF0A-AC4oXCADcIAJwC+ASigAfMpWq56TNpx4CREqWsXZMUL4a+LoGRqaWVgDcZGTcwOYKAIaC0HBcwiAoABbcAObp0IwOUADOuWbAAMJywnJmBqXAZvkx5FDZSRxmNXVm+oYm5m0WcVwJZsmpUOmZOfkoAO5yTCWd3b31jc2tJeXd1bX1A+HDZKOkoJB8QmKlHKbzXHlEsIhIs1m5z4VYn095JZyPBtMiCORcJpQABGcmA2QBpVexXa+0qmwaUAA5GYIOIsRg1l0ekdMVjoWIIATzqDSAB6OnYbIQUrQcpyUTCcRQJLCYQw6DmMz1UpgiFQ+H5NAGf7fApGV6w+GItoMxwAP01Wuw4BZUD8YGFkEqIGx6xJfSxPNx7nBAFswElgBwKRAAHRiyHAKCS544GUZL4LZaKuEIuWlVWMyha7UoXVIg1G8ygbFow6W63Qbj2x3O10e0jgr08vmIgyeO4PCAA5FkNUx2OxnWQRNKQ1yY2prHpjFWpI2nNyB1Ol3Cd17CoZrbY3H4wntc0YgzkynU0gWWlqnIs6ADtIAaU9UIhczl0puXnujzldfaFF7pJXc-Xm+P3tPQb9FduomvNdvQhVnvDpiWXbEKVEKkFzfUggA">what I came up with</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> XOR&lt;T1, T2&gt; =<br>    (T1 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T2, keyof T1&gt;]?: <span class="hljs-built_in">never</span>&#125;) |<br>    (T2 &amp; &#123;[k <span class="hljs-keyword">in</span> Exclude&lt;keyof T1, keyof T2&gt;]?: <span class="hljs-built_in">never</span>&#125;);<br></code></pre></td></tr></table></figure><p>This is roughly the same as the <a href="https://github.com/krzkaczor/ts-essentials/blob/831ba8b6f3600872559c30e875ea74450953dc8a/lib/types.ts#L441-L445"><code>XOR</code> implementation</a> from the <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> library.</p><p>There&#39;s one caveat to the optional <code>never</code> trick that&#39;s worth knowing: unless you set the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/#exact-optional-property-types"><code>--exactOptionalPropertyTypes</code></a> compiler flag (added in TS 4.4), you&#39;re allowed to assign <code>undefined</code> to an optional never field:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector2 &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>  z?: <span class="hljs-built_in">never</span>;<br>&#125;<br><br><span class="hljs-comment">// OK with just --strict</span><br><span class="hljs-keyword">const</span> v: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><br><span class="hljs-comment">// Error with --exactOptionalPropertyTypes</span><br><span class="hljs-keyword">const</span> w: Vector2 = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-literal">undefined</span>&#125;;<br><span class="hljs-comment">//                              ~</span><br><span class="hljs-comment">//    Type &#x27;undefined&#x27; is not assignable to type &#x27;never&#x27;.</span><br></code></pre></td></tr></table></figure><p>So remember: in TypeScript, &quot;or&quot; is a union: <code>A | B</code> means either <code>A</code>, <code>B</code>, or both. Remember that &quot;both&quot; is a possibility, and you should either prevent it or handle it in your code.</p>]]></content>
    
    <summary type="html">
    
      This post looks at how TypeScript&#39;s type union operator (&lt;code&gt;|&lt;/code&gt; aka &quot;pipe&quot; or &quot;or&quot;) is really an &lt;i&gt;inclusive&lt;/i&gt; or, and how this can come as a surprise. It presents a few options for getting an &lt;i&gt;exclusive&lt;/i&gt; or if that&#39;s what you want, including the &quot;optional &lt;code&gt;never&lt;/code&gt;&quot; trick.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>In defense of interface: Using declaration merging to disable &quot;bad parts&quot;</title>
    <link href="https://effectivetypescript.com/2021/06/03/interface/"/>
    <id>https://effectivetypescript.com/2021/06/03/interface/</id>
    <published>2021-06-03T21:00:56.000Z</published>
    <updated>2021-06-03T20:58:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript&#39;s <code>interface</code> has gotten a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a> lately, largely because of <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>, a behavior of <code>interface</code> that&#39;s quite surprising when you first see it. This post explains what declaration merging is, <em>why</em> it is, and how you can use it to iron out some of JavaScript&#39;s and TypeScript&#39;s wrinkles in your own projects.</p><span id="more"></span><hr><p>I recently implemented a multiselect feature on my product at work. For the most part this involved changing my state from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureId: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectionState &#123;<br>  featureIds: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>and tracking down all the resulting errors. But I had a bug! Sometimes I&#39;d click on a feature and it wouldn&#39;t get selected. Or, weirder, it would select a random smattering of other, unrelated features.</p><p>I eventually realized that I&#39;d converted the existing code from:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureId(featureId);<br></code></pre></td></tr></table></figure><p>to</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(featureId));<br></code></pre></td></tr></table></figure><p>In my case <code>featureId</code> was something like <code>&quot;357&quot;</code> and, as you can see:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; new Set(&quot;357&quot;)<br>&#123;&quot;3&quot;, &quot;5&quot;, &quot;7&quot;&#125;<br></code></pre></td></tr></table></figure><p>The <code>new Set</code> constructor takes an iterable, and JavaScript <code>string</code>s let you iterate over the sequence of their characters. Instead of selecting feature 357, I was selecting features 3, 5 and 7.</p><p>The solution was to change it to:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([featureId]));  <span class="hljs-comment">// one element array</span><br></code></pre></td></tr></table></figure><p>Fixing one bug is fine, but it&#39;s better to find a way to make sure that same bug, or a whole class of bugs, never comes back. Since this is a blog about TypeScript, let&#39;s look at how we can use one of TypeScript&#39;s most head-scratching features to prevent ourselves (and our coworkers) from ever passing a <code>string</code> to the <code>Set</code> constructor again.</p><h2 id="What-is-Declaration-Merging"><a href="#What-is-Declaration-Merging" class="headerlink" title="What is Declaration Merging?"></a>What is Declaration Merging?</h2><p>One of TypeScript&#39;s most surprising behaviors is <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Product &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">// ...</span><br><br><span class="hljs-keyword">interface</span> Product &#123;<br>  price: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> furby: Product;<br>furby.name;  <span class="hljs-comment">// ok, type is string</span><br>furby.price;  <span class="hljs-comment">// ok, type is number</span><br></code></pre></td></tr></table></figure><p>Even though they may be separated by thousands of lines of code or in entirely different modules, the two declarations of the <code>Product</code> interface are <em>merged</em> into a single type with both <code>name</code> and <code>price</code> properties.</p><p>Declaration merging is surprising and it&#39;s given <code>interface</code> a bit of a <a href="https://twitter.com/kentcdodds/status/1392678508954980353">bad rap</a>. <em>Effective TypeScript</em> even suggests using <code>type</code> instead of <code>interface</code> to avoid it (type aliases are not merged; see Item 13: Know the Differences Between <code>type</code> and <code>interface</code>).</p><p>But it&#39;s not all bad! Let&#39;s look at why TypeScript merges declarations before we use this to ban the evil <code>Set</code> constructor.</p><h2 id="Why-Declaration-Merging"><a href="#Why-Declaration-Merging" class="headerlink" title="Why Declaration Merging?"></a>Why Declaration Merging?</h2><p>Declaration merging really shines when you look at the <a href="https://www.typescriptlang.org/tsconfig#lib"><code>lib</code> setting</a> in <code>tsconfig.json</code>, which models the ECMAScript version that will be available at runtime.</p><p>The file <code>lib.es5.core.d.ts</code> <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1220">contains declarations</a> for built-in methods on the <code>Array</code> type as of 2009 vintage ES5:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  length: <span class="hljs-built_in">number</span>;<br>  pop(): T | <span class="hljs-literal">undefined</span>;<br>  push(...items: T[]): <span class="hljs-built_in">number</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>ES2015 added a few new methods, for example <code>Array.prototype.find</code>. When you add <code>es2015</code> to the <code>lib</code> setting in <code>tsconfig.json</code>, TypeScript pulls in <code>lib.es2015.core.d.ts</code>, which <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.core.d.ts#L21-L32">defines those methods</a>, too:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Array&lt;T&gt; &#123;<br>  find&lt;S <span class="hljs-keyword">extends</span> T&gt;(predicate: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">void</span>, value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> value is S, thisArg?: <span class="hljs-built_in">any</span>): S | <span class="hljs-literal">undefined</span>;<br>  find(predicate: <span class="hljs-function">(<span class="hljs-params">value: T, index: <span class="hljs-built_in">number</span>, obj: T[]</span>) =&gt;</span> unknown, thisArg?: <span class="hljs-built_in">any</span>): T | <span class="hljs-literal">undefined</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The net effect when these declarations are merged is that TypeScript will only know about <code>find</code> if your <code>lib</code> includes <code>es2015</code> (or later). Which is exactly what you want!</p><p>I assume that <code>lib</code> was the motivation behind declaration merging. But you can make use of it in your own code, too. Let&#39;s use it to ban the &quot;evil&quot; <code>Set</code> constructor.</p><h2 id="Banning-the-Evil-Set-Constructor"><a href="#Banning-the-Evil-Set-Constructor" class="headerlink" title="Banning the Evil Set Constructor"></a>Banning the Evil <code>Set</code> Constructor</h2><p>Recall that we want to disallow <code>new Set(&quot;string&quot;)</code> in our own code without affecting other invocations of the <code>Set</code> constructor.</p><p>Here&#39;s the <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.collection.d.ts#L58-L71">declaration of <code>Set</code></a> from <code>lib.es2015.collections.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Set&lt;T&gt; &#123;<br>    add(value: T): <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">delete</span>(value: T): <span class="hljs-built_in">boolean</span>;<br>    has(value: T): <span class="hljs-built_in">boolean</span>;<br>    <span class="hljs-keyword">readonly</span> size: <span class="hljs-built_in">number</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T = <span class="hljs-built_in">any</span>&gt;(values?: <span class="hljs-keyword">readonly</span> T[] | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>    <span class="hljs-keyword">readonly</span> prototype: <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">Set</span>: SetConstructor;<br></code></pre></td></tr></table></figure><p>Sometimes type declarations model the type of an instance (<code>Set</code>) and the type of the class (<code>SetConstructor</code>) separately. In this case we want to merge something into <code>SetConstructor</code>.</p><p>There&#39;s also an <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es2015.iterable.d.ts#L169-L185">overload of the constructor</a> in <code>lib.es2015.iterable.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>    <span class="hljs-keyword">new</span> &lt;T&gt;(iterable?: Iterable&lt;T&gt; | <span class="hljs-literal">null</span>): <span class="hljs-built_in">Set</span>&lt;T&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>We&#39;ll want to overload this one. Put this declaration in a <code>.d.ts</code> file somewhere in your project scope, e.g. <code>declarations/ban-evil-set-constructor.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SetConstructor &#123;<br>  <span class="hljs-keyword">new</span> (str: <span class="hljs-built_in">string</span>): <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>When this gets merged with the other <code>SetConstructor</code> declarations, the net effect is that the problematic usage will trigger a type error without affecting the others:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">setSelectedFeatureIds(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-string">&#x27;123&#x27;</span>));<br><span class="hljs-comment">//                    ~~~~~~~~~~~~~~</span><br><span class="hljs-comment">// Argument of type &#x27;void&#x27; is not assignable to parameter</span><br><span class="hljs-comment">//   of type &#x27;ReadonlySet&lt;string&gt;&#x27;.</span><br>setSelectedFeatureIds([<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>]);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><h2 id="What-else-can-you-do-with-this"><a href="#What-else-can-you-do-with-this" class="headerlink" title="What else can you do with this?"></a>What else can you do with this?</h2><p>That was neat! What else can we do with this technique?</p><p>A TypeScript pet peeve of mine has always been that <code>JSON.parse</code> returns a dangerous <code>any</code> type. This <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.es5.d.ts#L1052-L1079">declaration</a> comes from <code>lib.es5.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> JSON &#123;<br>    parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">var</span> <span class="hljs-built_in">JSON</span>: <span class="hljs-built_in">JSON</span>;<br></code></pre></td></tr></table></figure><p>A safer return type would be <code>unknown</code>. This type was only <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type">introduced in TypeScript 3.0</a> (July 2018) and changing this declaration would be a hugely breaking change for the TypeScript ecosystem as a whole. But there&#39;s no reason you can&#39;t &quot;fix&quot; it in your own project!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> JSON &#123;<br>  parse(text: <span class="hljs-built_in">string</span>, reviver?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-built_in">this</span>: <span class="hljs-built_in">any</span>, key: <span class="hljs-built_in">string</span>, value: <span class="hljs-built_in">any</span></span>) =&gt;</span> <span class="hljs-built_in">any</span>): unknown;<br>&#125;<br></code></pre></td></tr></table></figure><p>Now you won&#39;t be able to use the result of <code>JSON.parse</code> without going through a type assertion or type guard first:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseType &#123;<br>  lastModifiedAt: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> obj1 = <span class="hljs-built_in">JSON</span>.parse(apiResponse);<br>obj1.lastModifiedAt;<br><span class="hljs-comment">// ~~~~~~~~~~~~~~~ Object is of type &#x27;unknown&#x27;.</span><br><br><span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(apiResponse) <span class="hljs-keyword">as</span> ResponseType;<br>obj2.lastModifiedAt; <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>You can do something similar with <code>Response.prototype.json()</code>, which is used in the <code>fetch</code> API. Its <a href="https://github.com/microsoft/TypeScript/blob/87c5b6a752f8ac3239ac05fbcbbb889dc7c0019d/lib/lib.dom.d.ts#L2622-L2630">declaration</a> comes from <code>interface Body</code> in <code>lib.dom.d.ts</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Body &#123;<br>  <span class="hljs-keyword">readonly</span> body: ReadableStream&lt;<span class="hljs-built_in">Uint8Array</span>&gt; | <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">readonly</span> bodyUsed: <span class="hljs-built_in">boolean</span>;<br>  arrayBuffer(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">ArrayBuffer</span>&gt;;<br>  blob(): <span class="hljs-built_in">Promise</span>&lt;Blob&gt;;<br>  formData(): <span class="hljs-built_in">Promise</span>&lt;FormData&gt;;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">any</span>&gt;;<br>  text(): <span class="hljs-built_in">Promise</span>&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you merge in a new declaration for <code>json()</code>, you can get <code>unknown</code> types back instead of <code>any</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// declarations/safe-json.d.ts</span><br><span class="hljs-keyword">interface</span> Body &#123;<br>  json(): <span class="hljs-built_in">Promise</span>&lt;unknown&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Declaration merging is surprising and controversial, but it&#39;s not all bad. TypeScript uses it to great effect in modeling which library methods will be available at runtime. And you can use it modify or disallow those methods as you like for your project.</p><p>A few notes to conclude:</p><ul><li><p>As with all type-level constructs, this only affects type checking. The runtime behavior the <code>Set</code> constructor is not affected, either in your own code or in library code.</p></li><li><p>This technique is best used either to make the built-in types stricter, or to disallow certain things. If you add declarations that don&#39;t reflect reality at runtime, you can create a really confusing situation. Incorrect types can be worse than no types.</p></li><li><p>Making a constructor return <code>void</code> isn&#39;t itself an error. So calling <code>new Set(&quot;string&quot;)</code> on its own will not cause a type error. You only get the error when you try to use the resulting value, which gets a <code>void</code> type. This is fine in our case, but if the method you want to &quot;knock out&quot; already returns <code>void</code>, then this technique won&#39;t work as well. (link to &quot;user-defined type error&quot; issue)</p></li></ul><p>References:</p><ul><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">declaration merging</a>.</li><li>TypeScript Handbook page on <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/templates/global-modifying-module-d-ts.html#global-modifying-modules">global augmentation</a>.</li></ul><!--References:- KCD tweet about how augmentation makes him prefer `type`: https://twitter.com/kentcdodds/status/1392678508954980353- Item 13: Know the Differences Between `type` and `interface`- Rob Palmer tweet (blog post?) about compiler performance implications of `type` vs. `interface`:  - https://twitter.com/robpalmer2/status/1319188885197422594?lang=en  - https://www.techatbloomberg.com/blog/10-insights-adopting-typescript-at-scale/  - "9. Generated declarations can inline types from dependencies"- Is "augmentation" the right term for this? Declaration merging?  - https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation  - "Declaration Merging" is the general name  - "Augmentation" refers specifically to patching a module or "global augmentation"- The TS handbook calls out global augmentation as "somewhat dangerous":Notes to hit:- Declaration merging is surprising- Merging works best for adding methods to the standard library, e.g. `lib.dom.d.ts`- The mistake I made with `new Set(string)`-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript&amp;#39;s &lt;code&gt;interface&lt;/code&gt; has gotten a bit of a &lt;a href=&quot;https://twitter.com/kentcdodds/status/1392678508954980353&quot;&gt;bad rap&lt;/a&gt; lately, largely because of &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/declaration-merging.html&quot;&gt;declaration merging&lt;/a&gt;, a behavior of &lt;code&gt;interface&lt;/code&gt; that&amp;#39;s quite surprising when you first see it. This post explains what declaration merging is, &lt;em&gt;why&lt;/em&gt; it is, and how you can use it to iron out some of JavaScript&amp;#39;s and TypeScript&amp;#39;s wrinkles in your own projects.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Seven Sources of Unsoundness in TypeScript</title>
    <link href="https://effectivetypescript.com/2021/05/06/unsoundness/"/>
    <id>https://effectivetypescript.com/2021/05/06/unsoundness/</id>
    <published>2021-05-07T00:00:00.000Z</published>
    <updated>2022-03-01T14:44:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/square-peg-round-hole.png" title="A square peg in a round hole" width="212" height="197" style="float: right; padding-left: 10px;">Hang out on the internet much and you&#39;ll hear gripes about how TypeScript isn&#39;t &quot;sound,&quot; and that this makes it a poor choice of language. In this post, I&#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&#39;s never a good idea to listen to people on the internet!</p><span id="more"></span><p>Roughly speaking, a language is &quot;sound&quot; if the static type of every symbol is guaranteed to be compatible with its runtime value.</p><p>Here&#39;s a simple example of a sound type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = <span class="hljs-built_in">Math</span>.random();<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>TypeScript infers a static type of <code>number</code> for <code>x</code>, and this is sound: whatever value <code>Math.random()</code> returns at runtime, it will be a <code>number</code>. This doesn&#39;t mean that <code>x</code> could be any <code>number</code> at runtime: a more precise type would be the half-open interval <code>[0, 1)</code>, but TypeScript has no way to express this. <code>number</code> is good enough. If you remember the <a href="https://wp.stolaf.edu/it/gis-precision-accuracy/">famous statistics dartboard</a>, soundness is more about accuracy than precision.</p><p>Here&#39;s an example of unsoundness in TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];  <span class="hljs-comment">// type is number[]</span><br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>The static type of <code>x</code> is inferred as <code>number</code>, but at runtime its value is <code>undefined</code>, which is not a <code>number</code>. So this is unsound.</p><p>Many programming languages include proofs of soundness, or at least purport to be sound. Fun fact: in 2016, two researchers <a href="https://dl.acm.org/doi/10.1145/2983990.2984004">discovered that Java had become unsound</a>! As we saw above, TypeScript is emphatically <em>not</em> sound. In fact, <a href="https://github.com/Microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">soundness is not a design goal</a> of TypeScript at all. Instead, TypeScript favors convenience and the ability to work with existing JavaScript libraries.</p><p>That being said, unsoundness can lead to crashes and other problems at runtime, so it&#39;s a good idea to understand the ways that it can arise.</p><p>Here are the seven sources of unsoundness:</p><ol><li><a href="#any"><code>any</code></a></li><li><a href="#Type-Assertions">Type Assertions</a></li><li><a href="#Object-and-array-lookups">Object and array lookups</a></li><li><a href="#Inaccurate-type-definitions">Inaccurate type definitions</a></li><li><a href="#The-thing-with-variance-and-arrays">The thing with variance and arrays</a></li><li><a href="#Function-calls-don-39-t-invalidate-refinements">Function calls don&#39;t invalidate refinements</a></li><li><a href="#There-Are-Five-Turtles">There Are Five Turtles</a></li></ol><p>For each of these, I&#39;ll assess how common it is in practice, show what it looks like, and explain how you can avoid it.</p><p>Note that this post assumes you&#39;re using <code>--strict</code>. If you&#39;re not, then there are more ways that TypeScript is unsound.</p><h2 id="any"><a href="#any" class="headerlink" title="any"></a><code>any</code></h2><p><strong>How often does this occur?</strong> It depends how disciplined you are about not using <code>any</code>! But built-ins like <code>JSON.parse</code> that return <code>any</code> make it hard to avoid entirely.</p><p>If you &quot;put an <code>any</code> on it&quot;, then anything goes. The static types may or may not have anything to do with real runtime types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// static type of x is number, runtime type is string</span><br>&#125;<br><span class="hljs-keyword">const</span> num: <span class="hljs-built_in">any</span> = <span class="hljs-string">&#x27;forty two&#x27;</span>;<br>alertNumber(num);<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The solution here is simple: limit your use of <code>any</code> or, better, don&#39;t use it at all! Chapter 5 of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> is all about how to mitigate and avoid the static type disaster that is <code>any</code>. The highlights are to limit the scope of <code>any</code> and to use <code>unknown</code> as a safer alternative when possible.</p><h2 id="Type-Assertions"><a href="#Type-Assertions" class="headerlink" title="Type Assertions"></a>Type Assertions</h2><p><strong>How often does this occur?</strong> Often (though not as often as object and array lookups).</p><p>The slightly less offensive cousin of <code>any</code> is the &quot;type assertion&quot; (<em>not</em> the &quot;cast&quot;, see my <a href="https://effectivetypescript.com/2021/02/03/pet-peeves/">rant on this terminology</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">alertNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  alert(x.toFixed(<span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br>alertNumber(x1);<br><span class="hljs-comment">//          ~~ ... Type &#x27;null&#x27; is not assignable to type &#x27;number&#x27;.</span><br>alertNumber(x1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>);  <span class="hljs-comment">// type checks, but might blow up at runtime</span><br></code></pre></td></tr></table></figure><p>The <code>as number</code> in the last line is the type assertion, and it makes the error go away. It&#39;s the <a href="https://xkcd.com/149/">sudo make me a sandwich</a> of the type system.</p><p>Type assertions often come up in the context of input validation. You might fetch JSON via an API and give it a type using an assertion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json() <span class="hljs-keyword">as</span> FunFact;<br></code></pre></td></tr></table></figure><p>Nothing ensures that this API is <em>actually</em> returning a <code>FunFact</code>. You&#39;re simply asserting that it is. If it isn&#39;t, then the static type won&#39;t match reality.</p><p>What can you do about this? You can replace many assertions with conditionals (<code>if</code> statements or ternary operators):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x1 = <span class="hljs-built_in">Math</span>.random() || <span class="hljs-literal">null</span>;  <span class="hljs-comment">// type is number | null</span><br><span class="hljs-keyword">if</span> (x1 !== <span class="hljs-literal">null</span>) &#123;<br>  alertNumber(x1);  <span class="hljs-comment">// ok, x1&#x27;s type is number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Within the <code>if</code> block, the static type of <code>x1</code> is narrowed based on the condition, so the type assertion isn&#39;t needed.</p><p>For input validation, you can write a <a href="https://basarat.gitbook.io/typescript/type-system/typeguard">type guard function</a> to do some run-time type checking:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFunFact</span>(<span class="hljs-params">data: unknown</span>): <span class="hljs-title">data</span> <span class="hljs-title">is</span> <span class="hljs-title">FunFact</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> data &amp;&amp; <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;fact&#x27;</span> <span class="hljs-keyword">in</span> data <span class="hljs-comment">/* &amp;&amp; ... */</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">&#x27;/api/fun-fact&#x27;</span>);<br><span class="hljs-keyword">const</span> fact = <span class="hljs-keyword">await</span> response.json();<br><span class="hljs-keyword">if</span> (!isFunFact(fact)) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">`Either it wasn&#x27;t a fact or it wasn&#x27;t fun`</span>);<br>&#125;<br><span class="hljs-comment">// type of fact is now FunFact!</span><br></code></pre></td></tr></table></figure><p>Of course, you&#39;re still asserting that your type guard really guards the type. If you want to be more systematic about it, there are many possible approaches. One is to use a tool like <a href="https://github.com/colinhacks/zod">Zod</a> that&#39;s designed to solve this problem. Another is to generate JSON Schema from your TypeScript types (e.g. using <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a>) and validate the shape of your data at runtime using that. <a href="https://github.com/danvk/crosswalk">crosswalk</a> takes this approach.</p><!--The bit about about type guards being unchecked is called out here https://twitter.com/sebmck/status/1142601008251469824--><h2 id="Object-and-array-lookups"><a href="#Object-and-array-lookups" class="headerlink" title="Object and array lookups"></a>Object and array lookups</h2><p><strong>How often does this occur?</strong> All the time.</p><p>TypeScript doesn&#39;t do any sort of bounds checking on array lookups, and this can lead directly to unsoundness and runtime errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x = xs[<span class="hljs-number">3</span>];  <span class="hljs-comment">// static type is number but runtime type is undefined.</span><br>alert(x.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">// no error, throws at runtime:</span><br><span class="hljs-comment">// Cannot read property &#x27;toFixed&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>The same can happen when you reference a property on an object with an index type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string but runtime type is undefined.</span><br></code></pre></td></tr></table></figure><p>Why does TypeScript allow this sort of code? Because it&#39;s extremely common and because it&#39;s quite difficult to prove whether any particular index/array access is valid. If you&#39;d like TypeScript to try, there&#39;s a <a href="https://www.typescriptlang.org/tsconfig#noUncheckedIndexedAccess"><code>noUncheckedIndexedAccess</code></a> option. If you turn it on, it finds the error in the first example but also flags perfectly valid code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><span class="hljs-keyword">const</span> x2 = xs[<span class="hljs-number">2</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x2.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p><code>noUncheckedIndexedAccess</code> is at least smart enough to understand some common array constructs:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>  <span class="hljs-built_in">console</span>.log(x.toFixed(<span class="hljs-number">1</span>));  <span class="hljs-comment">// ok</span><br>&#125;<br><span class="hljs-keyword">const</span> squares = xs.map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * x);  <span class="hljs-comment">// also ok</span><br></code></pre></td></tr></table></figure><p>If you&#39;re concerned about unsafe access to specific arrays or objects, you can explicitly add <code>| undefined</code> to their value types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs: (<span class="hljs-built_in">number</span> | <span class="hljs-literal">undefined</span>)[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> x3 = xs[<span class="hljs-number">3</span>]; <span class="hljs-comment">// static type is number | undefined</span><br>alert(x3.toFixed(<span class="hljs-number">1</span>));<br><span class="hljs-comment">//    ~~ Object is possibly &#x27;undefined&#x27;.</span><br><br><span class="hljs-keyword">type</span> IdToName = &#123; [id: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span> &#125;;<br><span class="hljs-keyword">const</span> ids: IdToName = &#123;<span class="hljs-string">&#x27;007&#x27;</span>: <span class="hljs-string">&#x27;James Bond&#x27;</span>&#125;;<br><span class="hljs-keyword">const</span> agent = ids[<span class="hljs-string">&#x27;008&#x27;</span>];  <span class="hljs-comment">// static type is string | undefined</span><br>alert(agent.toUpperCase());<br><span class="hljs-comment">//    ~~~~~ Object is possibly &#x27;undefined&#x27;.</span><br></code></pre></td></tr></table></figure><p>The advantage of this approach over <code>noUncheckedIndexedAccess</code> is that it lets you limit the scope (and presumably false positives) of that flag. The disadvantage is that it lacks the smarts of the flag: the <code>for-of</code> loop will give you errors with this approach. It also introduces the possibility that you <code>push</code> an <code>undefined</code> onto the array.</p><p>Finally, it&#39;s often possible to rework your code to avoid the need for these sorts of lookups. Say your API looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuItem &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  displayText: <span class="hljs-built_in">string</span>;<br>  icon?: <span class="hljs-built_in">string</span>;<br>  hoverText?: <span class="hljs-built_in">string</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">id: <span class="hljs-built_in">string</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This API is very likely to lead to lookups in the <code>onSelectItem</code> callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125; = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>Menu(&#123;<br>  menuItems,<br>  <span class="hljs-function"><span class="hljs-title">onSelectItem</span>(<span class="hljs-params">id</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> menuItem = menuItems[id]; <span class="hljs-comment">// oh no! object lookup!</span><br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>Instead, you might pass the <code>MenuItem</code> itself to the callback:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> MenuProps &#123;<br>  menuItems: &#123;[id: <span class="hljs-built_in">string</span>]: MenuItem&#125;;<br>  onSelectItem: <span class="hljs-function">(<span class="hljs-params">menuItem: MenuItem</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is safer from a static types perspective.</p><h2 id="Inaccurate-type-definitions"><a href="#Inaccurate-type-definitions" class="headerlink" title="Inaccurate type definitions"></a>Inaccurate type definitions</h2><p><strong>How often does this occur?</strong> Surprisingly rarely, but it&#39;s annoying and surprising when it does!</p><p>The type declarations for a JavaScript library are like a giant type assertion: they claim to statically model the runtime behavior of the library but there&#39;s nothing that guarantees this. (Unless, that is, the library is written in TypeScript, the declarations are generated by <code>tsc</code> and the library doesn&#39;t break any of the rules in this post!)</p><p>It&#39;s hard to show a specific example here since these kinds of bugs tend to get fixed once you highlight them, particularly for declarations on DefinitelyTyped. But here&#39;s <a href="https://github.com/alex3165/react-mapbox-gl/issues/776">one example</a> in react-mapbox-gl that&#39;s been around for years. (Not to pick on react-mapbox-gl, we love you alex3165!)</p><p>How do you work around this? The best way is to fix the bug! For types on DefinitelyTyped (<code>@types</code>), the turnaround time on this is usually a week or less. If this isn&#39;t an option, you can work around some issues via <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html">augmentation</a> or, in the worst case, a type assertion.</p><p>It&#39;s also worth noting that some functions have types that are just very hard to model statically. Take a look at the parameter list for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_function_as_a_parameter"><code>String.prototype.replace</code></a> for a head-scratching example. There are also some functions that are <a href="https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598">incorrectly typed for historical reasons</a>, e.g. <code>Object.assign</code>.</p><h2 id="The-thing-with-variance-and-arrays"><a href="#The-thing-with-variance-and-arrays" class="headerlink" title="The thing with variance and arrays"></a>The thing with variance and arrays</h2><p><strong>How often does this occur?</strong> I&#39;ve never personally run into this, but I also tend not to use very deep or complex type hierarchies.</p><p>This is a famous one. TypeScript TL <a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> <a href="https://github.com/microsoft/TypeScript/issues/9825#issuecomment-234115900">offers</a> this example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat()];<br>addDogOrCat(z); <span class="hljs-comment">// Sometimes puts a Dog in a Cat array, sad!</span><br></code></pre></td></tr></table></figure><p>What can <em>you</em> do about this? The best solution is to avoid mutating array parameters. You can enforce this via <code>readonly</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDogOrCat</span>(<span class="hljs-params">arr: <span class="hljs-keyword">readonly</span> Animal[]</span>) </span>&#123;<br>  arr.push(<span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat());<br>  <span class="hljs-comment">//  ~~~~ Property &#x27;push&#x27; does not exist on type &#x27;readonly Animal[]&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This will prevent this type of unsoundness. Instead, you might write the example this way:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dogOrCat</span>(<span class="hljs-params"></span>): <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span> ? <span class="hljs-keyword">new</span> Dog() : <span class="hljs-keyword">new</span> Cat();<br>&#125;<br><br><span class="hljs-keyword">const</span> z: Cat[] = [<span class="hljs-keyword">new</span> Cat(), dogOrCat()];<br><span class="hljs-comment">//                           ~~~~~~~~~~ error, yay!</span><br><span class="hljs-comment">// Type &#x27;Animal&#x27; is missing the following properties from type &#x27;Cat&#x27;: ...</span><br></code></pre></td></tr></table></figure><p><em>(See <a href="https://www.typescriptlang.org/play?ssl=5&ssc=1&pln=6&pc=1#code/MYGwhgzhAECCB2BLAtmE0DeBfAsAKH1EhgFkxlV0BTADwBcr4ATGBFNTfaaRCMitAF46AJwCuVANz5cBPESjQAwmDrRaDZqXKVOebrxV1h4qVx4QAIgHsA5oIBmaCGbyzC4RTdvr6jFtD8uhjmvN4mEtL6FkaOzq7ueA5i8MB0iNbw0GBMTN4A8iJGABRgIiIAXHBIlADaALoAlHrcZSIAdAAOYhAAFsVkdL3tImDM1sjFzQB80AAM7QCs0AD80PBUAO7Q3lPQVRvbJY2NUYnJqemZ0LZUdEHOU1UPIA0t0CJ3YiJZDWf4+AA9IDoAAhfAXNIZLK9SAlNpVNh1JrvT50b5ZNrtCATKjFKjQQSzAmIeAQOhjYBUawOZSqU4yQiZcnQGjPHRoN6CG53F4QKZRYDMtQAT0J0FhEBKNAZcmByiZZLUAC8qkYudBaoc6XQpvUojk8nZCiVladoPL5QBlXHpZBUGDdOgwMA7Ow8TE67LlMAigA00AgOQAhPggA">full playground example</a>.)</em></p><p>Why does TypeScript allow this? Presumably because <code>readonly</code> wasn&#39;t always part of the language. In the future you could imagine a &quot;strict&quot; option that would prevent these types of errors. In the initial example, the <code>addDogOrCat</code> call should only be allowed with a subtype of <code>Animal[]</code> if it&#39;s declared as <code>readonly Animal[]</code>. This will have the side effect of pushing libraries to get better about declaring parameters <code>readonly</code>, which would be a very good thing!</p><p>TypeScript used to have more issues around function calls and variance, and you might still see gripes about this online. But these were largely fixed with <code>--strictFunctionTypes</code>, which was <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-6.html#strict-function-types">introduced with TypeScript 2.6</a> in November 2017.</p><h2 id="Function-calls-don-39-t-invalidate-refinements"><a href="#Function-calls-don-39-t-invalidate-refinements" class="headerlink" title="Function calls don&#39;t invalidate refinements"></a>Function calls don&#39;t invalidate refinements</h2><p><strong>How often does this come up?</strong> I&#39;ve rarely seen it myself, though this may depend on your style and the libraries that you use.</p><p>Here&#39;s some code that doesn&#39;t look too suspicious at first glance (at least from a type safety perspective):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> FunFact &#123;<br>  fact: <span class="hljs-built_in">string</span>;<br>  author?: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (fact.author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = fact.author.blink();  <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Depending on what <code>processor</code> does, however, the call to <code>blink()</code> might throw at runtime:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">&#x27;Peanuts are not actually nuts&#x27;</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>);<br><span class="hljs-comment">// Type checks, but throws `Cannot read property &#x27;blink&#x27; of undefined`.</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>if (fact.author)</code> refines the type of <code>fact.author</code> from <code>string | undefined</code> to <code>string</code>. This is sound. However, the call to <code>processor(fact)</code> <em>should</em> invalidate this refinement. The type of <code>fact.author</code> should revert back to <code>string | undefined</code> because TypeScript has no way of knowing what the callback will do to our refined fact.</p><p>Why does TypeScript allow this? Because most functions don&#39;t mutate their parameters, and this sort of pattern is common in JavaScript.</p><p>How can you avoid this? A simple way is to avoid deeply mutating your parameters. You can enforce that callbacks do this by passing them a <code>Readonly</code> version of the object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: Readonly&lt;FunFact&gt;) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br>processFact(<br>  &#123;<span class="hljs-attr">fact</span>: <span class="hljs-string">`Peanuts aren&#x27;t actually nuts`</span>, <span class="hljs-attr">author</span>: <span class="hljs-string">&#x27;Botanists&#x27;</span>&#125;,<br>  f =&gt; <span class="hljs-keyword">delete</span> f.author<br>  <span class="hljs-comment">//          ~~~~~~~~</span><br>  <span class="hljs-comment">// The operand of a &#x27;delete&#x27; operator cannot be a read-only property.</span><br>);<br></code></pre></td></tr></table></figure><p>(Note that <code>Readonly</code> is shallow; you&#39;ll need to use a tool like <a href="https://github.com/krzkaczor/ts-essentials">ts-essentials</a> to get a <code>DeepReadonly</code>.)</p><p>You can also avoid this issue by refining a value itself, rather than the object that contains it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFact</span>(<span class="hljs-params">fact: FunFact, processor: (fact: FunFact) =&gt; <span class="hljs-built_in">void</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;author&#125; = fact;<br>  <span class="hljs-keyword">if</span> (author) &#123;<br>    processor(fact);<br>    <span class="hljs-built_in">document</span>.body.innerHTML = author.blink();  <span class="hljs-comment">// safe</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Because <code>author</code> is a primitive type (not an object), it cannot be changed by the callback and the <code>blink()</code> call is safe.</p><!--Here's an alternate example using refinements from string|number and a global (via https://twitter.com/sebmck/status/1146524039227174914):https://www.typescriptlang.org/play?strict=true#code/DYUwLgBAbghsBcEB2BXAtgIxAJwgHwgGcxsBLJAcwgF4IByOgbgChmAzFJAYzFIHskEGIUKkKSAHLos2ABQBKCAG9mEaHBoQATCwC+rDt14CIaGOQXLVEUmwiywATwAOIPndjAa1WnVSYcOkUVNTUwAAtsPgB3ZBBYgFFsKLk6CT5kaRxCIWBgGJAAEyCWNX1rAHoKiAARATpIJBAioSRHGyRC0mwQHn5BcJwQa2FRcSkAuXkWSuqAFXDSHMJwvhRgQog2c2AAGhswOhyYTMnrLgFiIhJEYjJKTU89IA--><h2 id="There-Are-Five-Turtles"><a href="#There-Are-Five-Turtles" class="headerlink" title="There Are Five Turtles"></a>There Are Five Turtles</h2><p><strong>How often does this come up?</strong> More or less never; if you run into it in real-world code, you might get mentioned at tsconf!</p><p>Anders explains this best:</p><iframe width="560" height="315" src="https://www.youtube.com/embed/wpgKd-rwnMw?start=1714" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>I&#39;ve never been able to find the issue he references in the talk. And I&#39;ve heard rumors that there are now seven turtles. If you know more about either of these, please let me know in the comments!</p><hr><p>Those are the seven sources! But maybe there are eight, or nine, or ten. If you have an example of unsoundness that doesn&#39;t fit into any of these categories, please <a href="https://twitter.com/danvdk">let me know</a> and I&#39;ll update the post.</p><p>Updates:</p><ul><li><a href="https://twitter.com/SeaRyanC">Ryan Cavanaugh</a> offers <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBAhjAvDAFADwPwC4ZgK4C2ARgKYBOAlEgHwyYB0UIAYgJZokAmKFA3ALAAoUJFhEcPGjABuIVpyTwBw8NBjAJEbDGhlWYAOZVEtWfMVFlwFACIbfIUA">an example</a> that stems from how TypeScripthandles function assignability and optional parameters.</li><li>Ryan offers <a href="https://twitter.com/SeaRyanC/status/1397979078150344707">another example</a> stemming from a loss of information when you assign to a type with optional properties.</li><li>Oliver Ash <a href="https://twitter.com/OliverJAsh/status/1404719755324497922">offers</a> <a href="https://www.typescriptlang.org/play?strict=true#code/MYewdgzgLgBAhjAvDA3jAZiEAuV9cAUAlEgHwwDkcFMAvnQNwBQoksARknpjnu4SUTkK7GvVrMW4aDAC2AUwBOAc3lcAPAEEANDABCpAnFw6Y-fYPIE0AOjtxddm51pFmrGcC4KV8o7vY3FhseGzhiBhgAeiiYMBAYABUAZRglRRBFMwBXWCgACwyAdwh4WEVssCgASwUAQgbg0PYIpik2GAATLhQnBxgndgkmTpCsMIiYaNj0zJGxkGdWoA">an example</a> stemming from how TypeScript models object spread as a deep intersection between generics whereas it really operates as a shallow intersection. See <a href="https://github.com/microsoft/TypeScript/issues/28326">design notes</a> on this issue.</li></ul><!--Another one from Ryan around assignability issues with optional properties and index signatureshttps://twitter.com/SeaRyanC/status/1397979078150344707Is this related to my issues?https://github.com/microsoft/TypeScript/issues/41418https://github.com/microsoft/TypeScript/issues/43045Or related to distinguising undefined and missing?https://github.com/microsoft/TypeScript/issues/13195Anders has a PR out to fix this!https://github.com/microsoft/TypeScript/pull/43947--><p>Further reading:</p><ul><li><a href="https://frenchy64.github.io/2018/04/07/unsoundness-in-untyped-types.html">Are unsound type systems wrong?</a>, a discussion of types of soundness and TypeScript&#39;s deliberate choice to be unsound (see also <a href="https://news.ycombinator.com/item?id=16780068">HN Comments</a>).</li><li><a href="https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness">A Note on Soudness</a> from the TypeScript handbook; this page gives background on some of TypeScript&#39;s design decisions.</li><li><a href="https://www.typescriptlang.org/play?strictFunctionTypes=false&q=209#example/soundness">TypeScript Playground Soundness example</a>; this is a built-in example on the TypeScript Playground. Note that it does not have <code>strictFunctionTypes</code> enabled.</li></ul><!--https://github.com/microsoft/TypeScript-Handbook/issues/1059No excess property checks in object types with spread-> This is not unsoundness, just misunderstanding excess property checkingIncorrect definition of spread and Object.assign-> This is a spurious error, but that's not unsoundness, is it?-> This just seems like a bug-> Can easily be modified to be unsound.See https://github.com/microsoft/TypeScript/pull/28553#issuecomment-440004598Maybe this falls under "incorrect library definitions"?Hacker News thread from 2017:https://news.ycombinator.com/item?id=15659657  Counterexamples here seem to revolve around variance, which has not been an issue for a while.Luca Cardelli, 1996 (quoted in _Types and Programming Languages_):> It turns out that a fair amount of careful analysis is required to avoid false and embarrassing claims of type soundness for programming languages. As a consequence, the classification, description, and study of type systems has emerged as a formal discipline.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/square-peg-round-hole.png&quot; title=&quot;A square peg in a round hole&quot; width=&quot;212&quot; height=&quot;197&quot; style=&quot;float: right; padding-left: 10px;&quot;&gt;Hang out on the internet much and you&amp;#39;ll hear gripes about how TypeScript isn&amp;#39;t &amp;quot;sound,&amp;quot; and that this makes it a poor choice of language. In this post, I&amp;#39;ll explain what this means and walk through the sources of unsoundness in TypeScript. Rest assured, TypeScript is a great language and it&amp;#39;s never a good idea to listen to people on the internet!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The trouble with Jsonify: Unify types instead of modeling small differences</title>
    <link href="https://effectivetypescript.com/2021/04/09/unify-over-model/"/>
    <id>https://effectivetypescript.com/2021/04/09/unify-over-model/</id>
    <published>2021-04-09T13:45:00.000Z</published>
    <updated>2022-07-30T21:05:21.000Z</updated>
    
    <content type="html"><![CDATA[<!-- Alternate title: the trouble with Jsonify --><p>Last year I wrote about <a href="/2020/04/09/jsonify/"><code>Jsonify</code></a>, a generic that models how a type changes as it goes through JSON serialization and deserialization. This is especially relevant for JavaScript <code>Date</code>s, which get converted to strings in this process:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; JSON.parse(JSON.stringify(d))<br>&#39;2021-04-07T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure><p>If you use a type on your server, <code>Jsonify</code> tells you what that type will look like on your client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>The <a href="/2020/04/09/jsonify/">original post</a> generated some <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/">strong</a> <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/">reactions</a>. Since I posted it, I&#39;ve learned two things:</p><p>First, <strong>I didn&#39;t come up with this.</strong> In fact, Anders presented it at <a href="https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s">his keynote</a> at the original TSConf, in 2018. He, in turn, based it on <a href="https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545">discussion</a> on GitHub. What&#39;s surprising is that <em>I was at that talk</em>! But it must have gone in one ear and out the other. In any case, <code>Jsonify</code> became much more compelling once TypeScript 3.7 introduced <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases">recursive type aliases</a> in Nov. 2019.</p><p>Second, I&#39;ve learned that <strong><code>Jsonify</code> isn&#39;t a good idea</strong>.</p><p>Why not? While it&#39;s neat that you can model a transformation like this in the type system, it wound up being quite annoying when my team put it into practice.</p><p>For example, if you have an API on the server that produces a <code>Student</code>, then your client-side code should work in terms of <code>Jsonify&lt;Student&gt;</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>As you pass the <code>student</code> object around your application, you&#39;ll get long error messages any time you forget the <code>Jsonify</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);<br>  <span class="hljs-comment">//             ~~~~~~~</span><br>  <span class="hljs-comment">// Argument of type &#x27;&#123; id: number; name: string; birthday: string | null; &#125;&#x27; is not assignable to parameter of type &#x27;Student&#x27;.</span><br>  <span class="hljs-comment">//   Types of property &#x27;birthday&#x27; are incompatible.</span><br>  <span class="hljs-comment">//     Type &#x27;string | null&#x27; is not assignable to type &#x27;Date | null&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;string&#x27; is not assignable to type &#x27;Date | null&#x27;. (2345)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Nothing about this error says &quot;you forgot <code>Jsonify</code>.&quot; We just had to learn &quot;any time you see something about <code>Date</code> and <code>string</code>, it means you forgot a <code>Jsonify</code> somewhere.&quot; In more realistic code, there can be many <code>Date</code> objects that are deeply nested, leading to even longer, more confusing errors. These <code>Date</code> fields typically weren&#39;t used by the function producing the error, so we weren&#39;t even gaining safety for our trouble.</p><p>After battling <code>Jsonify</code> for a few months, we decided to get rid of it by eliminating <code>Date</code>s from our API. Most of these were coming from our database. By default, <code>node-postgres</code> <a href="https://node-postgres.com/features/types#date--timestamp--timestamptz">converts Postgres date/timestamp columns</a> to <code>Date</code> objects. This makes a lot of sense as a default. But to keep our server and and client types equal, we decided to just use strings instead.</p><p>To make this work, we had to reconfigure the types returned by node-postgres:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;types&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br>types.setTypeParser(types.builtins.DATE, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMPTZ, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMP, _.identity);<br></code></pre></td></tr></table></figure><p>We use <a href="https://github.com/danvk/pg-to-ts"><code>pg-to-ts</code></a> (a fork of <a href="https://github.com/PSYT/schemats"><code>schemats</code></a>) to generate types from our database schema (which we consider a source of truth). So we had to <a href="https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c">adapt it</a> with a <code>--datesAsStrings</code> flag.</p><p>With these changes in place, our API types were fully unified: they were exactly the same on the server and the client:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Used to be Date | null</span><br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Student&gt;;  <span class="hljs-comment">// exactly the same!</span><br></code></pre></td></tr></table></figure><p>So we could drop <code>Jsonify</code>! Now we could write code like this error-free:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);  <span class="hljs-comment">// ok!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The lesson here is that <strong>you should prefer to unify your types rather than model small differences between them.</strong> By unifying your types, you&#39;ll save all the time and effort you would have spent getting the transformations exactly correct and applied in exactly the right places.</p><p>As another example, it&#39;s common to have <code>snake_case</code> column names in your database and convert them to <code>camelCase</code> for JS/TS variable names and types in your API:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> StudentTable &#123;<br>  first_name: <span class="hljs-built_in">string</span>;<br>  last_name: <span class="hljs-built_in">string</span>;<br>  birth_date: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  firstName: <span class="hljs-built_in">string</span>;<br>  lastName: <span class="hljs-built_in">string</span>;<br>  birthDate: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>As I discussed in my <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> post, <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types">as of TypeScript 4.1</a> you can model this snake_case ‚Üí camelCase transformation in the type system. But should you? Following the mantra of &quot;unify rather than model small differences,&quot; clearly you should not! In this case you could either use <code>snake_case</code> names in your API or use a tool like <a href="https://github.com/hoegaarden/pg-camelcase">pg-camelcase</a> to convert the <code>snake_case</code> names to <code>camelCase</code> as you load them from the database (you can do something similar with <a href="http://knexjs.org/#Installation-wrap-identifier">knex</a>). In either case, you&#39;ll be able to forget about the type transformations entirely.</p><p>Of course, any rule comes with caveats.</p><p>First, this isn&#39;t always an option. You may need the two types if the database and the API aren&#39;t under your control. If this is the case, then modeling these sorts of differences systematically in the type system will help you find bugs in your transformation code. It&#39;s better than creating types ad-hoc and hoping they stay in sync.</p><p>Second, don&#39;t unify types that aren&#39;t representing the same thing! Say you have a tagged union, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseSuccess &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span>;<br>  payload: PayloadType;<br>&#125;<br><span class="hljs-keyword">interface</span> ResponseError &#123;<br>  status: <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  error: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Response = ResponseSuccess | ResponseError;<br></code></pre></td></tr></table></figure><p>It would be counterproductive to &quot;unify&quot; these types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don&#x27;t do this!</span><br><span class="hljs-keyword">interface</span> Response &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span> | <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  payload?: PayloadType;<br>  error?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This will make TypeScript less effective at finding bugs in your <code>Response</code>-handling code. The two <code>Response</code> types are fundamentally different, so they should not be unified. This rule is best applied to types that are fundamentally the same but superficially different.</p><p>If you find yourself creating lots of types that are only slightly different from one another, consider unifying them. You&#39;ll be happy you did!</p>]]></content>
    
    <summary type="html">
    
      Last year I wrote about &lt;code&gt;Jsonify&lt;/code&gt;, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with &lt;code&gt;Jsonify&lt;/code&gt; and 2) It&#39;s a bad idea!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Advent of Code 2020, this time in Rust</title>
    <link href="https://effectivetypescript.com/2021/03/24/advent-of-code/"/>
    <id>https://effectivetypescript.com/2021/03/24/advent-of-code/</id>
    <published>2021-03-24T04:00:00.000Z</published>
    <updated>2023-01-04T15:45:57.202Z</updated>
    
    <content type="html"><![CDATA[<p>There&#39;s been <a href="https://fettblog.eu/learning-rust-and-go/">lots of interest</a> in Rust in the JavaScript and TypeScript community over the past few years, both because <a href="https://rustwasm.github.io/book/">it can target WebAssembly</a> and because <a href="https://github.com/denoland/deno">deno</a> is written in Rust.</p><p>Last year I decided to learn Rust by doing the <a href="https://adventofcode.com/">Advent of Code</a> in it: two puzzles every day of December leading up to Christmas. I had a great time and learned a lot about Rust, and I&#39;d highly recommend this as a way to learn a language.</p><p>Since this is a bit off-topic for the <em>Effective TypeScript</em> blog, I posted my writeup on Medium. If you&#39;re interested in Rust, check it out: <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">Advent of Code 2020 (this time in Rust)</a>.</p><p>TL;DR: Rust is an interesting language that works great for a specific niche, but it&#39;s a bit annoying to work with and I wouldn&#39;t choose to use it unless I was working in its niche. Also, this year&#39;s Advent of Code was too easy!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;There&amp;#39;s been &lt;a href=&quot;https://fettblog.eu/learning-rust-and-go/&quot;&gt;lots of interest&lt;/a&gt; in Rust in the JavaScript and TypeScript commun
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Four words to avoid in TypeScript writing</title>
    <link href="https://effectivetypescript.com/2021/02/03/pet-peeves/"/>
    <id>https://effectivetypescript.com/2021/02/03/pet-peeves/</id>
    <published>2021-02-03T18:40:00.000Z</published>
    <updated>2023-05-07T15:36:10.075Z</updated>
    
    <content type="html"><![CDATA[<p>I&#39;ve <a href="https://amzn.to/3HIrQN6">written</a> <a href="https://effectivetypescript.com/archives/">many words</a> about TypeScript and I&#39;m sure I&#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!</p><span id="more"></span><ol><li><p><strong>&quot;Typescript&quot;</strong></p><p>It&#39;s not Typescript. It&#39;s Type<strong>S</strong>cript. Capital T, capital S. Fun fact: it&#39;s also JavaScript, capital J, capital S. I thought about ending my post here, this one bugs me so much! If you want to be taken seriously, you need to spell the name of the language correctly. The most egregious example of &quot;Typescript&quot; I know of this is the title of the <a href="https://www.reddit.com/r/typescript">r/typescript</a> subreddit. (I&#39;ve requested that this be fixed several times, but to no avail.)</p></li><li><p><strong>&quot;strongly-typed&quot;</strong></p><p>This one is hyphenated, sorry. I don&#39;t like it because no one can agree on what &quot;strongly-typed&quot; means. The TypeScript types that look &quot;strong&quot; to you coming from a Java background might look weak to a Haskell developer. Or to someone who&#39;s been using TypeScript a bit longer. And can types that go away at runtime really be considered strong?</p><p>When you write &quot;strongly typed,&quot; perhaps you mean to write &quot;statically typed&quot; (which TypeScript is) or &quot;sound&quot; (which it isn&#39;t)? Adding to the confusion, a <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection">weak type</a> is something very specific in TypeScript, and it&#39;s probably not the opposite of the &quot;strong types&quot; that you have in mind.</p></li><li><p><strong>&quot;advanced&quot;</strong></p><p>Expertise in programming is less about using &quot;advanced&quot; features and more about learning how to effectively use the basic building blocks of your language. To me, using the word &quot;advanced&quot; when discussing features like conditional types implies that that the more you use these features, the more &quot;advanced&quot; you are as a TS programmer. I prefer the word &quot;fancy&quot; (as in &quot;fancy types&quot;) since that has more accurate connotations about how often you really need to use these features. After all, the first rule of generics is to <a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">avoid them if you can</a>.</p></li><li><p><strong>&quot;cast&quot;</strong></p><p>The correct term for the expression <code>x as number</code> is &quot;type assertion&quot;. I don&#39;t like the word &quot;cast&quot; because in most languages (C, C++, Java, Rust, ‚Ä¶), a cast can have an effect at runtime. In C, for example, <code>(int)f</code> will  convert a <code>float</code> into an <code>int</code> by rounding down. But because <a href="http://neugierig.org/software/blog/2016/04/typescript-types.html">TypeScript types are erased at runtime</a>, the <code>as number</code> can&#39;t possibly have an effect. If you look at the generated JS in the <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBNBOB5eA5ArgWxgXhgWQEMoALAOngLABMQMAKAShgH4YByAFgCY2YAuGNwDcAWABQoSLDCYccKElSyCEGDIwAjAKbwhMGAHoDMADwBaMzAAiILRDBtYBYFDQEANu4CeMAETAVKF8YLxA0eHl4AEswAHMYKBAYAjVMbXgAQnEgA">TypeScript playground</a>, you can see this plainly. It&#39;s called a &quot;type assertion&quot; because you&#39;re asserting that the value <em>already</em> has the type you say it does. You&#39;re not &quot;casting&quot; it into that type. Item 9 of <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a>, <em>Prefer Type Declarations to Type Assertions</em>, has much more to say about exactly when it&#39;s appropriate to use type assertions.</p></li></ol><p>I always try to maintain a positive tone in public forums, and I certainly don&#39;t want this post to discourage anyone from writing about <del>Typescript</del> TypeScript. If you&#39;ve learned something about the language and want to share it online, that&#39;s great! I hope you do. But please avoid these four terms!</p><!--1. Thinking "types" are only about "type safety"   Actually they drive all the great language service features.   `tsserver` is just as important as `tsc`.   This is what makes people love TS!2. Misc incorrect terminology:   1. "type assertion" vs. "cast" (it cannot have a runtime effect, unlike some `C++` casts.)   2. String literal vs. string literal type3. Prefixing all your interfaces with `I`. If you do this, then you should probably prefix your types with `T` and your classes with `I`. And maybe your numbers with `n` and your strings with `s`?4. Using object wrappers for everything. TypeScript isn't Java. This isn't the kingdom of the nouns! (See ch10 of _Mastering TypeScript_.)5. Putting type annotations on all your variables and function parameters, for example `beforeEach((done: jest.DoneCallback)` in ch10 of _Mastering TypeScript_.-->]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I&amp;#39;ve &lt;a href=&quot;https://amzn.to/3HIrQN6&quot;&gt;written&lt;/a&gt; &lt;a href=&quot;https://effectivetypescript.com/archives/&quot;&gt;many words&lt;/a&gt; about TypeScript and I&amp;#39;m sure I&amp;#39;ve read even more. Here are four words that make me cringe every time I see them. If you write about TypeScript, please steer clear of these!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 3: Avoid Repeating Type Expressions</title>
    <link href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/"/>
    <id>https://effectivetypescript.com/2021/01/20/gentips-3-aliases/</id>
    <published>2021-01-21T02:40:00.000Z</published>
    <updated>2022-02-25T16:31:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: Avoid Repeating Type Expressions</li><li>Part 4: <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">The Display of Types</a></li></ul><p>Recently there&#39;s been some <a href="https://twitter.com/kentcdodds/status/1348016701632221184">chatter</a> online about how you should use <a href="https://fettblog.eu/tidy-typescript-name-your-generics/">long names for generic types</a> (i.e. longer than just <code>T</code>). I&#39;d generalize all this a bit to say:</p><p><strong>Just because you&#39;re writing generics, don&#39;t forget everything you&#39;ve learned about programming!</strong></p><p>So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.</p><p>This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&#39;re worth learning because they&#39;re usually better than repeating yourself!</p><span id="more"></span><p>As a motivating example, we&#39;ll look at how <a href="https://github.com/danvk/crosswalk">crosswalk</a> registers express endpoints (see the <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> for background on crosswalk). Recall that an API definition in crosswalk looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">&#x27;/users&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">the last post</a> we looked at how crosswalk defines safe wrappers to register handlers for an endpoint. Here&#39;s what usage looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>app.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> (params, request, response) =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>The <code>params</code> object has a type based on the path (<code>/users/:userId</code>) and the response is required to be <code>Promise&lt;User&gt;</code> (based on the <code>API</code> interface). Here&#39;s the implementation we wound up with in the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">last post</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ...;<br><span class="hljs-comment">// See https://twitter.com/danvdk/status/1301707026507198464</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-comment">// ... implementation ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The real crosswalk API passes the express <code>request</code> and <code>response</code> objects to the callback as well as the path params. And express requests and responses <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/8d49ebd3e913bdbb90294d7672cda5884566d62a/types/express/index.d.ts#L112-L118">take several generic parameters</a>: the path params, the request body type and the response type. For a GET request, we can ignore the request type (there&#39;s no request body) but the other two are relevant. They let you reference <code>request.params</code> and get a type, for example.</p><p>Here&#39;s what this looks like, focusing just on <code>get</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;<br>    &gt;,<br>    response: express.Response&lt;<br>      LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;<br>    &gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Wow that&#39;s a lot of a lot of repetition! The <code>ExtractRouteParams</code> clause appears twice and the response type (the <code>LooseKey2</code> bit) appears three times. It would be even worse for the <code>post</code> handler, where we have a request body to type, too.</p><p>So what can you do about this? There are a few options. They&#39;re better than nothing but, as we&#39;ll see, none are perfect.</p><h3 id="Factor-out-helper-types"><a href="#Factor-out-helper-types" class="headerlink" title="Factor out helper types"></a>Factor out helper types</h3><p>This is the generic equivalent of factoring out a helper function. Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You can factor the repeated bits out into a helper type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Exp&lt;T&gt; = Expression&lt;Involving&lt;T&gt;&gt;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">a: Exp&lt;T&gt;, b: Exp&lt;T&gt;</span>): <span class="hljs-title">Exp</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>(Of course, you should give the helper type a semantically meaningful name if possible.)</p><p>In the case of the crosswalk <code>get</code> method, we might want to factor out a helper to extract the <code>response</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> GetResponse&lt;API, Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt; =<br>  LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;;<br><br>get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      GetResponse&lt;API, Path&gt;<br>    &gt;,<br>    response: express.Response&lt;GetResponse&lt;API, Path&gt;&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;GetResponse&lt;API, Path&gt;&gt;<br>)<br></code></pre></td></tr></table></figure><p>While this does cut down on repetition in the <code>get</code> declaration itself, it forces us to repeat the constraint on <code>Path</code>. As with helper functions, helper types work best when they are semantically meaningful on their own. This makes them easier to think about and increases the likelihood that they&#39;ll be useful in other places.</p><h3 id="Introduce-a-local-type-alias"><a href="#Introduce-a-local-type-alias" class="headerlink" title="Introduce a local type alias"></a>Introduce a local type alias</h3><p>The <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">first post</a> in this series looked at how you can use classes and currying to introduce new inference sites. Currying has another advantage: it introduces a new scope in which you can create type aliases (you can&#39;t introduce a type alias scoped to a <code>class</code>).</p><p>Instead of:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  a: Expresion&lt;Involving&lt;T&gt;&gt;,</span></span><br><span class="hljs-function"><span class="hljs-params">  b: Expression&lt;Involving&lt;T&gt;&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Expression</span>&lt;<span class="hljs-title">Involving</span>&lt;<span class="hljs-title">T</span>&gt;&gt; </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>You could write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">type</span> Exp = Expresion&lt;Involving&lt;T&gt;&gt;;<br><br>  <span class="hljs-keyword">return</span> (a: Exp, <span class="hljs-attr">b</span>: Exp): <span class="hljs-function"><span class="hljs-params">Exp</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>By changing the signature, we&#39;re able to introduce a type alias that depends on the generic parameter, <code>T</code>. This greatly simplifies the resulting generic and doesn&#39;t require us to repeat any bounds on the generic parameters.</p><p>Here&#39;s what <code>get</code> might look like if we curried it:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>  path: Path<br>) =&gt; &#123;<br>  <span class="hljs-keyword">type</span> Params = ExtractRouteParams&lt;Path&gt;;<br>  <span class="hljs-keyword">type</span> ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;;<br><br>  <span class="hljs-keyword">return</span> (<br>    handler: (<br>      params: Params,<br>      request: express.Request&lt;Params, Response&gt;,<br>      response: express.Response&lt;Response&gt;<br>    ): <span class="hljs-built_in">Promise</span>&lt;Response&gt;) =&gt; &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>This is much clearer and much less repetitive. The downside is that it&#39;s more complicated for the caller. One hybrid option is to have a public, non-curried function that delegates to a curried, internal function. See crosswalk&#39;s <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/typed-router.ts#L88"><code>registerWithBody</code></a> for an example of this in action.</p><h3 id="Add-Generic-Parameters-with-Defaults"><a href="#Add-Generic-Parameters-with-Defaults" class="headerlink" title="Add Generic Parameters with Defaults"></a>Add Generic Parameters with Defaults</h3><p>What if you&#39;re defining a type alias, rather than a generic function? Then you can&#39;t create a local scope since there&#39;s no function body.</p><p>But if you&#39;re repeating the same type expression <em>a lot</em>, there is one mediocre option available: you can define another generic parameter with a default value.</p><p>Instead of writing:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A&gt; = [F&lt;A&gt;, F&lt;A&gt;, F&lt;A&gt;];<br></code></pre></td></tr></table></figure><p>You&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T&lt;A, B <span class="hljs-keyword">extends</span> F&lt;A&gt; = F&lt;A&gt;&gt; = [B, B, B];<br></code></pre></td></tr></table></figure><p>You have to write <code>F&lt;A&gt;</code> twice, so this trick isn&#39;t helpful unless it appears three or more times in your type alias.</p><p>You can use the same technique with generic functions. For example, here&#39;s how you might write crosswalk&#39;s <code>get</code> with an extra generic parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  ResponseType <span class="hljs-keyword">extends</span><br>    LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt; =<br>    LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;,<br>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>    request: express.Request&lt;<br>      ExtractRouteParams&lt;Path&gt;,<br>      ResponseType<br>    &gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Because <code>ResponseType</code> appears three times, defining it this way <em>does</em> reduce repetition. But because <code>ExtractRouteParams&lt;Path&gt;</code> only appears twice, factoring that out in the same way wouldn&#39;t be a win.</p><p>The upside of this technique is that it effectively introduces a local type alias without changing the function signature. The downside is that it&#39;s gross and potentially confusing for your users, who may think they need to pass a value for the additional type parameter. But it works with type aliases and it&#39;s (arguably) better than nothing!</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Just because you&#39;re doing generic programming, don&#39;t forget that you&#39;re programming! Cryptic code is hard to follow, so use meaningful type names. And repetitive code is hard to follow and error-prone, so use the techniques at your disposal to reduce repetition.</p><p>Admittedly none of these options are perfect. I&#39;ve filed a <a href="https://github.com/microsoft/TypeScript/issues/42388">feature request</a> to support <a href="https://github.com/rust-lang/rfcs/blob/master/text/0135-where.md">Rust-style <code>where</code> syntax</a> for generics, which would let you write <code>get</code> like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get(<br>  path: Path,<br>  handler: (<br>    params: Params,<br>    request: express.Request&lt;Params, ResponseType&gt;,<br>    response: express.Response&lt;ResponseType&gt;<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;ResponseType&gt;<br>) where<br>  Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>,<br>  Params = ExtractRouteParams&lt;Path&gt;,<br>  ResponseType = LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;,<br>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>In other words, you&#39;d get the local type alias without any of the downside. This would make the story around reducing repetition much better (and this blog post happily obsolete!). If you like the idea, please go vote it up!</p><p>The posts in this series have looked at how generic types are computed and inferred. In the next (and hopefully last) post, we&#39;ll look at your options for controlling how they&#39;re displayed.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;This is part of an ongoing series on tips I learned for working with TypeScript generics from building the &lt;a href=&quot;https://github.com/danvk/crosswalk&quot;&gt;crosswalk&lt;/a&gt; library. Check out &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;part 1&lt;/a&gt; for more background.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Part 0: &lt;a href=&quot;/2020/08/12/generics-golden-rule/&quot;&gt;The Golden Rule of Generics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 1: &lt;a href=&quot;https://effectivetypescript.com/2020/12/04/gentips-1-curry/&quot;&gt;Use Classes and Currying to create new inference sites&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 2: &lt;a href=&quot;https://effectivetypescript.com/2020/12/09/gentips-2-intersect/&quot;&gt;Intersect what you have with whatever TypeScript wants&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Part 3: Avoid Repeating Type Expressions&lt;/li&gt;
&lt;li&gt;Part 4: &lt;a href=&quot;https://effectivetypescript.com/2022/02/25/gentips-4-display/&quot;&gt;The Display of Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Recently there&amp;#39;s been some &lt;a href=&quot;https://twitter.com/kentcdodds/status/1348016701632221184&quot;&gt;chatter&lt;/a&gt; online about how you should use &lt;a href=&quot;https://fettblog.eu/tidy-typescript-name-your-generics/&quot;&gt;long names for generic types&lt;/a&gt; (i.e. longer than just &lt;code&gt;T&lt;/code&gt;). I&amp;#39;d generalize all this a bit to say:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Just because you&amp;#39;re writing generics, don&amp;#39;t forget everything you&amp;#39;ve learned about programming!&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;So yes, give long-lived variables meaningful names. But also avoid repeating yourself by factoring out common expressions.&lt;/p&gt;
&lt;p&gt;This post presents a few patterns for reducing repetition in generics. None of them are perfect, but they&amp;#39;re worth learning because they&amp;#39;re usually better than repeating yourself!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Top Posts of 2020</title>
    <link href="https://effectivetypescript.com/2021/01/09/top-posts-2020/"/>
    <id>https://effectivetypescript.com/2021/01/09/top-posts-2020/</id>
    <published>2021-01-10T03:30:00.000Z</published>
    <updated>2023-05-07T15:36:10.076Z</updated>
    
    <content type="html"><![CDATA[<p>I <a href="https://effectivetypescript.com/2020/03/06/hello-world/">started</a> the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&#39;d still be working remotely. It&#39;s been quite a year.</p><p>I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:</p><span id="more"></span><ol><li><p><a href="https://effectivetypescript.com/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a> (August 12th)</p><p>My most popular post is based on <a href="https://microsoft.github.io/TypeScript-New-Handbook/everything/#type-parameters-should-appear-twice">advice in the TypeScript handbook</a>. The alternate title was &quot;Good use of generics or bad use of generics?&quot; This showcasing of good examples and bad examples made this article fun to write and, evidently, fun to read as well. The <a href="https://www.reddit.com/r/programming/comments/i8zqp9/good_use_of_generics_or_bad_use_of_generics/?">extensive discussion</a> on r/programming is worth reading. I&#39;m intrigued by the idea of introducing generic parameters as a way of simulating nominal types to help get a function&#39;s implementation correct.</p></li><li><p><a href="https://effectivetypescript.com/2020/04/09/jsonify/">What&#39;s the type of JSON.parse(‚ÄãJSON.stringify(x))?</a> (April 9th)</p><p>I was quite happy when I &quot;discovered&quot; this trick, only to learn a few months later that I&#39;d subconsciously cribbed it from Anders Hejlsberg&#39;s <a href="https://www.youtube.com/watch?t=2550&v=wpgKd-rwnMw">excellent tsconf 2018 keynote</a>. Whatever the provenance, I&#39;ve soured on tools like <code>Jsonify</code>. Better to unify types instead of modeling small differences. Look for a future post on this topic. Also notable on this was the wildly different response on <a href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/">r/typescript</a> vs. <a href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/">r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/26/iterate-objects/">Item 54: Know How to Iterate Over Objects</a> (May 26th)</p><p>The blog started with several sample items from <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> and this one has done well with Google: &quot;Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the quirks of JavaScript objects and duck typing.&quot;</p></li><li><p><a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> (November 5th)</p><p>Template Literal Types are one of the most exciting additions to TypeScript in years, and we&#39;re all just starting to learn how to use them. This post introduces them to an audience that may not be familiar with TypeScript and explains why I think they&#39;re a particularly <em>TypeScripty</em> solution to a long-standing class of issues. See <a href="https://www.reddit.com/r/programming/comments/jsakpy/typescript_splits_the_atom_a_first_look_at_ts_41s/?">discussion on r/programming</a>.</p></li><li><p><a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a> (May 12th)</p><p>This article was inspired by a particularly insightful <a href="https://stackoverflow.com/a/56416192/388951">answer</a> from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir">Titian Cernicova Dragomir</a> on Stack Overflow. I kept finding more uses for his trick, and I wanted to give it a catchy name. <code>Unionize</code> it is! I&#39;m quite proud of this post and I&#39;m happy to see it crack the top five.</p></li></ol><p>I&#39;m excited to see what 2021 brings to TypeScript! I&#39;ve started a <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">series on generics</a> that I plan to wrap up this month. I&#39;m working on &quot;Pet Peeves in TypeScript Writing&quot; post, and am planning some kind of (now late) &quot;Writing a book, the view from a year out&quot; retrospective. Subscribe or follow for updates!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;I &lt;a href=&quot;https://effectivetypescript.com/2020/03/06/hello-world/&quot;&gt;started&lt;/a&gt; the Effective TypeScript blog on March 6, 2020. It was my fourth day staying home from work with a lingering illness. I had no idea that ten months later, I&amp;#39;d still be working remotely. It&amp;#39;s been quite a year.&lt;/p&gt;
&lt;p&gt;I wrote 17 blog posts in 2020, very close to my goal of a post every two weeks. Here were the most popular:&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Generic Tips Part 2: Intersect what you have with whatever TypeScript wants</title>
    <link href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/"/>
    <id>https://effectivetypescript.com/2020/12/09/gentips-2-intersect/</id>
    <published>2020-12-09T22:50:00.000Z</published>
    <updated>2023-06-26T17:01:59.982Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: Intersect what you have with whatever TypeScript wants</li><li>Part 3: <a href="/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">The Display of Types</a></li></ul><p>Recall that an API definition in <a href="https://github.com/danvk/crosswalk">crosswalk</a> looks something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> API &#123;<br>  <span class="hljs-string">&#x27;/users&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;UsersResponse&gt;;<br>    post: Endpoint&lt;CreateUserRequest, User&gt;;<br>  &#125;;<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>: &#123;<br>    get: GetEndpoint&lt;User&gt;;<br>    put: Endpoint&lt;UpdateUser, User&gt;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(<code>Endpoint</code> and <code>GetEndpoint</code> are simple type aliases <a href="https://github.com/danvk/crosswalk/blob/c63c9ef5a55b42c275f4f701c21d8eb03ae9ca5e/src/api-spec.ts#L1-L6">defined by the library</a>. Their parameters are request and response types.)</p><p>In <a href="/2020/12/04/gentips-1-curry/">last week&#39;s post</a> we defined a <code>getUrl</code> function to safely generate API URLs. In this week&#39;s post, we&#39;ll create type-safe wrappers around <a href="https://expressjs.com/">express</a> methods to handle these endpoints.</p><p>Here&#39;s how you typically register a <code>get</code> handler in express:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">app.get(<span class="hljs-string">&#x27;/users/:userId&#x27;</span>, <span class="hljs-keyword">async</span> (request, response) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> &#123;userId&#125; = request.params;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> getUserById(userId);<br>  response.json(user);<br>  <span class="hljs-comment">// (error handling omitted)</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>There are a few issues with this from a TypeScript perspective:</p><ol><li>The type of <code>request.params</code> is <code>any</code>. This means that <code>userId</code> also gets an <code>any</code> type, and this destructuring assignment is completely unsafe.</li><li>The call to <code>response.json()</code> doesn&#39;t check the type of its argument. In fact, nothing checks that we call <code>response.json</code> at all.</li></ol><p>Crosswalk defines a typed wrapper so that the registration looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedRouter = <span class="hljs-keyword">new</span> TypedRouter&lt;API&gt;(app);<br>typedRouter.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; getUserById(params.userId)<br>);<br></code></pre></td></tr></table></figure><p>Instead of using <code>response.json</code> to send a response, we return <code>Promise&lt;User&gt;</code>, which TypeScript checks against the <code>API</code> interface. Additionally, thanks to <a href="/2020/11/05/template-literal-types/">the magic of <code>ExtractRouteParams</code></a>, <code>params</code> has an inferred type of <code>&#123;userId: string&#125;</code>, so the reference to <code>params.userId</code> is type safe.</p><p>Let&#39;s take a crack at implementing <code>TypedRouter</code>. As <a href="/2020/12/04/gentips-1-curry/">last week&#39;s tip</a> explained, you can either use a class or a <a href="https://wiki.haskell.org/Currying">curried function</a> to capture the <code>API</code> type parameter. In this case let&#39;s use a class. Then we can use a method (<code>get</code>) that infers a string literal type for the path. Here&#39;s a sketch:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;unknown&gt;  <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> fill in this type!</span><br>  ) &#123;<br>    <span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This gets us some of the way there: the <code>params</code> parameter to our handler is getting the correct type:</p><p><img src="https://effectivetypescript.com/images/gentips-2-inferred-params.png" alt="path parameters being inferred"></p><p>But what about that return type? Really you&#39;d like to look it up from the <code>API</code> interface given <code>Path</code>.</p><p>Here&#39;s how you&#39;d do that with a type alias:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Response = API[<span class="hljs-string">&#x27;/users/:userId&#x27;</span>][<span class="hljs-string">&#x27;get&#x27;</span>][<span class="hljs-string">&#x27;response&#x27;</span>];<br><span class="hljs-comment">// type is User</span><br></code></pre></td></tr></table></figure><p>If you plug that into our <code>get</code> function, however, you get several errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">get&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt;(<br>  path: Path,<br>  handler: (<br>    params: ExtractRouteParams&lt;Path&gt;,<br>  ) =&gt; <span class="hljs-built_in">Promise</span>&lt;API[Path][<span class="hljs-string">&#x27;get&#x27;</span>][<span class="hljs-string">&#x27;response&#x27;</span>]&gt;<br>  <span class="hljs-comment">//           ~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br>  <span class="hljs-comment">// Type &#x27;Path&#x27; cannot be used to index type &#x27;API&#x27;. (2536)</span><br>  <span class="hljs-comment">// Type &#x27;&quot;get&quot;&#x27; cannot be used to index type &#x27;API[Path]&#x27;. (2536)</span><br>  <span class="hljs-comment">// Type &#x27;&quot;response&quot;&#x27; cannot be used to index type &#x27;API[Path][&quot;get&quot;]&#x27;. (2536)</span><br>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>It&#39;s reasonable for TypeScript to complain here. We haven&#39;t constrained <code>API</code> or <code>Path</code>, so it has no reason to believe that <code>Path</code> is defined on <code>API</code>, let alone that it has a <code>get</code> property which has a <code>response</code> property.</p><p>You can fix the first of these errors by changing:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends string&gt;(<br>+ get&lt;Path extends keyof API&gt;(<br></code></pre></td></tr></table></figure><p>Unfortunately, this introduces a <em>new</em> error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br><span class="hljs-comment">//              ~~~~</span><br><span class="hljs-comment">// Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;(string | RegExp)[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>(The full error is quite long, but that&#39;s the important part.)</p><p>The problem is that express wants the <code>path</code> parameter to be a <code>string</code> (or a <code>RegExp</code>), but in TypeScript, <code>keyof API</code> is a <code>PropertyKey</code>, which is <a href="https://github.com/microsoft/TypeScript/blob/4dc82fdfba577085a087db6535a4ad2cc755e503/lib/lib.es5.d.ts#L105">defined in the standard library</a> as:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">type</span> PropertyKey = <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span> | symbol;<br></code></pre></td></tr></table></figure><p>The <code>number</code> is a lie (Item 16 of <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a>, &quot;Prefer Arrays, Tuples, and ArrayLike to number Index Signatures&quot;, explains this in great detail). But <code>path</code> could certainly be a <code>string</code> or <code>symbol</code>. We don&#39;t care about the <code>symbol</code> or <code>number</code> cases, though. We only want the <code>string</code>. To get down to this, you can use an intersection type:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- get&lt;Path extends keyof API&gt;(<br>+ get&lt;Path extends keyof API &amp; string&gt;(<br></code></pre></td></tr></table></figure><p>This eliminates the error with <code>router.get</code>! This intersection trick winds up being an extremely useful way to get rid of TypeScript errors with generics. As it turns out, it&#39;s this week&#39;s tip!</p><p><strong>To get rid of generic type errors, intersect what you have with whatever TypeScript wants.</strong></p><p>Let&#39;s use the same trick to get rid of the remaining two errors:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39;][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;get&quot;&#39; cannot be used to index type &#39;API[Path]&#39;. (2536)<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot;]&#39;. (2536)<br></code></pre></td></tr></table></figure><p>In the first error, TypeScript is saying that it&#39;s seeing <code>&#39;get&#39;</code>, but it wants something that can index <code>API[Path]</code>. In other words, <code>keyof API[Path]</code>. So let&#39;s intersect!</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39;]&gt;<br>&#x2F;&#x2F;      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<br>&#x2F;&#x2F; Type &#39;&quot;response&quot;&#39; cannot be used to index type &#39;API[Path][&quot;get&quot; &amp; keyof API[Path]]&#39;. (2536)&#96;&#96;&#96;<br><br>Voila! The error is gone! It&#39;s like magic. You can get rid of the remaining error using the same trick. Watch out, this is going to get a little wordy:<br><br>&#96;&#96;&#96;ts<br>Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39; &amp; keyof API[Path][&quot;get&quot; &amp; keyof API[Path]]]&gt;<br></code></pre></td></tr></table></figure><p>And the errors are gone! What&#39;s more, we have perfect type inference. The error if you return the wrong type from a handler is exactly what you&#39;d hope for:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">typedRouter.get(<br>  <span class="hljs-string">&#x27;/users/:userId&#x27;</span>,<br>  <span class="hljs-keyword">async</span> params =&gt; <span class="hljs-literal">null</span><br>  <span class="hljs-comment">//              ~~~~</span><br>  <span class="hljs-comment">// Type &#x27;Promise&lt;null&gt;&#x27; is not assignable to type &#x27;Promise&lt;User&gt;&#x27;.</span><br>  <span class="hljs-comment">//   Type &#x27;null&#x27; is not assignable to type &#x27;User&#x27;. (2322)</span><br>);<br></code></pre></td></tr></table></figure><p>But this a mess. The issue is that for every index operator, you also have to introduce a <code>keyof</code>. And with three index operators (<code>Path</code>, <code>&#39;get&#39;</code>, <code>&#39;response&#39;</code>), this has spiraled out of control.</p><p>You can improve things with a short helper:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br></code></pre></td></tr></table></figure><p>This is like <code>T[K]</code> except that it doesn&#39;t require evidence that <code>K</code> is actually a key of <code>T</code>. (If it&#39;s not, it will resolve to <code>never</code>.) The win here is that while <code>T</code> appears twice in the definition of <code>LooseKey</code>, it only appears once when you use it. Here&#39;s how you can use it to simplify the monstrous type expression from earlier:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">- Promise&lt;API[Path][&#39;get&#39; &amp; keyof API[Path]][&#39;response&#39; &amp; keyof API[Path][&quot;get&quot; &amp; keyof API[Path]]]&gt;<br>+ Promise&lt;LooseKey&lt;LooseKey&lt;API[Path], &#39;get&#39;&gt;, &#39;response&#39;&gt;&gt;<br></code></pre></td></tr></table></figure><p>As before, this still resolves all our types perfectly. You could even define a <code>LooseKey2</code> to simplify things a bit more:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><br><span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br></code></pre></td></tr></table></figure><p>(You could define a variadic version of this that works on tuples of keys. Give it a try!)</p><p>This technique also comes in handy with <a href="https://github.com/microsoft/TypeScript/pull/40336">template literal types</a>. For example, let&#39;s define a generic type that capitalizes the property names of another type. You can do this using the built-in <code>Capitalize</code> generic and a mapped type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K&gt;]: T[K];<br>  <span class="hljs-comment">//                          ~</span><br>  <span class="hljs-comment">// Type &#x27;K&#x27; does not satisfy the constraint &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//   Type &#x27;keyof T&#x27; is not assignable to type &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//     Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;string&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. (2344)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This looks familiar! TypeScript wants a <code>string</code>, but we&#39;ve got a <code>PropertyKey</code>. By now you should see how to solve the problem: intersect with whatever TS wants!</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Caps&lt;T&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> Capitalize&lt;K &amp; <span class="hljs-built_in">string</span>&gt;]: T[K];<br>&#125;<br></code></pre></td></tr></table></figure><p>and now this works as you&#39;d expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Caps&lt;&#123;<span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>, <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>&#125;&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     Name: string;</span><br><span class="hljs-comment">//     Age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>Of course, there&#39;s no free lunch. The downside of this approach is that TypeScript won&#39;t check that the property accesses in your generic are safe. You&#39;ll need to verify them in some other way, <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">probably with a test</a>. But it&#39;s undeniably convenient to have this safety valve available! You can think of it as a rough equivalent of <code>as any</code> for generic types.</p><p>Here&#39;s our final version of <code>TypedAPI</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypedRouter</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">private</span> router: express.Router</span>)</span> &#123;&#125;<br>  get&lt;Path <span class="hljs-keyword">extends</span> keyof API &amp; <span class="hljs-built_in">string</span>&gt;(<br>    path: Path,<br>    handler: (<br>      params: ExtractRouteParams&lt;Path&gt;,<br>    ) =&gt; <span class="hljs-built_in">Promise</span>&lt;LooseKey2&lt;API[Path], <span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;response&#x27;</span>&gt;&gt;<br>  ) &#123;<br>    <span class="hljs-built_in">this</span>.router.get(path, <span class="hljs-function">(<span class="hljs-params">request, response</span>) =&gt;</span> &#123;<br>      handler(request.params)<br>      .then(<span class="hljs-function"><span class="hljs-params">obj</span> =&gt;</span> response.json(obj));<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>As usual, you can find the <a href="https://www.typescriptlang.org/play?#code/JYWwDg9gTgLgBAKjgQwM5wKYA8xQ69AMyghDgHJtd9VyBuAKAaunmADsYMpDkBjDHACi7ACaQOMADwAlDAEcArvhgAaOHNSR2qDAD44AbwZw4eJSoBcGhctQxGpvFog6M1zdt2MAvsxyscDAAnmCCAOIYMCLiEJKy+F76cAC8wmISnFLsigA2ueqerrp6jAyS3LwCcACqulBGQaHuFIr19HB+FTz8gnXcqEVujW0D1v1QANoAunSd5ZyVvXAAwnjIXBNyFvaN7MggLfZQHADmc12LPdU1YKIbGBN7BxgA-NbHZ51lAPQ-cABlDCCAAWMBgYFQlj+p2AMBBigARgA6PikH73dgANwA1j8+CQCAB3ZC5HH+SCwODdKqCACCAAUAJJGEwUH6jKC0azGUymU5RayRaIZOJZCaDRLFfSOPmQezWGKZaRrDAPLa2FTqCalNk+WXkDn1VA-Sycpmicg8tn8wVwYVKsXSHWy0xgRQwRWi+K3e6bera+q60x+PwMP6A4FwMEQ6E-XIQPikkEQBUAFgADFmfgAmDN5n4ARkLPwzAFYflxwLkHgBaXJw7ik2shMImimBVuCIRYGBQfgwGQQD0YBnIfsgVBSAAqBjSn3Yp0wvYwYnQ07ZrxsaKgoikC9O6gPejZ1mny64a7gAAMACSGDiEbhwAD6AJg45gPks98fz7HE4+D8v7sE+DSaF+16bo0kw4tS7BwABBxwAAPnAOIYMEECEMIvb9nwg7DlwSGTgk9h6NMHx9l8fimGeF6rqI6B3g+oHPm+H6wN+IFgYh44HD4UGmFuhhwLB8F8ROlFwAe8x0UY+pMKIGB8DWeBwLkUQoGAYDWFQzioMiQ4jlAjDKap46CIQijsARwCuHAAowBMABCwQWgAFOaohUSci4AJTWAyJAgMAuhSC6TBdjYLjDGkjJMpMhqciaZr1Ba5DTElTmZUlzhJJljARtFYW1PUUXNHAAAyECphgADSmEzuo9VznA06TPVcAAGToZh2HtbMDDRTVdWNcEObNXA9WFi1OZtaNujjVIi0NU104tYWehzbqDAWQQ7XNKIxlcFAUgJQYvJwGiOh9ooBHQB5uDAFiDxmER3B6TgBlGR9UD+QpbJOVIY7wgxV4YVhOEJT1MnUYuegeTacBgBsIJBWjqjIyCyBiJpUDWEjfJyvxk6KnhA4naOpNTqDILbcjAMpAYwWkGFGArbVS2YZNCWTHT0zqOQOVC-l0rkHoJ6mADV2mPCYXIiQJnIk5T2Y3AHnmHYahmFKbhM5dyOmDjePcJrmr2MiqMTqg-lG3AyLwquHkQIiABWqQGGLbjIm7qCuC77v+f5rqdHbIYMGGN27F2x1-akcDsBgRKHWEccmedzKI8gOkh8NR1U1AKtRET7Ipaa3nkFjphoMEtkozTnuOVErnuaIas28i3l23n+dhKsOdTrOCdXZ1EmQwN55oAPYBwqSwAAF4c11vXHtJHX1dMkcVf355pCsg9SIY+yHL5ZzqMgArWDkICItwPi6sVlV76yEbEwAci8Z+LkV-zE3SV9E6KFvtwX+8wgA">full code</a> for this post on the TypeScript playground.</p><p>Next week we&#39;ll add the express Request and Response objects to the callback and look at ways to mitigate the repetition of types that follows.</p>]]></content>
    
    <summary type="html">
    
      When you&#39;re working with generic types and run into a seemingly unavoidable error, there&#39;s a trick that can often make it go away: intersect what you have with whatever TypeScript wants it to be. Your errors will melt away! Read on for examples and caveats.

    
    </summary>
    
    
    
  </entry>
  
</feed>
