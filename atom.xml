<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Effective TypeScript</title>
  <icon>https://effectivetypescript.com/icon.png</icon>
  <subtitle>62 Specific Ways to Improve Your TypeScript</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://effectivetypescript.com/"/>
  <updated>2024-05-21T21:38:32.904Z</updated>
  <id>https://effectivetypescript.com/</id>
  
  <author>
    <name>Dan Vanderkam</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Now Available: Effective TypeScript, Second Edition</title>
    <link href="https://effectivetypescript.com/2024/05/21/second-edition/"/>
    <id>https://effectivetypescript.com/2024/05/21/second-edition/</id>
    <published>2024-05-21T21:30:00.000Z</published>
    <updated>2024-05-21T21:38:32.904Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/cover-2e.jpg" style="float: right">I&#39;m happy to <a href="https://twitter.com/danvdk/status/1788579805643915424">announce</a> that the second edition of <a href="https://amzn.to/3UjPrsK"><em>Effective TypeScript</em></a> is now available! I&#39;ve spent a good chunk of the past year working on this update, and I&#39;m incredibly happy with how it&#39;s turned out.</p><p>You can buy a copy at all the usual places:</p><ul><li><a href="https://amzn.to/3UjPrsK">Amazon</a></li><li><a href="https://www.amazon.com/Effective-TypeScript-Dan-Vanderkam-ebook/dp/B0D2SGRTGR/">Amazon eBook</a> (Kindle)</li><li><a href="https://www.ebooks.com/en-us/book/211331398/effective-typescript/dan-vanderkam/">DRM-free eBook</a> (ebooks.com)</li><li><a href="https://www.oreilly.com/library/view/effective-typescript/9781098155056/">Read online</a> (O&#39;Reilly)</li></ul><p>If you&#39;d like to read it online, you can get a free month of access to the O&#39;Reilly online platform using promo code <a href="https://learning.oreilly.com/get-learning/?code=ETYPESCRIPT24">ETYPESCRIPT24</a> (valid until the end of 2024).</p><p>The book has been thoroughly revised and expanded to reflect how TypeScript is used in 2024. You can find full <a href="https://github.com/danvk/effective-typescript/releases/tag/2.0.0">release notes</a> on the book&#39;s GitHub page, but here are the highlights:</p><ul><li>Two new chapters: one on Generics and Type-Level Programming and one on TypeScript Recipes</li><li>24 new items (one item from the first edition was dropped)</li><li>Coverage of new TypeScript features like template literal types and recursive type aliases.</li></ul><p>TypeScript has changed and grown since 2019 and so has <em>Effective TypeScript</em>: it&#39;s 50% thicker!</p><img src="/images/ets-1v2.jpg"><p>If you enjoyed the first edition or use it as a reference, you&#39;ll be happy to update to the second. If you haven&#39;t read it yet, now&#39;s the perfect time to <a href="https://amzn.to/3UjPrsK">pick up a copy</a>.</p><p>If you&#39;d like me to come give a talk at your company, please <a href="mailto:danvdk@gmail.com">get in touch</a>. For a preview, check out the talk I gave at <a href="https://effectivetypescript.com/2024/01/31/etsy/">Etsy</a> in 2020.</p>]]></content>
    
    <summary type="html">
    
      Fully updated, thoroughly revised, now with 50% more book!
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Making of a TypeScript Feature: Inferring Type Predicates</title>
    <link href="https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/"/>
    <id>https://effectivetypescript.com/2024/04/16/inferring-a-type-predicate/</id>
    <published>2024-04-16T17:30:00.000Z</published>
    <updated>2024-04-30T21:41:26.619Z</updated>
    
    <content type="html"><![CDATA[<p>Over the past few months I became a TypeScript contributor and implemented a new feature, <a href="https://github.com/microsoft/TypeScript/pull/57465">type predicate inference</a>, that should be one of the headliners for TypeScript 5.5. This post tells the story of how that happened: why I wanted to contribute to TypeScript, the journey to implementing the feature and getting <a href="https://github.com/microsoft/TypeScript/pull/57465">the PR</a> merged, and what I&#39;ve learned along the way.</p><p>This is not a short read, but it will give you a good sense of what it&#39;s like to become a TypeScript contributor and develop a new feature.</p><span id="more"></span><p>If you&#39;re new to the <em>Effective TypeScript</em> blog, consider <a href="https://effectivetypescript.com/mail/">subscribing</a> or buying a copy of <a href="https://amzn.to/3UjPrsK">the book</a>. You can find a list of all the posts on this blog <a href="https://effectivetypescript.com/all-posts/">here</a>.</p><h2 id="What-is-Type-Predicate-Inference"><a href="#What-is-Type-Predicate-Inference" class="headerlink" title="What is Type Predicate Inference?"></a>What is Type Predicate Inference?</h2><p>Before we dive into the backstory, let&#39;s take a quick look at the feature I added. If you write code like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">data: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;number&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript will now infer that the function is a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type predicate</a>:</p><img style="max-width: 720px" alt="TypeScript inferring a type predicate" src="https://effectivetypescript.com/images/inferred-predicate.png"><p>Previously, TypeScript would have inferred a <code>boolean</code> return type. This also works for arrow functions, which means code that filters arrays becomes much more ergonomic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>].filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//    ^? const nums: number[]</span><br><span class="hljs-built_in">console</span>.log(nums[<span class="hljs-number">0</span>].toFixed()); <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Previously, this type would have been <code>(number | null)[]</code> and the last line would have been a type error.</p><h2 id="Why-contribute-to-TypeScript"><a href="#Why-contribute-to-TypeScript" class="headerlink" title="Why contribute to TypeScript?"></a>Why contribute to TypeScript?</h2><div style="width: 256px; float:right; margin-left: 10px;"><img src="https://effectivetypescript.com/images/soviet-contribute.png" width="256" height="256" alt="Soviet-style propaganda poster encouraging you to contribute to TypeScript"></div><p>I&#39;ve been using TypeScript since 2016. I&#39;ve been <a href="https://danvdk.medium.com/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8">writing about it</a> <a href="https://danvdk.medium.com/a-typed-chain-exploring-the-limits-of-typescript-b50153be53d8">almost as long</a>. But I&#39;d never contributed code to it. This felt like a gap in my understanding of TypeScript and its ecosystem. Like most TS users, I have a <a href="https://effectivetypescript.com/2022/12/25/christmas/">long list</a> of features I&#39;d like to see added to the language, and I thought learning about compiler internals would help me understand which of those features were feasible and which weren&#39;t.</p><p>At the start of this year, I signed up for a 12-week batch at <a href="https://www.recurse.com/">Recurse Center</a>, a &quot;writer&#39;s retreat for programmers.&quot; You apply with a project in mind, and mine was to contribute to TypeScript. RC provided an encouraging structure and the space for me to make this leap.</p><h2 id="Hopes-and-Fears"><a href="#Hopes-and-Fears" class="headerlink" title="Hopes and Fears"></a>Hopes and Fears</h2><p>I hoped that I&#39;d build a stronger intuition for how TypeScript works internally and maybe have some insights along the way. If I was lucky, maybe I&#39;d be able to say I was a TypeScript contributor and make some improvements to the language.</p><p>My biggest fear was that I&#39;d put a lot of work into a PR only to see it stall. There are some <a href="https://github.com/microsoft/TypeScript/pull/38839#issuecomment-1160929515">notorious examples</a> of this, most famously the <a href="https://twitter.com/JoshuaKGoldberg/status/1481654056422567944?lang=en">cake-driven development incident</a>. I knew the real goal was to learn more about TypeScript. But I did hope to get a change accepted.</p><h2 id="Finding-a-first-issue"><a href="#Finding-a-first-issue" class="headerlink" title="Finding a first issue"></a>Finding a first issue</h2><!-- 2024-01-12 to 01-26 --><p><em>Mid- to Late-January 2024</em></p><p>Before trying to implement something substantial, I thought I&#39;d start by fixing a trivial bug. This would help me get familiar with the compiler and the development process. This is exactly how the TypeScript docs suggest you get started as a contributor.</p><p>Finding a &quot;good first issue&quot; proved harder than I&#39;d expected. Most of the small, newly-filed issues get fixed quickly by one or two experienced community members. From a community perspective, this is great: if you file a bug and it&#39;s accepted, it&#39;s likely to get fixed. But for a new contributor this isn&#39;t good: I was unlikely to win any races to fix an issue.</p><p>There&#39;s a <a href="https://github.com/microsoft/TypeScript/labels/Good%20First%20Issue">good first issue</a> label, but this proved to be a bit of a joke. My <a href="https://github.com/microsoft/TypeScript/issues/29707">favorite issue</a> in this category was discussed by three of the top contributors to TypeScript, who decided it was impossible or not worth doing. But it&#39;s still got that &quot;good first issue&quot; label!</p><p>Eventually I found <a href="https://github.com/microsoft/TypeScript/issues/53182">#53182</a>, which involved numeric separators (<code>1_234</code>) not getting preserved in JS emit. This seemed low stakes and, as an added bonus, I&#39;m a fan of the <a href="https://macwright.com/">developer</a> who filed it.</p><p>The <a href="https://github.com/microsoft/TypeScript/pull/57144">fix</a> was a one-liner, just like you&#39;d expect, but I learned a lot about how TypeScript works along the way. TypeScript&#39;s code structure defies many best practices. All the code for type checking is in a single file, <code>checker.ts</code>, that&#39;s over 50,000 lines of code. And these are meaty lines since there&#39;s no set line width and relatively few comments. It also makes extensive use of numeric enums, a feature I discourage in <a href="https://amzn.to/3UjPrsK">Effective TypeScript</a>.</p><p>That being said, there are some impressive parts of the tooling. Visual debugging (F5) works great in VS Code and is an excellent way to learn what the compiler is doing. There are relatively few unit tests, but there&#39;s an enormous collection of &quot;baselines,&quot; a sort of end-to-end test that snapshots the types and errors for a code sample. There are over 18,000 of these, but TypeScript is able to run all of them on my laptop in just a few minutes.</p><p>After a few weeks, my PR was merged and released as part of TypeScript 5.4. I was officially a TypeScript contributor!</p><h2 id="A-meatier-second-issue"><a href="#A-meatier-second-issue" class="headerlink" title="A meatier second issue"></a>A meatier second issue</h2><!-- Starting ~2024-01-26; first commit on infer-guard is 2024-02-02 --><p><em>January 26, 2024</em></p><p>Fixing a small bug was a good start, but my bigger goal was to implement a new feature. Of all the issues I&#39;d filed on TypeScript, <a href="https://github.com/microsoft/TypeScript/issues/16069">#16069</a> stood out with over 500 👍s. This issue requested that TypeScript infer <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards">type predicates</a> for functions like <code>x =&gt; x !== null</code>. Clearly I wasn&#39;t the only one who wanted this!</p><p>I also had reason to think that this issue might be solvable. In <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-4/">TypeScript 4.4</a> (2021), Anders added support for <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-4.html#control-flow-analysis-of-aliased-conditions-and-discriminants">aliased conditions and discriminants</a>. This let you write code like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> ok = x !== <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">if</span> (ok) &#123;<br>    x  <span class="hljs-comment">// type is string</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> ok;<br>&#125;<br></code></pre></td></tr></table></figure><p>Surely the <code>ok</code> symbol had to have information stored on it saying that its value was tied to a refinement on <code>x</code>. If I looked at Anders&#39; PR, I&#39;d find where this was stored. This felt at least adjacent to my issue. And it was a good story: the feature only became feasible after another seemingly-unrelated feature was added. There were even <a href="https://github.com/microsoft/TypeScript/issues/16069#issuecomment-893914922">some comments</a> suggesting as much.</p><p>As it turned out, this was totally wrong! Nothing was stored on the <code>ok</code> symbol and I totally misunderstood how type inference worked. This was a big insight for me, and I wrote about it in my last blog post, <a href="https://effectivetypescript.com/2024/03/24/flownodes/">Flow Nodes: How Type Inference Is Implemented</a>. Head over there to learn all about this epiphany.</p><p>As part of my efforts to understand how control-flow analysis worked, I wrote some code to visualize TypeScript&#39;s control flow graph. I <a href="https://twitter.com/danvdk/status/1762868150800977996">contributed this</a> as a new feature to the <a href="https://ts-ast-viewer.com/">TS AST Viewer</a>. This was a nice, concrete win: even if my work on type predicate inference went nowhere, at least I&#39;d contributed something of value to the ecosystem.</p><h2 id="quot-OK-maybe-this-isn’t-hopeless…-quot"><a href="#quot-OK-maybe-this-isn’t-hopeless…-quot" class="headerlink" title="&quot;OK, maybe this isn’t hopeless…&quot;"></a>&quot;OK, maybe this isn’t hopeless…&quot;</h2><p><em>Week of February 2, 2024</em></p><p>Having built a stronger understanding of how type inference worked, I came back to the original problem. Did this make implementing my feature easier or harder?</p><p>Whenever I explained this feature, I&#39;d demo how you could put the return expression in an <code>if</code> statement to see the narrowed type of the parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNull</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x !== <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// -&gt;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNullRewrite</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span>) &#123;<br>    x  <span class="hljs-comment">// type is number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The key insight was to realize that I could do the exact same thing with the control flow graph. I&#39;d just have to synthesize a <code>FlowCondition</code> node, plug it into wherever the <code>return</code> statement was, and check the type of the parameter in that branch if the condition was <code>true</code>. If it was different than the declared type, then I had a type predicate!</p><p>I could check the type of a parameter at a location using the <code>getFlowTypeOfReference</code> function. But where to put this check? This was also a challenge, but eventually I found a place in <code>getTypePredicateOfSignature</code> to slot it in. I added a new function, <code>getTypePredicateFromBody</code>, that this would call for boolean-returning functions.</p><p>This was all a bit of a struggle since it was my first time really working with the type checker. Even simple things felt quite hard. What&#39;s the difference between a <code>Declaration</code>, a <code>Symbol</code> and an <code>Identifier</code>? How should I go from one to the other? Often I found a <a href="https://github.com/danvk/TypeScript/commit/a6a34c1523f3e70cda676cd75879ce53b6bcff51">very roundabout way</a> that let me keep making progress before I later found a more canonical path. For example, if <code>param</code> is a <code>ParameterDeclaration</code>, then you can use <code>param.name</code> to get a <code>BindingName</code>, and <code>isIdentifier(param.name)</code> to make sure it&#39;s an <code>Identifier</code>.</p><p>Running the tests was easy, but it took me a bit longer to realize how to test them in an interactive setting. So far as I can tell, building your own version of the TypeScript Playground isn&#39;t possible. But if you run <code>hereby local</code>, it will build <code>tsc.js</code>, and you can point any VS Code workspace at that version of TypeScript. You can even do this for the TypeScript repo itself.</p><p>While learning my way around the codebase, I found it incredibly helpful to take notes. Which function did what? What questions did I have? What was I struggling with? What did I have left to do? This helped to keep me oriented and also gave me a sense of progress. In particular, it was satisfying to read questions I&#39;d had weeks earlier that I now knew the answer to. Clearly I was learning! By the time my PR was merged, my Notion doc ran to 70+ pages of notes.</p><p>Eventually I was able to fit all the pieces together, though, and this let me infer type predicates for the first time, which was hugely encouraging!</p><h2 id="43-failures"><a href="#43-failures" class="headerlink" title="43 failures"></a>43 failures</h2><p><em>Week of February 9, 2024</em></p><p>This let me run the 18,000+ TypeScript &quot;baselines.&quot; This was an exciting moment: the first time I&#39;d see how my inference algorithm behaved on unfamiliar code! My initial implementation produced 43 test failures. I went through and categorized these:</p><ul><li>32 were &quot;Maximum call stack size exceeded&quot; errors</li><li>5 were the identify function on booleans</li><li>1 involved my mishandling a function with multiple returns</li><li>The other 5 were wins!</li></ul><p>This change was pretty funny:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// function identity(b: boolean): b is true</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">identity</span>(<span class="hljs-params">b: <span class="hljs-built_in">boolean</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> b;<br>&#125;<br></code></pre></td></tr></table></figure><p>The identity function on booleans <em>is</em> a type predicate! But that didn&#39;t seem very useful. I added a special case to skip boolean parameters.</p><p>The maximum call stack errors turned out to be an infinite loop. I added some code to block this. Then I changed my code to only run on functions with a single <code>return</code> statement. This left me with just the wins.</p><p>One of these wins got me particularly excited:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guard1</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span></span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guard2</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> guard1(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>I was inferring that <code>guard2</code> was a type guard because <code>guard1</code> was. This meant that type predicates could flow! There was another <a href="https://github.com/microsoft/TypeScript/issues/10734">long-standing issue</a> requesting just this behavior. Anders has said that you never want to fix just a single issue, you always want to fix a whole category of problems. This was an encouraging sign that I was doing just that. I hadn&#39;t set out to make type predicates flow, it just followed naturally from my change and TypeScript&#39;s control flow analysis.</p><h2 id="More-Predicates-in-More-Places"><a href="#More-Predicates-in-More-Places" class="headerlink" title="More Predicates in More Places"></a>More Predicates in More Places</h2><p><em>Week of February 16, 2024</em></p><p>To keep things simple, I&#39;d only been considering function statements, not function expressions or arrow functions. Now that I&#39;d validated the basic approach, I wanted to support these, too.</p><p>Standalone function expressions and arrow functions weren&#39;t difficult to add, but I had a lot of trouble with functions whose parameter types are determined by context. For example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> xs = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-literal">null</span>];<br><span class="hljs-keyword">const</span> nums = xs.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x !== <span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><p>The type of <code>x</code> is <code>number | null</code>, but TypeScript only determines this from a complex sequence of type inferences. I kept getting <code>any</code> types.</p><p>This problem didn&#39;t turn out to be deep. It just required finding the right function to call. <code>getTypeForVariableLikeDeclaration</code> did not work, but eventually I discovered <code>getNarrowedTypeOfSymbol</code>, which did. For the final PR I switched over to <code>getSymbolLinks</code>.</p><p>This was another really exciting moment! My commit message nicely captures my feelings:</p><img style="max-width: 100%" src="https://effectivetypescript.com/images/omg-it-works.png" alt="commit message reading OMG IT WORKS"><p>Nearly seven years after I&#39;d filed the <a href="https://github.com/microsoft/TypeScript/issues/16069">original issue</a>, I was able to make it pass the type checker:</p><img style="max-width: 100%" src="https://effectivetypescript.com/images/even-squares.png" alt="code sample passing type checker."><p>Success would be fleeting for this code sample, though, as I was about to find out.</p><h2 id="Pathological-Cases-and-an-Insight"><a href="#Pathological-Cases-and-an-Insight" class="headerlink" title="Pathological Cases and an Insight"></a>Pathological Cases and an Insight</h2><p>As I was developing the feature, I started collecting a set of &quot;pathological&quot; functions, ones that I thought might trip up my algorithm. The goal here is to think of everything that could possibly go wrong. That&#39;s impossible, of course, but the more bugs you work out on your own, the better.</p><p>This one turned out to be particularly interesting:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsString</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Should this be a type predicate? If it returns <code>true</code>, then you know that <code>x</code> is a <code>string</code>. But what if it returns <code>false</code>? In that case, <code>x</code> could be either <code>string</code> or <code>null</code>.</p><p>TypeScript infers correct types on both sides if we rewrite this as an <code>if</code> statement:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringRewrite</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x; <span class="hljs-comment">// type is string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x; <span class="hljs-comment">// type is string | null</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>But if you make this a type predicate, that nuance is lost:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsString</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> sOrN: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (flakyIsString(sOrN)) &#123;<br>  sOrN  <span class="hljs-comment">// type is string</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  sOrN  <span class="hljs-comment">// type is null 😱</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In other words, <code>flakyIsString</code> should <em>not</em> be a type predicate. This forced me to reformulate my criterion for inferring type predicates to consider the <code>false</code> case. If you rewrite a function that returns <code>expr</code> like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: InitType</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (expr) &#123;<br>    x  <span class="hljs-comment">// TrueType</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then I required that <code>FalseType = Exclude&lt;InitType, TrueType&gt;</code>. This was the criterion I used when I first posted the PR, but it turned out to be subtly incorrect.</p><p>I hadn&#39;t realized that type predicates had these &quot;if and only if&quot; semantics before working on this PR. This was a genuine insight, and I wrote about in another post on this blog: <a href="https://effectivetypescript.com/2024/02/27/type-guards/">The Hidden Side of Type Predicates</a>.</p><h2 id="Plot-Twist-Truthiness-and-Nullishness"><a href="#Plot-Twist-Truthiness-and-Nullishness" class="headerlink" title="Plot Twist: Truthiness and Nullishness"></a>Plot Twist: Truthiness and Nullishness</h2><p>Here&#39;s the example code from the original feature request in 2017:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> evenSquares: <span class="hljs-built_in">number</span>[] =<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<br>        .map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? x * x : <span class="hljs-literal">null</span>)<br>        .filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !!x);  <span class="hljs-comment">// errors, but should not</span><br></code></pre></td></tr></table></figure><p>With my new criterion came a real <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1959570195">plot twist</a>: I stopped inferring a type guard in this case! The reason is that &quot;truthiness&quot; doesn&#39;t cleanly separate <code>number|null</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (!!x) &#123;<br>  x;  <span class="hljs-comment">// number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  x;  <span class="hljs-comment">// number | null</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>number</code> is possible in the <code>else</code> case because <code>0</code> is falsy. (A type of <code>0|null</code> <a href="https://github.com/microsoft/TypeScript/issues/45329">would be more precise</a>).</p><p>I saw this as a mixed bag. While it meant that I didn&#39;t truly &quot;fix&quot; the original issue, I also think it&#39;s a good behavior. Checking for &quot;truthiness&quot; is usually a bad idea with primitive types. You typically want to exclude just <code>null</code> or <code>undefined</code>, not <code>0</code> or <code>&quot;&quot;</code>. Filtering out <code>0</code> when you mean to filter out <code>null</code> is a common source of bugs.</p><p>To infer a type predicate for <code>x =&gt; !!x</code>, TypeScript would either need <a href="https://github.com/microsoft/TypeScript/issues/4196">negated types</a> (so that you could represent &quot;numbers other than 0&quot;) or <a href="https://github.com/microsoft/TypeScript/issues/15048">one-sided type predicates</a>. Both are beyond the scope of my PR.</p><p>My change <em>will</em> infer a type predicate from <code>x =&gt; !!x</code> for object types, where there&#39;s no ambiguity.</p><h2 id="Putting-up-the-PR"><a href="#Putting-up-the-PR" class="headerlink" title="Putting up the PR"></a>Putting up the PR</h2><p><em>February 20–21, 2024</em></p><p>I showed my PR to <a href="https://www.joshuakgoldberg.com/">Josh Goldberg</a> around this time. I was a bit nervous to post the PR—I&#39;d put a lot of work into it at this point!—but he was excited and gave me the pep talk that I needed. So I wrote up a detailed PR description and <a href="https://github.com/microsoft/TypeScript/pull/57465">posted</a> my code the next day.</p><p>There was a <em>lot</em> of excitement! It was fun and encouraging to see all the positive feedback on Twitter. In particular Brad Zacher <a href="https://twitter.com/bradzacher/status/1760414631548653729">introduced</a> me to <a href="https://flow.org/en/docs/types/functions/#predicate-functions"><code>%checks</code></a>, which was a similar feature in Flow. His experience using this <a href="https://github.com/microsoft/TypeScript/pull/57552#issuecomment-1965983413">proved helpful later</a> in keeping the scope of my PR large.</p><p>I&#39;d run all the TypeScript unit tests on my laptop, so I knew that those passed. But there was a new test that failed in a really interesting way…</p><h2 id="A-Scary-Self-Check-Error"><a href="#A-Scary-Self-Check-Error" class="headerlink" title="A Scary Self-Check Error"></a>A Scary Self-Check Error</h2><p><em>February 21, 2024</em></p><p>TypeScript is written in… TypeScript! This is a bit of a headscratcher at first, but it&#39;s actually a common practice in programming languages known as <a href="https://stackoverflow.com/questions/1254542/what-is-bootstrapping">bootstrapping</a>. As such, it&#39;s important that TypeScript be able to compile itself with every change.</p><p>My PR was unable to compile TypeScript, and for a very interesting reason. It boiled down to whether this function should be a type predicate:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is the same as <code>flakyIsString</code>, but with a broader parameter type. We can convert this to an <code>if</code> statement as usual:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType: unknown</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Since <code>Exclude&lt;unknown, string&gt; = unknown</code>, my PR inferred a type predicate for this function. And that <em>is</em> valid if you call it with a symbol whose type is <code>unknown</code>. But there&#39;s no reason you have to do that! As with any function in TypeScript, you can call it with a subtype of the declared type. And if we infer a type predicate, that&#39;s trouble:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">string</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">const</span> sOrN: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">if</span> (flakyIsStringUnknown(sOrN)) &#123;<br>  sOrN  <span class="hljs-comment">// type is string</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  sOrN  <span class="hljs-comment">// type is number 😱</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The type in the <code>else</code> case is wrong. It could still be a <code>string</code>. So something was wrong with my criterion. I <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1957751656">feared</a> that this might be a fundamental problem with my approach.</p><p>I decided to step away from the problem and go for a walk.</p><h2 id="Saving-the-PR-A-New-Criterion"><a href="#Saving-the-PR-A-New-Criterion" class="headerlink" title="Saving the PR: A New Criterion"></a>Saving the PR: A New Criterion</h2><p>Recall that this was the criterion I was using:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseType = Exclude&lt;InitType, TrueType&gt;<br></code></pre></td></tr></table></figure><p><code>InitType</code> is the declared parameter type. Really I needed that relationship to hold not just for <code>InitType</code> but <em>for all subtypes</em> of <code>InitType</code>. But how on earth to test that?</p><p>Intuitively, it seemed to me like there was just one subtype of <code>InitType</code> that was worth testing: <code>TrueType</code>. If I set <code>InitType=TrueType</code>, I could run the same inference algorithm again to get <code>TrueSubType</code> and <code>FalseSubType</code>. Then I could check a secondary criterion:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseSubType = Exclude&lt;TrueType, TrueSubtype&gt;<br></code></pre></td></tr></table></figure><p>Here&#39;s what this would look like for <code>flakyIsStringUnknown</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;  <span class="hljs-comment">// InitType: unknown</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseType: unknown</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// ✅ unknown = Exclude&lt;unknown, string&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flakyIsStringUnknownSub</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) </span>&#123;  <span class="hljs-comment">// TrueType: string</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.random() &gt; <span class="hljs-number">0.5</span>) &#123;<br>    x  <span class="hljs-comment">// TrueSubType: string</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// FalseSubType: string</span><br>  &#125;<br>&#125;<br><span class="hljs-comment">// ❌ string != Exclude&lt;string, string&gt;</span><br></code></pre></td></tr></table></figure><p>This seemed to work, at the expense of making four calls to <code>getFlowTypeOfReference</code> rather than two. But correctness first, performance second. The PR was working again!</p><h2 id="A-Surprising-Circularity-Error"><a href="#A-Surprising-Circularity-Error" class="headerlink" title="A Surprising Circularity Error"></a>A Surprising Circularity Error</h2><p><em>February 23, 2024</em></p><!-- 2024-02-23: fixed the circularity error (https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1961723998) --><p>With the tests passing, I got my first glimpse of the performance impact of my changes, as well as the new errors on TypeScript&#39;s broader test suite of popular repos.</p><p>The performance wasn&#39;t great: +5% on one of their standard benchmarks.</p><p>There were <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960271216">six failures</a>. Four were sensible consequences of my change. <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1960328566">This one</a> from VS Code was particularly interesting:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> responseItems = items.filter(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> isResponseVM(i));<br></code></pre></td></tr></table></figure><p><code>isResponseVM</code> is a type guard. The author of this code wrapped it in an arrow function to avoid applying it as a refinement to the <code>items</code> array. But with my PR TypeScript wasn&#39;t so easily fooled! The type guard flowed through and the type of <code>responseItems</code> changed.</p><p>The only really problematic failure came from <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1961723998">Prisma</a>. This was a new &quot;circular reference&quot; error. I spent quite a while setting up a <a href="https://github.com/microsoft/TypeScript/blob/main/tests/cases/compiler/circularConstructorWithReturn.ts">minimal reproduction</a> of this before I realized what was going on: my code was running on constructor functions!</p><p>But not just any constructor function. Only constructor functions with exactly one <code>return</code> statement. Did you know that a constructor function in JS could have a <code>return</code> statement? I didn&#39;t. <a href="https://www.mgaudet.ca/technical/2020/7/24/investigating-the-return-behaviour-of-js-constructors">It&#39;s allowed</a>, but exceedingly rare. Regardless, constructors can&#39;t be type predicates, so I excluded them and this fixed the test.</p><p>One insight here is that lots of valid TypeScript code is teetering on the edge of triggering a circularity error. Just by checking a type in a different sequence in <code>checker.ts</code>, you might cause enough of a change to tip some over.</p><h2 id="Performance-and-the-Final-Criterion"><a href="#Performance-and-the-Final-Criterion" class="headerlink" title="Performance and the Final Criterion"></a>Performance and the Final Criterion</h2><p><em>February 25, 2024</em></p><!-- 2024-02-25: new criterion in place, posted on 26th https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842 --><p>With the changes in the test suite well-characterized, I started to think about performance. Were those four calls to <code>getFlowTypeOfReference</code> all necessary? The <code>TrueSubtype</code> was irrelevant. It should just be the same as <code>TrueType</code>. Maybe I could also ditch <code>FalseType</code> and go directly to the <code>FalseSubtype</code> test.</p><p>Moreover, if <code>TrueType == TrueSubtype</code>, and</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">FalseSubType = Exclude&lt;TrueType, TrueSubtype&gt;<br></code></pre></td></tr></table></figure><p>then really what I need to test is <code>FalseSubtype == never</code>. This was a nice win because it got me back to two calls to <code>getFlowTypeOfReference</code> <em>and</em> let me drop potentially-expensive <code>Exclude</code> calculations.</p><p>This wound up being the <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842">final version of the criterion</a>. Let&#39;s walk through how it works for this function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>First we rewrite this to an <code>if</code> statement to get the <code>TrueType</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    x  <span class="hljs-comment">// TrueType = string</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Next we pass this through as the parameter type and look at the <code>else</code> case:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStringFromUnknown</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    x  <span class="hljs-comment">// type is never</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If this type is <code>never</code> then we have a bulletproof type predicate. Otherwise we don&#39;t. This makes good intuitive sense: if the function returns true for every value in a type, then there should be nothing left in the <code>else</code> case, where it returns false.</p><p>With fewer calls to <code>getFlowTypeOfReference</code> and a simple <code>never</code> check, the performance hit dropped from 5% down to 1-2%.</p><h2 id="More-performance"><a href="#More-performance" class="headerlink" title="More performance"></a>More performance</h2><p><em>February 27–March 6, 2024</em></p><!--Anders review 2024-02-29Ill-fated optimization on 2024-03-02Second ill-fated opti on 2024-03-06--><p>At this point my PR started to get <a href="https://github.com/microsoft/TypeScript/issues/57568">discussed</a> at the <a href="https://github.com/microsoft/TypeScript/issues/57599">weekly design meetings</a>. They were generally supportive but wanted to track down that performance hit.</p><p>This set off a flurry of optimizations. Ryan <a href="https://github.com/microsoft/TypeScript/pull/57552">experimented</a> with narrowing the scope of the PR. Anders <a href="https://github.com/microsoft/TypeScript/pull/57612">reordered</a> some of the checks. I profiled my change and <a href="https://github.com/microsoft/TypeScript/pull/57465#issuecomment-1964355842">thought I found a big win</a> that didn&#39;t hold up.</p><p>An insight from profiling was that <code>getTypePredicateFromBody</code> was usually quite fast, but there were a few pathological cases where it could be very slow. This was the worst of the worst:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasBindableName</span>(<span class="hljs-params">node: Declaration</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> !hasDynamicName(node) || hasLateBindableName(node);<br>&#125;<br></code></pre></td></tr></table></figure><p>Both <code>hasDynamicName</code> and <code>hasLateBindableName</code> are explicit type predicates. So should this be a type predicate? Here&#39;s how the types come out:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">InitType &#x3D; Declaration<br>TrueType &#x3D; NumericLiteral | StringLiteral | NoSubstitutionTemplateLiteral | Identifier | TypeParameterDeclaration | ... 106 more ... | LateBoundBinaryExpressionDeclaration<br>FalseSubtype &#x3D; (PropertySignature &amp; DynamicNamedDeclarationBase) | (PropertyDeclaration &amp; DynamicNamedDeclarationBase) | ... 17 more ... | DynamicNamedBinaryExpression<br></code></pre></td></tr></table></figure><p>That&#39;s a big union! Calculating these types, particularly the <code>FalseSubtype</code>, winds up being very expensive. This one call took 300ms on my laptop and accounted for 80% of the slowdown on one benchmark.</p><p>I tried adding a <a href="https://github.com/microsoft/TypeScript/pull/57660">few more optimizations</a> but unfortunately they didn&#39;t change the perf numbers much. So a 1-2% slowdown is where it was going to be.</p><p>A highlight here was getting a very positive <a href="https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1909849513">code review</a> from Anders. This is definitely going on my resume!</p><img src="https://effectivetypescript.com/images/anders-code-review.png" alt="Positive Code Review from Anders Hejlsberg" style="max-width: 100%"><h2 id="A-productive-prod"><a href="#A-productive-prod" class="headerlink" title="A productive prod"></a>A productive prod</h2><p><em>March 12, 2024</em></p><p>At this point the PR stalled for around a week. I wanted to keep things moving along, but I also didn&#39;t want to be that person posting &quot;any updates?&quot; comments. I&#39;ve been on both sides of this. Those comments are rarely helpful. Presumably everyone wants the PR to make progress, there are just other priorities.</p><p>But in this case, there was an opportunity for a more constructive nudge. I had a draft of the <a href="https://amzn.to/3UjPrsK">second edition</a> of <em>Effective TypeScript</em> due on March 15th. One of the new items was &quot;Know how to filter null values from lists.&quot; If my PR went in, that item would be completely unsalvageable, and the best course of action would be to delete it completely.</p><p>Ryan Cavanaugh was a reviewer for the book, so I asked him what he thought the odds of my PR being merged were. If they were greater than 50/50, I should just delete the item.</p><p>Ryan said that Anders was &quot;super stoked&quot; on the PR and he thought it would go in for 5.5. Wow! Even better, he took the hint and reassigned the PR to Anders, who immediately approved it. Amazing! Ryan said he&#39;d ping the team for a last round of reviews.</p><h2 id="The-final-review"><a href="#The-final-review" class="headerlink" title="The final review"></a>The final review</h2><p><em>March 13–15, 2024</em></p><p>During that final round of reviews, Wes Wigham found <a href="https://github.com/microsoft/TypeScript/pull/57465#pullrequestreview-1935559962">two more issues</a>:</p><ol><li>I needed to avoid inferring type predicates for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters">rest parameters</a> (a pathological case I&#39;d missed!)</li><li>I needed to make sure that inferred type predicates showed up in emitted declaration files (<code>.d.ts</code>), just like inferred return types do.</li></ol><p>Adding <code>.d.ts</code> emit would have been a daunting change at the start of this process, but by now I was comfortable enough navigating the TypeScript codebase that it didn&#39;t prove too difficult.</p><p>The most confusing part here was that the tests all started failing on TypeScript&#39;s CI. I couldn&#39;t reproduce the failures on my laptop. This was quite frustrating until I figured out what was going on: the TypeScript CI does a <code>git merge main</code> before running your tests. There are differing opinions on whether this is a good idea, and I usually don&#39;t set up my repos to do it. But once I realized what was going on, the fix was easy: I just needed to merge the upstream changes myself.</p><p>There was one funny bug that came up here. My generated <code>.d.ts</code> files initially contained code that looked like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">syntaxRequiresTrailingSemicolonOrASI</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  kind: SyntaxKind</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">kind</span> <span class="hljs-title">is</span> <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">PropertyDeclaration</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">VariableStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ExpressionStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">DoStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ContinueStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">BreakStatement</span> |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ReturnStatement</span> |</span><br><span class="hljs-function">   ... 7 <span class="hljs-title">more</span> ... |</span><br><span class="hljs-function">   <span class="hljs-title">SyntaxKind</span>.<span class="hljs-title">ExportDeclaration</span></span>;<br></code></pre></td></tr></table></figure><p>That &quot;... 7 more ...&quot; isn&#39;t valid TypeScript syntax! It turns out I needed to set an emit flag to prevent truncation.</p><p>Wes requested that I do some minor refactoring and then approved the PR.</p><p>After a last round of tests, Ryan merged my PR. This was happening!</p><h2 id="Aftermath"><a href="#Aftermath" class="headerlink" title="Aftermath"></a>Aftermath</h2><!-- 2024-03-15 --><p>Once my PR went in, there was <a href="https://twitter.com/GabrielVergnaud/status/1769392854156095565">even more excitement</a> on TypeScript Twitter. <a href="https://twitter.com/AndaristRake/status/1768722035369181466">Andarist</a> and <a href="https://twitter.com/mattpocockuk/status/1768809254733951424">Matt Pocock</a> both tweeted about it, and Matt even wrote a <a href="https://www.totaltypescript.com/type-predicate-inference">blog post</a>. Jake Bailey put up a <a href="https://github.com/microsoft/TypeScript/pull/57830">very satisfying PR</a> that removed newly-superfluous type assertions from the TypeScript code base. There was one <a href="https://github.com/microsoft/TypeScript/issues/57947">bug filed</a> about inferring type predicates for tagged unions, which Andarist <a href="https://github.com/microsoft/TypeScript/pull/57952">quickly fixed</a>.</p><p>I explored a two followup changes:</p><ol><li>Lots of the Twitter reaction <a href="https://twitter.com/MiTypeScript/status/1768741478199697806">asked</a> whether <code>filter(Boolean)</code> would work now. The answer is no, but I explored how we could make this work (for object types) and found it <a href="https://github.com/microsoft/TypeScript/issues/50387#issuecomment-2037968462">harder than expected</a>.</li><li>I also looked into supporting type predicate inference for <a href="https://github.com/microsoft/TypeScript/pull/58154">functions with multiple <code>return</code> statements</a>. This isn&#39;t a major change to the existing logic and it has minimal performance impact. But there aren&#39;t many functions like this in the wild, so it may not be worth the effort.</li></ol><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>Stepping back, creating this PR was a great experience that worked out far better than I had any right to expect. My goal was to get a better sense for how TypeScript worked internally, and I certainly did that! But fixing a seven year-old bug and seeing the wildly positive response was even better.</p><p>I filed this issue in 2017 when TypeScript 2.3 was the latest and greatest. I&#39;d initially been drawn to work on it because I thought that an unrelated change in TypeScript 4.4 (2021) might have made it more tractable. That change turned out to be irrelevant. All of the machinery I wound up using to infer type predicates was already in place way back in 2017. It&#39;s just that no one had thought to put the pieces together in quite this way.</p><p>This is a great example of how bringing fresh eyes into an ecosystem can be beneficial. I don&#39;t think there are any other places where the type checker synthesizes a flow node. But I didn&#39;t know that, so I just did it. And it worked great!</p><p>TypeScript 5.5 should come out for beta testing in the next few weeks, and a final version should be out in the next few months. It&#39;s exciting to think that my experimental code from January will soon be running on every TypeScript function in the world!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Over the past few months I became a TypeScript contributor and implemented a new feature, &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/57465&quot;&gt;type predicate inference&lt;/a&gt;, that should be one of the headliners for TypeScript 5.5. This post tells the story of how that happened: why I wanted to contribute to TypeScript, the journey to implementing the feature and getting &lt;a href=&quot;https://github.com/microsoft/TypeScript/pull/57465&quot;&gt;the PR&lt;/a&gt; merged, and what I&amp;#39;ve learned along the way.&lt;/p&gt;
&lt;p&gt;This is not a short read, but it will give you a good sense of what it&amp;#39;s like to become a TypeScript contributor and develop a new feature.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Flow Nodes: How Type Inference Is Implemented</title>
    <link href="https://effectivetypescript.com/2024/03/24/flownodes/"/>
    <id>https://effectivetypescript.com/2024/03/24/flownodes/</id>
    <published>2024-03-25T03:00:00.000Z</published>
    <updated>2024-04-16T16:39:09.450Z</updated>
    
    <content type="html"><![CDATA[<style>  .entry-content img {    max-height: 400px;    max-width: 100%;  }</style><p>In most programming languages a variable has a type and that type does not change. But one of the most interesting aspects of TypeScript&#39;s type system is that a symbol has a type <em>at a location</em>. Various control flow constructs can change this type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refine</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-comment">// type of x is string | number here</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// type of x is number here.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// type of x is string here.</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><div style="display: inline-block; width: 256px; float:right; margin-left: 10px; margin-top: 10px;"><img src="https://effectivetypescript.com/images/dall-e-control-flow.jpg" width="256" height="256" alt="Dall-E's interpretation of TypeScript's control flow graph and type inference algorithm."> <i>Dall-E's interpretation of TypeScript's control flow graph and type inference algorithm.</i></div><p>This is known as &quot;refinement&quot; or &quot;narrowing.&quot; When I look at TypeScript code, I read it from top to bottom and I think about how the type of <code>x</code> changes as execution moves through each conditional. This works well but, as I learned from my recent work <a href="https://github.com/microsoft/TypeScript/pull/57465">adding a new form of type inference</a> in the TypeScript compiler, it&#39;s not at all how type inference is actually implemented!</p><p>For users of TypeScript, reading code from top to bottom works just fine. But if you&#39;re working in the TypeScript compiler itself, you&#39;ll need to know how type inference works &quot;under the hood.&quot; The key to this is &quot;Flow Nodes,&quot; which are the nodes in the Control Flow Graph. I had a remarkably hard time finding documentation about FlowNodes online. The official Compiler-Notes repo <a href="https://github.com/microsoft/TypeScript-Compiler-Notes/blob/main/codebase/src/compiler/binder.md#control-flow">just has a &quot;TODO&quot;</a> to document them. Basarat&#39;s TypeScript guide makes <a href="https://basarat.gitbook.io/typescript/overview/checker">no mention</a> of them in the section on the TypeScript Compiler.</p><p>I learned a lot about FlowNodes from implementing <a href="https://github.com/microsoft/TypeScript/pull/57465">#57465</a> and this post is my attempt to write the &quot;missing manual&quot; on them that I wish I&#39;d had a few months back.</p><h2 id="Confusion"><a href="#Confusion" class="headerlink" title="Confusion"></a>Confusion</h2><p>My first clue that type inference didn&#39;t work the way I expected came from reading a PR that Anders Hejlsberg wrote in 2021 to <a href="https://github.com/microsoft/TypeScript/pull/44730">add &quot;aliased conditions&quot; to type inference</a>. This let you write something like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">refine</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> isNum = <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>;<br>  <span class="hljs-keyword">if</span> (isNum) &#123;<br>    <span class="hljs-comment">// type of x is number here.</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// type of x is string here.</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>In my top-to-bottom way of thinking about type inference, it seemed like there must be some kind of &quot;tag&quot; associated with the <code>isNum</code> variable indicating that it refined the parameter <code>x</code>. But looking at Anders&#39; PR, this wasn&#39;t at all how it worked. He wasn&#39;t storing any information whatsoever! Instead, all I saw was a bunch of references to flow nodes. So clearly these were important.</p><p>When TypeScript parses your code, it forms an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree</a> (AST). Any node in the TypeScript AST can have an associated &quot;flow node.&quot; The best way to view the TypeScript AST is David Sherret&#39;s <a href="https://ts-ast-viewer.com/">TS AST Viewer</a>. When you click on a node, it shows you its FlowNode. This consisted of some flags, a node, and one or more &quot;antecedents.&quot; Curiously <code>node.flowNode.node</code> was never the same as <code>node</code>. It was always some other node in the AST.</p><p><img src="https://effectivetypescript.com/images/flownode-tree-view.png" alt="A Flow Node and its antecedent in the TS AST Viewer. I didn't find this view very illuminating."> <em>A Flow Node and its antecedent in the TS AST Viewer. I didn&#39;t find this view very illuminating.</em></p><h2 id="Graph-Visualization-and-an-Insight"><a href="#Graph-Visualization-and-an-Insight" class="headerlink" title="Graph Visualization and an Insight"></a>Graph Visualization and an Insight</h2><p>The antecedents were other FlowNodes. These seemed to form some sort of graph structure, so I thought that visualizing them might help. I&#39;d used GraphViz and the dot language to create graph visualizations on a <a href="https://www.sidewalklabs.com/products/delve">previous project</a>, and this seemed like a natural addition to the TS AST Viewer. I learned later that there was already a <a href="https://github.com/orta/playground-code-show-flow">TypeScript playground plugin</a> that did something similar.</p><p>Seeing this graph made it much clearer what was going on. This was the control flow graph in reverse! An <code>if</code> statement came out as a <a href="https://ts-ast-viewer.com/#code/GYVwdgxgLglg9mABAJwKbBmVAKAHgLkQGcplMBzRAH0TBAFsAjVZASkQG8AoRRCBEohhEAcg0QBeRFACeAB1RxgiXJIlSA5HSYsNAbh5Dl2YWPrtuvXvzBE4AG1QA6e3HLYNphvg0AaFawGvAC+iKj2RKichtYCDs6u7p5EAMqkFD7+uIGGwYY2do4ubh6MAIYQANbScIjg8EiyCho5vGhQIMhIXvQGwUA">diamond shape</a>:</p><p><img src="https://effectivetypescript.com/images/diamond-refine.png" alt="Control flow graph showing a diamond shape"><em>Full control flow graph showing a diamond shape for branching code.</em></p><p>I showed this to a <a href="https://github.com/sarahmeyer">batchmate</a> at <a href="https://www.recurse.com/">Recurse Center</a> who had the key insight: a Node&#39;s Flow Node is the previous statement that executed. With branching constructs, there will be more than one possible previous statement.</p><p>With loops, the graph <a href="https://ts-ast-viewer.com/#code/FA1hmCuB2DGAuBLA9tABAG2cgDgCgEo0BvYNTAU3jQA80BeNARgG4y0B3AC0QwrTx0APMwD6ABkkTJRUuXJ0AVIwBMbeWlioAzsj4A6LAHNBBdWgC+7AE5VI19DTYWgA">can even have a cyclic</a>:</p><p><img src="https://effectivetypescript.com/images/loop-graph.png" alt="Control flow graph showing a loop"><em>Control flow graph showing a cycle for looping code.</em></p><p>I eventually <a href="https://twitter.com/danvdk/status/1762868150800977996">added this visualization</a> to the TS AST Viewer. You can play around with it yourself to get a sense for how Flow Nodes work.</p><h2 id="Turning-Type-Inference-Upside-Down"><a href="#Turning-Type-Inference-Upside-Down" class="headerlink" title="Turning Type Inference Upside-Down"></a>Turning Type Inference Upside-Down</h2><p>With some intuition about Flow Nodes in place, the code I was seeing in the type checker started to make a lot more sense.</p><p>TypeScript greedily constructs the control flow graph in the binder (<code>binder.ts</code>), then lazily evaluates it as it needs to get types in the checker (<code>checker.ts</code>) or for display (<code>tsserver.ts</code>). This is backwards from how we think about narrowing in our heads: rather than narrowing types as you read down your code, TypeScript narrows types by traversing back <em>up</em> the control flow graph from the point where symbols are referenced.</p><p>Why does TypeScript do type inference this way? There are two reasons I can think of. The first is performance. In the context of the compiler, a symbol&#39;s type in a location is called its &quot;flow type.&quot; Determining a symbol&#39;s flow type can be an expensive operation. It requires traversing the control flow graph all the way back to the root (usually the start of a function) and potentially computing some relationships between types along the way.</p><p>But often the flow type isn&#39;t needed. If you have an <code>if</code> statement like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logNum</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x is a number&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Then the type of <code>x</code> inside the <code>if</code> statement is <code>number</code>. But that&#39;s not relevant to the type safety of this code in any way. There&#39;s no reason for TypeScript to determine the flow type of <code>x</code>. And indeed, it doesn&#39;t. At least not until you write <code>x</code> in the <code>if</code> block.</p><p>This leads us to a profound realization: until it becomes relevant, TypeScript has no idea what the type of <code>x</code> is!</p><p>If the type of <code>x</code> becomes relevant for type checking, then TypeScript <em>will</em> determine its flow type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logNum</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>    <span class="hljs-comment">// x is referenced, so TypeScript needs to know its type.</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;it&#x27;s a number:&quot;</span>, x);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>There may be many local variables in scope in your function. By only determining the flow types of the ones that are relevant for type checking, TypeScript potentially saves an enormous amount of work. This results in a more responsive editor and faster compile times. It also reduces TypeScript&#39;s memory usage: only the control flow graph needs to be stored permanently. Flow types can potentially be thrown away after they&#39;re checked.</p><p>The other reason that TypeScript does control flow analysis this way is to separate concerns in their code base. The control flow analysis graph is a standalone structure that&#39;s computed once in the binder. (This is the part of the compiler that determines which symbol <code>x</code> refers to in any location.) This graph can be constructed without any knowledge of what sort of analysis you&#39;d like to do on it.</p><p>That analysis happens in the checker, <code>checker.ts</code>. One part of the compiler constructs the graph greedily, the other runs algorithms on it lazily.</p><p>This is what I was seeing in <a href="https://github.com/microsoft/TypeScript/pull/44730">Anders&#39;s PR</a>. He already had all the information he needed in the control flow graph. His PR just made the algorithm that ran over it a little more elaborate. Very few PRs need to change how the control flow is constructed. It&#39;s much more common to change the algorithms that run over it.</p><h2 id="getFlowTypeOfReference"><a href="#getFlowTypeOfReference" class="headerlink" title="getFlowTypeOfReference"></a>getFlowTypeOfReference</h2><p>Speaking of algorithms, let&#39;s take a look at <code>getFlowTypeOfReference</code>, the workhorse of type inference. This is the function that determines the type of a symbol at a location. It&#39;s a real beast, clocking in at over 1200 lines of code. I&#39;d link to it in <a href="https://github.com/microsoft/TypeScript/blob/main/src/compiler/checker.ts"><code>checker.ts</code></a>, but GitHub won&#39;t even display files this large!</p><p><code>getFlowTypeOfReference</code> is so large because it follows the usual TypeScript compiler style of defining helper functions as local functions inside a large, top-level function. It quickly calls <code>getTypeAtFlowNode</code>, which is where the flow node graph traversal happens.</p><p>This function consists of a <code>while</code> loop that looks at the current Flow Node and tries to match it against all the different patterns that can trigger a refinement. If it doesn&#39;t find one, it moves up to the node&#39;s antecedent:</p><p><img src="https://effectivetypescript.com/images/flow-type-recursion.png" alt="The code for traversing up the antecedent graph"> <em>The code for traversing up the antecedent graph in getTypeAtFlowNode</em></p><p>All the different patterns of refinement that TypeScript supports are represented by helper functions. Here&#39;s a sample:</p><ul><li>narrowTypeByTruthiness</li><li>narrowTypeByBinaryExpression</li><li>narrowTypeByTypeof</li><li>narrowTypeByTypeName</li><li>narrowTypeBySwitchOnDiscriminant</li><li>narrowTypeByInstanceof</li><li>narrowTypeByTypePredicate</li><li>narrowTypeByEquality</li><li>narrowTypeByOptionalChainContainment</li></ul><p>It&#39;s interesting to think about what sort of code would trigger each of these. <code>narrowTypeByEquality</code>, for example, is a special case of <code>narrowTypeByBinaryExpression</code>. It would trigger on code like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// x is string in here</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>(There&#39;s an <code>assumeTrue</code> flag that toggles behavior based on <code>===</code> vs. <code>!==</code>.)</p><p><code>narrowTypeByEquality</code> is more subtle than you might expect! Take a look at this code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span>, y: <span class="hljs-built_in">number</span> | <span class="hljs-built_in">Date</span></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x === y) &#123;<br>    <span class="hljs-comment">// x is number</span><br>    <span class="hljs-comment">// y is number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>If two values are equal to one another, then their type must be the intersection of their declared types. Very clever, TypeScript!</p><p>What about branching constructs? TypeScript traverses up through both branches and unions the result. This should give you a sense for why determining flow types can be expensive! (The code for this is in <code>getTypeAtFlowBranchLabel</code>.)</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Hopefully this post has clarified what flow nodes are and how type narrowing is implemented in the TypeScript compiler. While this isn&#39;t important to understand for TypeScript users, I&#39;m still amazed that, after having used TypeScript for eight years, it turned out to work completely backwards from how I thought!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;If a variable gets a type but no one looks at it, does it really get a type at all?&lt;/p&gt;
&lt;p&gt;This post looks at how type inference is implemented in the TypeScript compiler. It&#39;s of some interest to anyone who uses TypeScript and is curious how it works, but it will be most relevant to developers who want to contribute to TypeScript itself.&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Hidden Side of Type Predicates</title>
    <link href="https://effectivetypescript.com/2024/02/27/type-guards/"/>
    <id>https://effectivetypescript.com/2024/02/27/type-guards/</id>
    <published>2024-02-27T15:45:00.000Z</published>
    <updated>2024-02-27T15:35:46.267Z</updated>
    
    <content type="html"><![CDATA[<p>For the past two months I&#39;ve been participating in a batch at the <a href="https://www.recurse.com/">Recurse Center</a> in Brooklyn, a &quot;writer&#39;s retreat for programmers.&quot; I&#39;ve been having lots of fun learning about <a href="https://github.com/danvk/gravlax">Interpreters</a>, <a href="https://github.com/danvk/Stanford-CS-242-Programming-Languages">Programming Languages</a> and <a href="https://github.com/karpathy/nn-zero-to-hero">Neural Nets</a>, but you apply to RC with a <em>project</em> in mind, and mine was to contribute to the TypeScript open source project. I&#39;ve used TypeScript and written about it for years, but I&#39;ve never contributed code to it. Time to change that!</p><p>The result is <a href="https://github.com/microsoft/TypeScript/pull/57465">PR #57465</a>, which adds a feature I&#39;ve always wanted in TypeScript: inference of <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type predicates</a>. I&#39;ll have more to say about that PR in a future post. But for now I&#39;d like to share some of what I&#39;ve learned about type predicates while implementing it.</p><h2 id="What-are-type-predicates"><a href="#What-are-type-predicates" class="headerlink" title="What are type predicates?"></a>What are type predicates?</h2><p>What is a type predicate? Whenever a function in TypeScript returns a <code>boolean</code>, you can change it to return a &quot;type predicate&quot; instead:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNumber</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here <code>x is number</code> is the type predicate. Any function that returns a type predicate is a &quot;user-defined type guard.&quot;</p><p>Here&#39;s how you use a type guard:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125;<br></code></pre></td></tr></table></figure><p>In this case there&#39;s little advantage over doing the <code>typeof</code> check directly in the <code>if</code> statement. But type guards really shine in two specific circumstances:</p><ol><li>When TypeScript can&#39;t infer the type you want on its own.</li><li>When you pass the type guard as a callback.</li></ol><p>The former often comes up with input validation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isProductReview</span>(<span class="hljs-params">input: unknown</span>): <span class="hljs-title">input</span> <span class="hljs-title">is</span> <span class="hljs-title">ProductReview</span> </span>&#123;<br>  <span class="hljs-comment">// ... validate input using JSONSchema, etc.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>But in this post we&#39;re more interested in the latter. Here&#39;s the motivating scenario:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span>);<br><span class="hljs-comment">//    ^? const nums: (number | string)[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());<br>  <span class="hljs-comment">//              ~~~~~~~</span><br>  <span class="hljs-comment">//    Property &#x27;toFixed&#x27; does not exist on type &#x27;string | number&#x27;.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>We&#39;ve filtered the array of strings and numbers down to just the numbers, but TypeScript hasn&#39;t been able to follow along. The result is a spurious type error.</p><p>Changing from an arrow function to the type guard fixes the problem:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> strsAndNums = [<span class="hljs-number">123</span>, <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&#x27;def&#x27;</span>];<br><span class="hljs-comment">//    ^? const strsAndNums: (number | string)[]</span><br><span class="hljs-keyword">const</span> nums = strsAndNums.filter(isNumber);<br><span class="hljs-comment">//    ^? const nums: number[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num <span class="hljs-keyword">of</span> nums) &#123;<br>  <span class="hljs-built_in">console</span>.log(num.toFixed());  <span class="hljs-comment">// ok</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This works because the declaration of <code>Array.prototype.filter</code> <a href="https://github.com/microsoft/TypeScript/blob/8f531ff3ba221344a93a63312326f9decfdcf458/src/lib/es5.d.ts#L1255-L1260">has been overloaded</a> to work with type predicates. Several built-in <code>Array</code> methods work this way, including <code>find</code> and <code>every</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> num = strsAndNums.find(isNumber);<br><span class="hljs-comment">//    ^? const num: number | undefined</span><br><span class="hljs-keyword">if</span> (strsAndNums.every(isNumber)) &#123;<br>  strsAndNums<br>  <span class="hljs-comment">// ^? const strsAndNums: number[]</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="What-if-you-return-false"><a href="#What-if-you-return-false" class="headerlink" title="What if you return false?"></a>What if you return false?</h2><p>If a function returns <code>x is T</code>, then it&#39;s clear what it means when it returns <code>true</code>: <code>x</code> is a <code>T</code>! But what does it mean if it returns <code>false</code>?</p><p>TypeScript&#39;s expectation is that type guards return <code>true</code> <em>if and only if</em> the predicate is true. To spell it out:</p><ul><li>If the type guard returns <code>true</code> then <code>x</code> is <code>T</code>.</li><li>If the type guard returns <code>false</code> then <code>x</code> is not <code>T</code>.</li></ul><p>This often works so intuitively that you don&#39;t even think about it. Using our <code>isNumber</code> type guard, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> strOrNum = <span class="hljs-built_in">Math</span>.random() &lt; <span class="hljs-number">0.5</span> ? <span class="hljs-number">123</span> : <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-comment">//  ^? let strOrNum: number | string</span><br><span class="hljs-keyword">if</span> (isNumber(strOrNum)) &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum;<br>  <span class="hljs-comment">// ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>But it can definitely go wrong! What about this type guard?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(x) &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>If this returns <code>true</code> then <code>x</code> is definitely a <code>number</code>. But if it returns <code>false</code>, then <code>x</code> could be either a <code>string</code> or a large <code>number</code>. This is not an &quot;if and only if&quot; relationship. This sort of incorrect type predicate can lead to <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsoundness</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (isSmallNumber(strOrNum)) &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toFixed());<br>  <span class="hljs-comment">//          ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(strOrNum.toUpperCase());<br>  <span class="hljs-comment">//          ^? let strOrNum: string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>This passes the type checker but blows up at runtime:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">  console.log(strOrNum.toUpperCase());<br>                       ^<br><br>Cannot read property toUpperCase of 123.<br></code></pre></td></tr></table></figure><p>This highlights two important facts about type guards:</p><ol><li>TypeScript does very little to check that they&#39;re valid.</li><li>There are expectations around the <code>false</code> case, and getting it right matters!</li></ol><p>Generally functions that combine checks with <code>&amp;&amp;</code> should not be type guards because the type will come out incorrectly for the <code>false</code> case.</p><p>Many functions only care about the <code>true</code> case. If you&#39;re just passing your type guard to <code>filter</code> or <code>find</code>, then you won&#39;t get into trouble. But if you pass it to a function like lodash&#39;s <a href="https://lodash.com/docs/4.17.15#partition"><code>_.partition</code></a> then you will:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;<br><span class="hljs-keyword">const</span> [smallNums, others] = _.partition(strsOrNums, isSmallNumber);<br><span class="hljs-comment">//                ^? const others: string[]</span><br></code></pre></td></tr></table></figure><p>This is an unsound type and it will lead to trouble. It&#39;s interesting to compare this with inlining the check into an <code>if</code> statement:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> strOrNum === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">Math</span>.abs(strOrNum) &lt; <span class="hljs-number">10</span>) &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  strOrNum<br>  <span class="hljs-comment">// ^? let strOrNum: number | string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Left to its own devices, TypeScript gets this right. The only reason it went wrong before was because we fed it bad information: <code>isSmallNumber</code> should not have been a type predicate!</p><p>Because of the strict rules around what <code>false</code> means, a type guard cannot, in general, replace an <code>if</code> statement. There&#39;s a <a href="https://github.com/microsoft/TypeScript/issues/15048">proposal</a> to fix this by adding &quot;one-sided&quot; or &quot;fine-grained&quot; type guards. If it were adopted, you&#39;d be able to declare something like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isSmallNumber</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">number</span></span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">number</span> <span class="hljs-title">else</span> (<span class="hljs-params"><span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>)</span>;<br></code></pre></td></tr></table></figure><h2 id="A-test-for-valid-type-predicates"><a href="#A-test-for-valid-type-predicates" class="headerlink" title="A test for valid type predicates"></a>A test for valid type predicates</h2><p>In the last example, we could tell that the type predicate was invalid because inlining it into an <code>if</code> statement produced different types in the <code>else</code> block than calling the type guard did.</p><p>This feels like a good test for type guards! Does it work?</p><p>As it turns out, no! There&#39;s a subtlety around subtyping that hadn&#39;t occurred to me until the <a href="https://github.com/microsoft/TypeScript/pull/57465/commits/e2684f128975dac725f4af4f9e6f03d4e765cfbe">tests failed</a> on my PR branch. The details and solution are a little too in the weeds for this post. But when I write a post about the making of this PR, we&#39;ll cover it in depth. There <em>is</em> a test. Check out the PR if you&#39;re curious.</p><p>In the meantime, though, we can talk about a few heuristics. If a condition fails the &quot;inlining&quot; test, then it&#39;s definitely not a valid type predicate.</p><h2 id="Non-Nullishness-not-Truthiness"><a href="#Non-Nullishness-not-Truthiness" class="headerlink" title="Non-Nullishness, not Truthiness"></a>Non-Nullishness, not Truthiness</h2><p>JavaScript and TypeScript make a distinction between &quot;truthiness&quot; and &quot;non-nullishness&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> isTruthy&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> !!x;<br><span class="hljs-keyword">const</span> isNonNullish&lt;T&gt;<span class="hljs-function">(<span class="hljs-params">x: T</span>) =&gt;</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>This is important for types like <code>number</code> and <code>string</code>. Here&#39;s why:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> numOrNull: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (numOrNull) &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  numOrNull;<br>  <span class="hljs-comment">// ^? const numOrNull: number | null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>The interesting part is the <code>number</code> in the <code>else</code> block. The number <code>0</code> is falsy, so <code>numOrNull</code> can be a <code>number</code> in the false case. (In theory TypeScript could narrow it to <code>0 | null</code>, but the TS team has decided this is <a href="https://github.com/microsoft/TypeScript/issues/45329">not worth it</a>.)</p><p>This means that if you make <code>isTruthy</code> return a type predicate, functions like <code>partition</code> will produce unsound types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> numsAndNulls = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">//    ^? const numsAndNulls: (number | null)[]</span><br><br><span class="hljs-keyword">const</span> isTruthy = (x: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>): x is <span class="hljs-built_in">number</span> =&gt; !!x;  <span class="hljs-comment">// don&#x27;t do this!</span><br><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, isTruthy);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure><p>TypeScript thinks that <code>nulls</code> is an array of <code>null</code> values, but it could actually contain numbers (specifically zeroes). This is an <a href="https://effectivetypescript.com/2021/05/06/unsoundness/">unsound type</a>. It&#39;s also likely to be a logic error: do you really mean to filter out the zeroes? If you&#39;re calculating an average, this will give you an incorrect result.</p><p>Better to use <code>isNonNullish</code> or the equivalent. This is safe:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> [nums, nulls] = _.partition(numsAndNulls, (x): x is <span class="hljs-built_in">number</span> =&gt; x !== <span class="hljs-literal">null</span>);<br><span class="hljs-comment">//           ^? const nulls: null[]</span><br></code></pre></td></tr></table></figure><p>You can make the generic <code>isNonNullish</code> into a type predicate, too:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isNonNullish</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">T</span> &amp; </span>&#123;&#125; &#123;<br>  <span class="hljs-keyword">return</span> x !== <span class="hljs-literal">null</span> &amp;&amp; x !== <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>This relies on the <code>&#123;&#125;</code> type, which is TypeScript for &quot;all values except <code>null</code> and <code>undefined</code>.&quot; This is one of the few good uses of this very broad type!</p><h2 id="Composing-predicates"><a href="#Composing-predicates" class="headerlink" title="Composing predicates"></a>Composing predicates</h2><p>In general you can compose type predicates with &quot;or&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooOrBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> | <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) || isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>Similarly, you can compose predicates with &quot;and&quot; if their types intersect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isFooAndBar</span>(<span class="hljs-params">x: unknown</span>): <span class="hljs-title">x</span> <span class="hljs-title">is</span> <span class="hljs-title">Foo</span> &amp; <span class="hljs-title">Bar</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> isFoo(x) &amp;&amp; isBar(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>This could happen if you have a big discriminated union and you have helpers that match different subsets of it.</p><p>Be careful about composing conditions that can&#39;t be fully represented in the type system, however. You can&#39;t define a TypeScript type for &quot;numbers less than 10&quot; or &quot;strings less than ten characters long&quot; or &quot;numbers other than zero.&quot; So conditions like these generally don&#39;t belong in a type guard:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// This should not return a type predicate!</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isShortString</span>(<span class="hljs-params">x: unknown</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; x.length &lt; <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>When you write a user-defined type guard, it&#39;s easy to only think about the <code>true</code> case: if you write <code>x is string</code> and you know that <code>x</code> must be a <code>string</code> when the function returns <code>true</code>, then surely you&#39;re good to go, right?</p><p>As this post has explained, that&#39;s only half the battle. In order for a type guard to be completely safe, it&#39;s also important to know what the type of the parameter is when it returns <code>false</code>. This is the hidden side of type predicates. It&#39;s easy to get wrong, and this can lead to unsound types.</p><p>Because it might be used in an <code>if</code> / <code>else</code> statement or with functions like <code>_.partition</code>, you want your type guard to be bulletproof! Make sure you provide the &quot;if and only if&quot; semantics that TypeScript expects.</p>]]></content>
    
    <summary type="html">
    
      Type guards are a powerful tool for improving TypeScript&#39;s built-in control flow analysis. This post looks at when it&#39;s appropriate to use a type predicate, and in particular what it means when a type predicate returns &lt;code&gt;false&lt;/code&gt;.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Effective TypeScript Talk at Etsy (Dec 2020)</title>
    <link href="https://effectivetypescript.com/2024/01/31/etsy/"/>
    <id>https://effectivetypescript.com/2024/01/31/etsy/</id>
    <published>2024-01-31T22:40:00.000Z</published>
    <updated>2024-01-31T22:41:36.679Z</updated>
    
    <content type="html"><![CDATA[<p>Back in 2020 I gave a whole series of <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> talks at companies that were interested in the language and the book. The talk that I gave at Etsy in December of 2020 was one of the most fun. It was recorded and is now available to watch. It&#39;s about an hour.</p><span id="more"></span><iframe width="560" height="315" src="https://www.youtube.com/embed/l40Vz9p5o7Q?si=t9RurUFI4ZJf2dNF" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>Here are the <a href="https://docs.google.com/presentation/d/1rx7In5TUiMm0q9z1wnWQf5tZeRS8z25NG3LqExsjj3U/edit?usp=sharing">slides</a>. Topics covered in this talk include:</p><ul><li>What is an &quot;Effective&quot; book?</li><li>What&#39;s the relationship between TypeScript and JavaScript (<a href="https://www.typescriptlang.org/play/#code/DYUwLgBAxglmCeEC8EDkA7EB3C8D2ATgNbRzyoDcAUFHugM56gB0weA5gBSwLNh4BVAA5CQBKAEN6ITgEpZ1KktoNI9MBLAh6yCAG0qECAG90EgLYgAXGgCCwCQCMLE1ABpoEoXAnAbqAFk6MHY8SwJyAF83QxMzS397KSJXD09vDT80ACkAV0wJXNRo2NMLazsCGAAvOlT0nyzUAAUACzwQdBgAD2KYowB6AYhmUaoAXWoAM0IIbjp1CHVNEAg8KaWNLXpZE1iVRhY2LmWtZkkMpgUqSKogA">playground</a>)</li><li>Why you shouldn&#39;t repeat type information in documentation (<a href="https://effectivetypescript.com/2023/05/31/jsdoc-repeat/">Item 30</a>; <a href="https://www.typescriptlang.org/play?#code/PQKhCgAIUglBTALgVwE4DsDOkCGlOKoCW6A5pAO5GIAWkt8kAZgParymovLoAmkAYxYAbNgDooMACo4A1vGwAveF0hs16RjlSlkAW3jpEmMZADq1Ouha4d+w8YA0kdigzYGk-Ihx9t-VnZObj5BEXFzSw0tOwMjZ1c0LHoaRkCOLh5+IVFUL0DcSAAHbUQiAWRhbWKcUngJaGBwJh4BMpZ0SDrEADE2DJDeAGFw1AAKErqAfgAub2IyAEpIAG8oFyQkmrrIAF59yAByUVISQ8gp1dQ5gEYAJgB2Z1Jbx+cAI1eHgF9IOZXrpAAAzPOYgyCfYHfADc4G+4HA3T6QUyfBGuTGiwRJEQKiYOAEjD6NjWkEgwGAkAAopYVIUqMJhBDGJgkGpUBDKERGcz8EgPshEJBrEL3ixaOscLN5iRSLCye9pQQFnK4QjQDAAMpsIUMGVkbDvACewvsxAEkAAbjhhMhGGMiGJ6pAAER3F2QAA8rpuQJdi1MABEWApheLIHoWLwiEwTeh9CZGs1Wu1OpgdQA5M3lG3CI1jeN6TBzZWygDaAF1FiXCOWK6t1okMKai2J06hEGMxjgPstdgA+SBZvTvFTd5YAWiH+lH43ei0WsPhQA">playground</a>)</li><li>Why you should think about types as sets of values (Item 7, <a href="https://www.typescriptlang.org/play?#code/PTAEBUE8AcFMGdQEMBOtT1gF0QewGajS7zwCWARgDboBuSVArggFAs1agAeoAvKAEYADAG4WPfgHJhksSxCgA6gAsknMoQDu6TUgB2nLLmRUquTaCzKy8APxsFAVT1lDMViyzvQAQQBCAMJ8oJI+kqAAPiF+4VGSAbLs2MgAXL6BwaGJSJkxYjlSACKJ8mAqapKIAERIpGQA5npI1LBV9iwAJrAAxlSo6BwYAPIoAHJp8FgoZHr1kaB6jAC2FLAocgCyasoAdPAAjihYABTwI6MAlHIKAJKIiytrlsrouHpUkJbeVmqgS0gAawQzxsoE0uBQAPaCgAypAVrgqIhVLR0DkvHBQAB9X45MzdNRkN5YljdN6TUCwKjBDq4brLWAGHb1bAAURoS0ZWD8kBuHWOkiWkAAtFTJFcWAw1icqTssLAuFgAm95QYJaVQAAlWBIDqgKoK1UdeBVZDVeCMCiYTgEKosGbylD4JDddCjRimSAwrCMLoGUAAbxYoBDoDIHQmUxm9TEoYWSE5kems3mi1MYgAvg4wHcQYghgBpaFgB1rZ2u0De31cymKxnG0Duz1Vv2cIMKONNRMYKOzMQKLNAA">playground</a>)</li><li>Designing types that only represent valid states (Item 28, <a href="https://www.typescriptlang.org/play?#code/PTDECcFMHMEsHsB2AoWiAulwDMCGBjSAAgGV1dMiBvZIo-AV3CgwAVdpIAuIgZ3XBpoAblpEADh0gAVSAA90PfoMQixsXgBl4uACZCeAI3jwANpFyJRdLOHjgA-EoFDRAX2QhQkRLqhwkZGR5cXt0ImwGRHx0BEQiFl0sdk4ACn4KblJyTABKajEQIgA6UrEodCZ4gAMAHgALAEYAPgASKgzMYsZmH3QUyDda4CbmgB1Eds7IYslOWQU3avcgr3841AwsPEIiACVIAEcGSH5WH31VArppngBycQuhO5W0TBwCYgPj0-QAUWY9mufByWTutnsLzEEPAzhUag8b22n32RxO-BIDHwhF4vGBtyId3gAGsoXQ5jJ5IoQfCVugAJ6PVE-DGgogAXmZ6P6TyuAB8ub8AXZwEQBd9uZjsadeKJNu8dsQyJkAEzAnosfpSOGucpo368HhUADaFJ1qgAujwJb9lZg3CsvBd1kggA">playground</a>)</li><li>How to avoid fighting with the type checker (<a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAcwE4FN1QBRgIYC26AXIgM5SoxjIA0iARjKlABYAieUJin3iAH0RgQAG1EBKRAG8AUIkSisiPMnQBZMogC8jZmz7pEAfl5d0AOjBwA7tikBaPSw7mLaqABUYRe4lIi4gDcsvKKymiYsDQ6iAAGABLo4nCIACTS+EQAvhZxIQowwIjYTC6GUnIK1ZFY1MiIANS6cYgAmnAgKhglqJ3IrKIAnlIZqhpaAPSIAIwADAvZ5OgQCAAmWnCia3kFiNlhGFAgqEi10cghB0A">playground</a>)</li></ul><p>The content of the talk represents my views, it wasn&#39;t by or on behalf of Etsy. If you&#39;re interested in hosting an <em>Effective TypeScript</em> talk at your company or meetup, please <a href="https://twitter.com/danvdk">get in touch</a>!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Back in 2020 I gave a whole series of &lt;a href=&quot;https://amzn.to/3HIrQN6&quot;&gt;&lt;em&gt;Effective TypeScript&lt;/em&gt;&lt;/a&gt; talks at companies that were interested in the language and the book. The talk that I gave at Etsy in December of 2020 was one of the most fun. It was recorded and is now available to watch. It&amp;#39;s about an hour.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Don&#39;t Write Traditional Getter and Setter Methods in JavaScript and TypeScript</title>
    <link href="https://effectivetypescript.com/2023/12/31/getters-setters/"/>
    <id>https://effectivetypescript.com/2023/12/31/getters-setters/</id>
    <published>2023-12-31T22:20:00.000Z</published>
    <updated>2023-12-31T22:22:52.976Z</updated>
    
    <content type="html"><![CDATA[<p>Say you want to create a class to represent a point in two-dimensional space. If you come from a <a href="https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">certain background</a>, your immediate instinct may be to create some private properties and <a href="https://dzone.com/articles/java-getter-and-setter-basics-common-mistakes-and">getter/setter methods</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point2D</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> x: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> y: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">getX</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setX</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.x = x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getY</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.y;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setY</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.y = y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This feels productive. You&#39;re writing code, after all! If you&#39;re feeling especially diligent, you might even write JSDoc comments for each of these methods. Your editor might even include shortcuts to write all these getters and setters for you.</p><p>Here&#39;s some code that uses that class:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> Point2D();<br>pt.setX(<span class="hljs-number">3</span>);<br>pt.setY(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(pt.getX(), pt.getY());  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>The downside is that this is a lot of boilerplate code that doesn&#39;t do very much. Why write the getters and setters rather than this?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectPoint2D</span> </span>&#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> DirectPoint2D();<br>pt.x = <span class="hljs-number">3</span>;<br>pt.y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(pt.x, pt.y);  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>At least in Java, the answer is that getters and setters encapsulate the implementation of the class and give it much greater flexibility to evolve in the future.</p><p>For example, what if you realize that for some reason it&#39;s much better to use <a href="https://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a> internally? With the getters and setters, it&#39;s no trouble to reimplement the old API using the new internal representation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point2D</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> r: <span class="hljs-built_in">number</span>;<br>  <span class="hljs-keyword">private</span> theta: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-function"><span class="hljs-title">getX</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">getY</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setX</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">this</span>.getY();<br>    <span class="hljs-built_in">this</span>.r = <span class="hljs-built_in">Math</span>.sqrt(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">this</span>.theta = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">setY</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>)</span> &#123;<br>    <span class="hljs-comment">// ... similar</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Users of the <code>Point2D</code> class will be completely oblivious to this internal change. The code above works without change. Contrast this with <code>DirectPoint2D</code>. You can&#39;t make an analogous change to this version because the internals are exposed. You can&#39;t get rid of the <code>x</code> and <code>y</code> properties without making a breaking change to the API. You&#39;re stuck.</p><p>That&#39;s the story in Java, anyway, and it was also the story for JavaScript in the 1990s and early 2000s. If you use <a href="https://github.com/google/closure-library/blob/7818ff7dc0b53555a7fb3c3427e6761e88bde3a2/closure/goog/ui/gauge.js#L473">very old JS libraries</a> (or libraries written by recent transplants from Javaland), you may still run across these sorts of getter and setter methods. After publishing my <a href="https://effectivetypescript.com/2023/09/27/closure-compiler/">post about Google&#39;s Closure Compiler</a> I <a href="https://news.ycombinator.com/item?id=37699258">learned</a> that one of its goals was to inline simple methods like these.</p><p>But getter and setter methods like these are <em>not</em> a good idea in modern JavaScript or TypeScript. The reason is that back in 2009, ES5 introduced a new syntax for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get">get</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set">set methods</a> that entirely eliminates this problem with direct property access.</p><p>Here&#39;s how you&#39;d migrate <code>DirectPoint2D</code> to a polar coordinates representation using getter and setter methods:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectPoint2D</span> </span>&#123;<br>  r = <span class="hljs-number">0</span>;<br>  theta = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">x</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.cos(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">x</span>(<span class="hljs-params">x: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-keyword">const</span> y = <span class="hljs-built_in">this</span>.y;<br>    <span class="hljs-built_in">this</span>.r = <span class="hljs-built_in">Math</span>.sqrt(x**<span class="hljs-number">2</span> + y**<span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">this</span>.theta = <span class="hljs-built_in">Math</span>.atan2(y, x);<br>  &#125;<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">y</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.r * <span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">this</span>.theta);<br>  &#125;<br><br>  <span class="hljs-keyword">set</span> <span class="hljs-title">y</span>(<span class="hljs-params">y: <span class="hljs-built_in">number</span></span>) &#123;<br>    <span class="hljs-comment">// ... similar to set x</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Usage looks exactly as it did before:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = <span class="hljs-keyword">new</span> DirectPoint2D();<br>pt.x = <span class="hljs-number">3</span>;<br>pt.y = <span class="hljs-number">4</span>;<br><span class="hljs-built_in">console</span>.log(pt.x, pt.y);  <span class="hljs-comment">// logs 3, 4</span><br></code></pre></td></tr></table></figure><p>What were direct property accesses before have become method calls. But the syntax is character-for-character identical, so the caller need not be aware that anything has changed. The public properties are no longer a constraint on your class design.</p><p>The takeaway here is that it&#39;s OK to use a public property on a class in JavaScript and TypeScript. You may read warnings in books and online about how this is a bad practice, but this advice has more to do with specific limitations of Java and old-school JS than it does with modern JavaScript and TypeScript. When you write getter and setter methods in JavaScript, you&#39;re working around a problem that no longer exists.</p><p>Simple getter and setter methods are a code smell in JavaScript and TypeScript. Don&#39;t write them! If you see them in a code review, suggest replacing them with a public property and send your coworker here for an explanation of why.</p><p>One cautionary note: don&#39;t go too crazy with <code>get</code> and <code>set</code>. When you read code like <code>pt.x = 3</code>, you expect that this will do something like setting the <code>x</code> property of <code>pt</code> to <code>3</code>. Of course, with a <code>set</code> method, it <em>could</em> do anything. It could set <code>y</code> instead, or it could even issue a network request. But to avoid confusion and surprise, it&#39;s best if paired <code>get</code> and <code>set</code> methods get and set the same thing, at least conceptually.</p><p><em>Here&#39;s a complete <a href="https://www.typescriptlang.org/play?#code/MYGwhgzhAEAiCWAnApsALgBQPbwHZoCZZoBvAKGmkWgF5oAGAbgujQAtk0xaHmXgsuCGkQBXdFkQAKAB4AuaLlEBbAEbJEAGmgBPBUrUaAlKRaV28CADoZPGc0rm2lqzp46H0AL5kWAc05oGSkTckcqTlFEXFZna2oAKmgAWTB2KwEIKQtrdk4wI08fSghA4PlFFXVEULNoASE0XR4c108nF2o6VPSIAEdENFkEhIJoAGpdEYJCuta8rh4etis0sFwCKR1tGVnKH39AnRDTcJQ0KJjWxJS0lYg8bLirBYKi3xKjrf0q41PHBrCIItZ72ObPLq3XoDIYyaYTKajPaOeYcRbdO6rLgbLY7ZE+A6ApoAByadFwyAA7nAkKhMDh8EQpABmbQAFlmgKwIGQVhAWD8UlJNm0wp0syAA">playground link</a> for the last example if you want to give it a try.</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Getter and setter methods (&lt;code&gt;getFoo&lt;/code&gt;, &lt;code&gt;setFoo&lt;/code&gt;) are common in Java and considered a best practice. But they&#39;re a code smell that&#39;s best avoided in JavaScript and TypeScript because the problem they solve in Java does not exist in JS/TS. This post looks at what that problem is and how you can solve it in TypeScript without imposing the boilerplate of getters and setters.&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Using infer to unpack nested types</title>
    <link href="https://effectivetypescript.com/2023/11/29/infer-deep/"/>
    <id>https://effectivetypescript.com/2023/11/29/infer-deep/</id>
    <published>2023-11-29T21:07:00.000Z</published>
    <updated>2023-11-29T21:08:33.435Z</updated>
    
    <content type="html"><![CDATA[<img src="https://effectivetypescript.com/images/magnifying-glass.png" width="128" height="128" alt="Inspecting a type with a magnifying glass" style="max-height: 100%; float: right"><p>In a <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">previous post</a> I suggested using intersections as a sort of type-level &quot;as any&quot;. I&#39;d personally found this technique useful on a few projects as a way of silencing type errors without losing type safety. Because you often needed to apply this trick two or three times for deeply nested types, it also led me to explore ways of <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">reducing repetition in type-level code</a>.</p><p>But when I started reworking that advice into an Item for the upcoming second edition of <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a>, I learned something interesting: there&#39;s usually a better way! TypeScript&#39;s <code>infer</code> keyword can infer quite a lot, and it offers a more direct way to achieve the same goals I talked about in those two posts without the repetition.</p><p>Those previous posts were motivated by my <a href="https://github.com/danvk/crosswalk">crosswalk</a> library, which helps you build and use type-safe REST APIs. Using <code>infer</code> works in that context, too, but the difference is even more dramatic when we look at an <a href="https://spec.openapis.org/oas/v3.1.0">OpenAPI Schema</a>.</p><p>Say your API lets you create a user. (It also lets you GET a user, but I&#39;ll only show the POST here since this is already verbose.) The OpenAPI Schema might look like this:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">&#123;<br>  <span class="hljs-string">&quot;openapi&quot;</span>: <span class="hljs-string">&quot;3.0.3&quot;</span>,<br>  <span class="hljs-string">&quot;info&quot;</span>: &#123; <span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;Users API&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>: <span class="hljs-string">&quot;0.1&quot;</span> &#125;,<br>  <span class="hljs-string">&quot;paths&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;/users&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;post&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;requestBody&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;content&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;application/json&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;schema&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;$ref&quot;</span>: <span class="hljs-string">&quot;#/components/schemas/CreateUserRequest&quot;</span><br>              &#125;<br>            &#125;<br>          &#125;,<br>          <span class="hljs-string">&quot;required&quot;</span>: <span class="hljs-literal">true</span><br>        &#125;,<br>        <span class="hljs-string">&quot;responses&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;200&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;Newly-created User&quot;</span>,<br>            <span class="hljs-string">&quot;content&quot;</span>: &#123;<br>              <span class="hljs-string">&quot;application/json&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;schema&quot;</span>: &#123;<br>                  <span class="hljs-string">&quot;$ref&quot;</span>: <span class="hljs-string">&quot;#/components/schemas/User&quot;</span><br>                &#125;<br>              &#125;<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-string">&quot;components&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;schemas&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;CreateUserRequest&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span> &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;required&quot;</span>: [ <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span> ]<br>      &#125;,<br>      <span class="hljs-string">&quot;User&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;properties&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;id&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span> &#125;,<br>          <span class="hljs-string">&quot;age&quot;</span>: &#123; <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;number&quot;</span> &#125;<br>        &#125;,<br>        <span class="hljs-string">&quot;required&quot;</span>: [ <span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;age&quot;</span> ]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>You can run this through <a href="https://github.com/drwpow/openapi-typescript">openapi-typescript</a> to generate TypeScript types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** This file was auto-generated by openapi-typescript. */</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> paths &#123;<br>  <span class="hljs-string">&quot;/users&quot;</span>: &#123;<br>    post: &#123;<br>      requestBody: &#123;<br>        content: &#123;<br>          <span class="hljs-string">&quot;application/json&quot;</span>: components[<span class="hljs-string">&quot;schemas&quot;</span>][<span class="hljs-string">&quot;CreateUserRequest&quot;</span>];<br>        &#125;;<br>      &#125;;<br>      responses: &#123;<br>        <span class="hljs-comment">/** <span class="hljs-doctag">@description <span class="hljs-variable">Newly</span></span>-created User */</span><br>        <span class="hljs-number">200</span>: &#123;<br>          content: &#123;<br>            <span class="hljs-string">&quot;application/json&quot;</span>: components[<span class="hljs-string">&quot;schemas&quot;</span>][<span class="hljs-string">&quot;User&quot;</span>];<br>          &#125;;<br>        &#125;;<br>      &#125;;<br>    &#125;;<br>    <span class="hljs-comment">// also get, etc.</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> components &#123;<br>  schemas: &#123;<br>    CreateUserRequest: &#123;<br>      name: <span class="hljs-built_in">string</span>;<br>      age: <span class="hljs-built_in">number</span>;<br>    &#125;;<br>    User: &#123;<br>      id: <span class="hljs-built_in">string</span>;<br>      name: <span class="hljs-built_in">string</span>;<br>      age: <span class="hljs-built_in">number</span>;<br>    &#125;;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Accessing these types via the <code>path</code> structure involves a <a href="https://github.com/drwpow/openapi-typescript/tree/main/packages/openapi-typescript#basic-usage">whole bunch of indexing</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> UserResponse = paths[<span class="hljs-string">&quot;/users&quot;</span>][<span class="hljs-string">&quot;post&quot;</span>][<span class="hljs-string">&quot;responses&quot;</span>][<span class="hljs-number">200</span>][<span class="hljs-string">&quot;content&quot;</span>][<span class="hljs-string">&quot;application/json&quot;</span>];<br></code></pre></td></tr></table></figure><p>If you want to make a generic POST method, you&#39;ll quickly run into some errors:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>&lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">paths</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  endpoint: Path</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">paths</span>[<span class="hljs-title">Path</span>][&quot;<span class="hljs-title">post</span>&quot;][&quot;<span class="hljs-title">responses</span>&quot;][200][&quot;<span class="hljs-title">content</span>&quot;][&quot;<span class="hljs-title">application</span>/<span class="hljs-title">json</span>&quot;]&gt;</span>;<br><span class="hljs-comment">//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br><span class="hljs-comment">// Type &#x27;&quot;application/json&quot;&#x27; cannot be used to index type &#x27;paths[Path][&quot;post&quot;][&quot;responses&quot;][200][&quot;content&quot;]&#x27;. (2536)</span><br></code></pre></td></tr></table></figure><p>This error makes sense: TypeScript has no reason to believe that this deep sequence of index operations will work on an arbitrary type.</p><p>You can use <code>infer</code> to extract just what you want out of this structure:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> HttpVerb = <span class="hljs-string">&#x27;get&#x27;</span> | <span class="hljs-string">&#x27;post&#x27;</span> | <span class="hljs-string">&#x27;patch&#x27;</span> | <span class="hljs-string">&#x27;delete&#x27;</span> | <span class="hljs-string">&#x27;update&#x27;</span>;<br><span class="hljs-keyword">type</span> ResponseForMethod&lt;Path <span class="hljs-keyword">extends</span> keyof paths, Verb <span class="hljs-keyword">extends</span> HttpVerb&gt; =<br>  paths[Path] <span class="hljs-keyword">extends</span> Record&lt;Verb, &#123;<br>    responses: &#123;<br>      <span class="hljs-number">200</span>: &#123;<br>        content: &#123;<br>          <span class="hljs-string">&#x27;application/json&#x27;</span>: infer ResponseType,  <span class="hljs-comment">// &lt;-- the &quot;infer&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;&gt; ? ResponseType : <span class="hljs-built_in">never</span>;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">post</span>&lt;<span class="hljs-title">Path</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">paths</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  endpoint: Path</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">ResponseForMethod</span>&lt;<span class="hljs-title">Path</span>, &#x27;<span class="hljs-title">post</span>&#x27;&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> response = post(<span class="hljs-string">&#x27;/users&#x27;</span>);<br><span class="hljs-comment">//    ^? const response: Promise&lt;&#123; id: string; name: string; age: number; &#125;&gt;</span><br></code></pre></td></tr></table></figure><p>What surprised (and impressed me) was that <code>infer</code> can see right through the <code>Record</code> helper, which is a <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#recordkeys-type">wrapper around a mapped type</a>.</p><p>If the endpoint doesn&#39;t support <code>POST</code> requests, you&#39;ll get a <code>never</code> type back. A type error would be better, but hopefully the <code>never</code> will be enough to alert the caller that something is amiss.</p><p>My <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">previous posts</a> would have suggested this <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">chain of helpers</a> instead:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> LooseKey&lt;T, K&gt; = T[K &amp; keyof T];<br><span class="hljs-keyword">type</span> LooseKey2&lt;T, K1, K2&gt; = LooseKey&lt;LooseKey&lt;T, K1&gt;, K2&gt;;<br><span class="hljs-keyword">type</span> LooseKey3&lt;T, K1, K2, K3&gt; = LooseKey&lt;LooseKey2&lt;T, K1, K2&gt;, K3&gt;;<br><span class="hljs-keyword">type</span> LooseKey4&lt;T, K1, K2, K3, K4&gt; = LooseKey&lt;LooseKey3&lt;T, K1, K2, K3&gt;, K4&gt;;<br><span class="hljs-keyword">type</span> LooseKey5&lt;T, K1, K2, K3, K4, K5&gt; = LooseKey&lt;LooseKey4&lt;T, K1, K2, K3, K4&gt;, K5&gt;;<br><br><span class="hljs-keyword">type</span> ResponseForMethod&lt;Path <span class="hljs-keyword">extends</span> keyof paths, Verb <span class="hljs-keyword">extends</span> HttpVerb&gt; =<br>  LooseKey5&lt;paths[Path], Verb, <span class="hljs-string">&#x27;responses&#x27;</span>, <span class="hljs-number">200</span>, <span class="hljs-string">&#x27;content&#x27;</span>, <span class="hljs-string">&#x27;application/json&#x27;</span>&gt;;<br></code></pre></td></tr></table></figure><p>Yikes! Compared to this intersection form, the <code>infer</code> approach is more direct, easier to read and more closely matches the layout of the data. And if you need to extract multiple pieces of information from a type, it&#39;s clear how to do it. This is a nice win.</p><p>So is <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">&quot;intersect what you have with whatever TypeScript wants&quot;</a> still a useful technique? You sometimes need to write <code>&amp; string</code> when passing a type parameter to another generic type that expects a <code>string</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// see previous post</span><br><span class="hljs-keyword">type</span> ExtractRouteParams&lt;Path <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; = ...;<br><span class="hljs-comment">// e.g. ExtractRouteParams&lt;&#x27;/users/:userId&#x27;&gt; = &#123;userId: string&#125;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiWrapper</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  apiGet&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path,<br>    queryParams: ExtractRouteParams&lt;Path&gt;,<br>    <span class="hljs-comment">//                              ~~~~</span><br>    <span class="hljs-comment">// Type &#x27;Path&#x27; does not satisfy the constraint &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//   Type &#x27;keyof API&#x27; is not assignable to type &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//     Type &#x27;string | number | symbol&#x27; is not assignable to type &#x27;string&#x27;.</span><br>    <span class="hljs-comment">//       Type &#x27;number&#x27; is not assignable to type &#x27;string&#x27;. (2344)</span><br>  ): <span class="hljs-built_in">Promise</span>&lt;GetResponseForMethod&lt;API, Path&gt;&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>Check out <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> for a definition of <code>ExtractRouteParams</code>. The problem is that we expect <code>keyof API</code> to be a subtype of <code>string</code>, but strictly speaking all TypeScript knows is that it&#39;s a subtype of <code>PropertyKey</code>, aka <code>string | number | symbol</code>. There&#39;s nothing preventing <code>API</code> from being <code>string[]</code>, for example, in which case <code>keyof API = number</code>. Since <code>ExtractRouteParams</code> expects a <code>string</code>, this won&#39;t fly.</p><p>The best solution would be to tell TypeScript that <code>API</code> should only have <code>string</code> keys. But I&#39;m not aware of any way to do that: writing <code>ApiWrapper&lt;API extends Record&lt;string, any&gt;&gt;</code> results in the same error.</p><p>In this case, using an intersection to silence the error still makes sense:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiWrapper</span>&lt;<span class="hljs-title">API</span>&gt; </span>&#123;<br>  apiGet&lt;Path <span class="hljs-keyword">extends</span> keyof API&gt;(<br>    path: Path,<br>    queryParams: ExtractRouteParams&lt;Path &amp; <span class="hljs-built_in">string</span>&gt;,  <span class="hljs-comment">// ok</span><br>  ): <span class="hljs-built_in">Promise</span>&lt;GetResponseForMethod&lt;API, Path&gt;&gt;;<br>&#125;<br></code></pre></td></tr></table></figure><p>When you&#39;re working with nested object types, remember that you can use <code>infer</code> to extract a particular type from deep inside them.</p><p><em>Image credit: <a href="https://commons.wikimedia.org/wiki/File:Magnifying_glass_icon_by_Manjiro5.svg">Wikimedia Commons</a></em></p>]]></content>
    
    <summary type="html">
    
      TypeScript&#39;s &lt;code&gt;infer&lt;/code&gt; keyword can infer quite a bit more than you might expect. It&#39;s extremely effective at extracting types from the sort of nested structures that you might get from codegen or an API specification.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Overload on the type of this to specialize generics (The Lost Item)</title>
    <link href="https://effectivetypescript.com/2023/10/27/specialize-this/"/>
    <id>https://effectivetypescript.com/2023/10/27/specialize-this/</id>
    <published>2023-10-27T14:50:00.000Z</published>
    <updated>2023-10-27T14:52:38.982Z</updated>
    
    <content type="html"><![CDATA[<p><em>I cut one item from <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> during the final stages of editing. Four years later, it&#39;s time for it to see the light of day! It&#39;s a trick for specializing generic types for certain subtypes of their type parameters. This post shows how it works, why it&#39;s indispensible for wrapper types, and also explains why I cut it from the book.</em></p><p>As you write type declarations for generic classes, you may find that you want to make some methods available only for particular values of the generic parameter. This often comes up with wrapper objects. In the lodash utility library, for example, you can rewrite a series of function calls:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_.sum(<br>  _.map(<br>    _.filter(<br>      _.split(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">Math</span>.PI, <span class="hljs-string">&#x27;&#x27;</span>),<br>      digit =&gt; digit !== <span class="hljs-string">&#x27;.&#x27;</span>),<br>    <span class="hljs-built_in">Number</span>));  <span class="hljs-comment">// result is 80</span><br></code></pre></td></tr></table></figure><p>into a <a href="https://lodash.com/docs/4.17.15#chain">chain</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_.chain(<span class="hljs-string">&#x27;&#x27;</span> + <span class="hljs-built_in">Math</span>.PI)<br>  .split(<span class="hljs-string">&#x27;&#x27;</span>)<br>  .filter(<span class="hljs-function"><span class="hljs-params">digit</span> =&gt;</span> digit !== <span class="hljs-string">&#x27;.&#x27;</span>)<br>  .map(<span class="hljs-built_in">Number</span>)<br>  .sum()<br>  .value();  <span class="hljs-comment">// result is 80</span><br></code></pre></td></tr></table></figure><p>The call to <code>_.chain(val)</code> creates a wrapper object which is eventually unwrapped by a call to <code>.value()</code>. This reads more naturally since the execution order matches the code order: top to bottom, left to right.</p><p>Modeling this in TypeScript presents some challenges:</p><ul><li>The <code>split</code> method should only be available on wrapped strings.</li><li>The <code>filter</code> and <code>map</code> methods should only be available on arrays. (In the real lodash library they work on objects, too, but have different type signatures.)</li><li>The <code>sum</code> method should only be available on wrapped arrays of strings or numbers.</li></ul><p>For example, calling <code>map</code> on a wrapped number should be an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI)<br>  .map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~ map method not available</span><br></code></pre></td></tr></table></figure><p>You can start by defining the wrapper interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>(Since we&#39;re writing declarations here, we assume there&#39;s already an implementation defined elsewhere which may use different classes at runtime.)</p><p>You can verify that this wraps and unwraps values by writing a simple chain and inspecting the intermediate types in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI).value();<br>       <span class="hljs-comment">//  ----- (method) Wrapper&lt;number&gt;.value(): number</span><br></code></pre></td></tr></table></figure><p>As expected, this forms a <code>Wrapper&lt;number&gt;</code> and then unwraps it.</p><p>So what if you want to add a <code>map</code> method that&#39;s only available on arrays? If you add it directly to the <code>Wrapped</code> interface, it will be available on all wrapped objects, not just arrays. Perhaps a better approach is to create a specialized <code>ArrayWrapper</code> interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: T</span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T[]</span>): <span class="hljs-title">ArrayWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br></code></pre></td></tr></table></figure><p>You can verify that this gives the desired completions and errors in your editor:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI)  <span class="hljs-comment">// typing &quot;.&quot; offers &quot;value&quot; as the only completion</span><br>_(<span class="hljs-built_in">Math</span>.PI)<br>  .map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~ Property &#x27;map&#x27; does not exist on type &#x27;Wrapper&lt;number&gt;&#x27;.</span><br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])  <span class="hljs-comment">// typing &quot;.&quot; offers &quot;map&quot; and &quot;value&quot; completions</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v).value();  <span class="hljs-comment">// ok, type is string[]</span><br></code></pre></td></tr></table></figure><p>So far so good. Now let&#39;s add support for the <code>sum</code> method. You can add this to the <code>ArrayWrapper</code> interface:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  sum(): T;<br>&#125;<br></code></pre></td></tr></table></figure><p>and this will work, but it will also let you sum an array of <code>Date</code> objects to get a single <code>Date</code>, or an array of regular expressions to get a single regular expression. These should be errors.</p><p>You could try to model this out explicitly by creating more specialized interfaces:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  value(): T;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayWrapper&lt;T&gt; <span class="hljs-keyword">extends</span> Wrapper&lt;T[]&gt; &#123;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: T</span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayOfNumbersWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;number&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>&#125;<br><span class="hljs-keyword">interface</span> ArrayOfStringsWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;string&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>(<span class="hljs-params">value: <span class="hljs-built_in">string</span>[]</span>): <span class="hljs-title">ArrayOfStringsWrapper</span></span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>(<span class="hljs-params">value: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title">ArrayOfNumbersWrapper</span></span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T[]</span>): <span class="hljs-title">ArrayWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]).sum().value();  <span class="hljs-comment">// ok, type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum();<br><span class="hljs-comment">//                           ~~~</span><br><span class="hljs-comment">//     Property &#x27;sum&#x27; does not exist on type &#x27;ArrayWrapper&lt;number&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>What went wrong? When you use <code>map</code> on an <code>ArrayOfNumbersWrapper</code>, the result reverts back to <code>ArrayWrapper&lt;number&gt;</code>, which doesn&#39;t have a <code>sum</code> method. You can patch this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ArrayOfNumbersWrapper <span class="hljs-keyword">extends</span> ArrayWrapper&lt;number&gt; &#123;<br>  sum(): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>  map(mapFn: <span class="hljs-function">(<span class="hljs-params">v: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>): ArrayOfNumbersWrapper;<br>  map&lt;V&gt;(mapFn: <span class="hljs-function">(<span class="hljs-params">v: <span class="hljs-built_in">number</span></span>) =&gt;</span> V): ArrayWrapper&lt;V&gt;;<br>&#125;<br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum().value();  <span class="hljs-comment">// ok, type is number</span><br></code></pre></td></tr></table></figure><p>But this is a losing battle. There&#39;s always going to be some combination of method calls that your series of interfaces misses. This will be a frustrating experience for your users, since a TypeScript error will be only loosely correlated with a runtime error.</p><p>Taking a step back, this tracking of types through function calls is exactly what the TypeScript compiler does and is good at. It would be better to let it figure out that the wrapped type is <code>number[]</code> and provide the <code>sum</code> method in that case, rather than having to think of every possible way you could get a wrapped number array.</p><p>The trick to doing this is to specialize methods on the type of <code>this</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Wrapper&lt;T&gt; &#123;<br>  <span class="hljs-comment">// Methods available for all types:</span><br>  value(): T;<br><br>  <span class="hljs-comment">// Methods available on arrays:</span><br>  map&lt;U, V&gt;(<span class="hljs-built_in">this</span>: Wrapper&lt;U[]&gt;, mapFn: <span class="hljs-function">(<span class="hljs-params">v: U</span>) =&gt;</span> V): Wrapper&lt;V[]&gt;;<br><br>  <span class="hljs-comment">// Methods available on specific types of arrays:</span><br>  sum(<span class="hljs-built_in">this</span>: Wrapper&lt;<span class="hljs-built_in">number</span>[]&gt;): Wrapper&lt;<span class="hljs-built_in">number</span>&gt;;<br>  sum(<span class="hljs-built_in">this</span>: Wrapper&lt;<span class="hljs-built_in">string</span>[]&gt;): Wrapper&lt;<span class="hljs-built_in">string</span>&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value: T</span>): <span class="hljs-title">Wrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>;<br><br>_(<span class="hljs-built_in">Math</span>.PI).value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v * v).value();  <span class="hljs-comment">// type is string[]</span><br><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).sum().value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v * v).sum().value();  <span class="hljs-comment">// type is number</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v + v).sum().value();  <span class="hljs-comment">// type is string</span><br>_([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]).map(<span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span> + v + v).map(<span class="hljs-built_in">Number</span>).sum().value();  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>Everything works! The type checker is indeed quite good at tracking types: even trickier cases we didn&#39;t cover before, like mapping from strings to numbers and back, work as expected. What&#39;s more, this code is significantly clearer than our previous attempts. There&#39;s only a single <code>Wrapper</code> interface. As you add more and more specialized methods, the returns on this simplicity compound.</p><p>The only downside is that the error you get from calling an unavailable method is a bit cryptic:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">_(<span class="hljs-built_in">Math</span>.PI).map(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> val);<br><span class="hljs-comment">// ~~~~~~~ The &#x27;this&#x27; context of type &#x27;Wrapper&lt;number&gt;&#x27; is not assignable</span><br><span class="hljs-comment">//         to method&#x27;s &#x27;this&#x27; of type &#x27;Wrapper&lt;&#123;&#125;[]&gt;&#x27;.</span><br><span class="hljs-comment">//         Type &#x27;number&#x27; is not assignable to type &#x27;&#123;&#125;[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>But at least there&#39;s an error. Hopefully there are enough details in it to make the user realize that the <code>map</code> method only applies to arrays.</p><p>If you ever find yourself building a complex series of interfaces to model behaviors in a type declarations file, ask whether you could model the same thing by specializing on a generic type parameter. Overloading on the type of <code>this</code> will let TypeScript do the hard work for you. It&#39;ll be more accurate and a whole lot simpler!</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Specify a narrower type for <code>this</code> to specialize generic methods in interfaces.</li><li>Avoid building elaborate series of wrapper types. TypeScript is better at this!</li></ul><h3 id="Why-was-this-cut-from-the-book"><a href="#Why-was-this-cut-from-the-book" class="headerlink" title="Why was this cut from the book?"></a>Why was this cut from the book?</h3><p>This item was inspired by Daniel Rossenwasser&#39;s <a href="https://www.reddit.com/r/javascript/comments/62f531/a_typed_chain_exploring_the_limits_of_typescript/dfn411v/">comment</a> on my 2017 blog post <a href="https://medium.com/@danvdk/a-typed-chain-exploring-the-limits-of-typescript-b50153be53d8">A typed chain: exploring the limits of TypeScript</a>. The technique is perfect for typing <code>_.chain</code> and other generic wrappers. So why did I cut it? It&#39;s a complex technique to motivate, and I struggled to think of any <em>other</em> situation where it would be useful. Complex and not that useful? Sounded like a good one to drop!</p><p>I don&#39;t think the technique of specializing on <code>this</code> is widely-known, so perhaps this blog post can inspire some creative new use cases! Have you every run across this trick? Do you have a use case? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      I cut one item from Effective TypeScript during the final stages of editing. Four years later, it&#39;s time for it to see the light of day! It&#39;s a trick for specializing generic types for certain subtypes of their type parameters. This post shows how it works, why it&#39;s indispensible for wrapper types, and also explains why I cut it from the book.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The Saga of the Closure Compiler, and Why TypeScript Won</title>
    <link href="https://effectivetypescript.com/2023/09/27/closure-compiler/"/>
    <id>https://effectivetypescript.com/2023/09/27/closure-compiler/</id>
    <published>2023-09-27T20:45:00.000Z</published>
    <updated>2023-10-27T14:24:44.101Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/240px-Closure_logo.svg.png" title="Closure Tools Logo" width="100" height="100" style="float: right; margin-left: 10px;">Here&#39;s something that makes me feel old: in just six months, Gmail will celebrate its 20th anniversary. If you weren&#39;t actively developing web sites at the time, it&#39;s hard to capture just how revolutionary it was. This was a time when JavaScript was held in almost universally low regard. The idea that you could build a sophisticated web app using it was mind-boggling. But it clearly worked and it heralded the dawn of the single-page web app (SPA).</p><p>Behind this application was an exciting new tool that Google had built for creating large JavaScript applications: the <a href="https://github.com/google/closure-compiler">Closure Tools</a> (that&#39;s Closure with an &#39;s&#39;, not Clojure with a &#39;j&#39;, which is a different thing). This included the <a href="https://developers.google.com/closure/compiler/">Closure Compiler</a> (CC), a JavaScript source-to-source compiler that did type checking. Sound familiar?</p><p>Unless you&#39;ve worked on frontend at Google at some point in the past 20 years, it&#39;s unlikely that you&#39;ve ever encountered the Closure Compiler. It occupied a similar niche to TypeScript, but TypeScript has absolutely, definitively won.</p><p>Still, it&#39;s interesting to revisit CC for a few reasons:</p><ol><li>By looking at a system that made different high-level design decisions than TypeScript, we can gain a deeper appreciation of TypeScript&#39;s design.</li><li>It shows us missing features from TypeScript that it might not have even occurred to us to want.</li><li>It&#39;s an interesting case study in the history of JavaScript.</li></ol><p>In other words, the saga of the Closure Compiler gives us some perspective. TypeScript has become so ubiquitous that it&#39;s sometimes hard to imagine any other way of adding a type checker to JavaScript. The Closure Compiler shows us that the design space was larger than it looks in retrospect.</p><p>I wrote Closure-style JavaScript at Google most heavily from 2012–14. This post reflects Closure as it existed at that point. I&#39;m much less familiar with how it&#39;s evolved since then.</p><h2 id="What-is-the-Closure-Compiler"><a href="#What-is-the-Closure-Compiler" class="headerlink" title="What is the Closure Compiler?"></a>What is the Closure Compiler?</h2><p>TypeScript&#39;s motto is &quot;TypeScript is a superset of JavaScript&quot;. Closure code, on the other hand, <em>is</em> JavaScript. It doesn&#39;t add any new syntax to the language.</p><p>If you&#39;ve ever used <a href="https://www.typescriptlang.org/tsconfig#checkJs">TypeScript with <code>--checkJs</code></a>, it&#39;s a similar idea. Rather than adding types to JavaScript through new syntax, you add them via JSDoc-style comments.</p><p>Compare this TypeScript:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">a: <span class="hljs-built_in">number</span>, b: <span class="hljs-built_in">number</span></span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>to the equivalent Closurized JavaScript:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">a</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">b</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">max</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>&#125;<br></code></pre></td></tr></table></figure><p>An invalid invocation of <code>max</code> will result in an error:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;max.js&quot;<br><br>max.js:12:16: WARNING - [JSC_TYPE_MISMATCH] actual parameter 1 of max does not match formal parameter<br>found   : string<br>required: number<br>  12| console.log(max(&#39;foo&#39;, &#39;bar&#39;));<br>                      ^^^^^<br><br>max.js:12:23: WARNING - [JSC_TYPE_MISMATCH] actual parameter 2 of max does not match formal parameter<br>found   : string<br>required: number<br>  12| console.log(max(&#39;foo&#39;, &#39;bar&#39;));<br>                             ^^^^^<br><br>0 error(s), 2 warning(s), 100.0% typed<br>function max(a,b)&#123;return a&gt;b?a:b&#125;console.log(max(&quot;foo&quot;,&quot;bar&quot;));<br></code></pre></td></tr></table></figure><p>This is similar to what <code>tsc</code> does in some ways but different in others. Just like <code>tsc</code>, it reports type errors in your code. And just like <code>tsc</code>, it outputs JavaScript (the last line). At a high level, type checking and JS emit are also the two things that TypeScript does.</p><p>There are some interesting differences, too. The Closure Compiler reports that our code is &quot;100.0% typed&quot;. Using TypeScript terminology, this is a measure of how many <code>any</code> types you have. (<a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> discusses using the <a href="https://github.com/plantain-00/type-coverage">type-coverage</a> tool to get this information in Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety.)</p><p>The other interesting difference is that the output is minified. This gets us the fundamental design goal of the Closure Compiler: producing the smallest JavaScript possible.</p><h2 id="Minification-as-Design-Goal"><a href="#Minification-as-Design-Goal" class="headerlink" title="Minification as Design Goal"></a>Minification as Design Goal</h2><p>When Gmail came out back in 2004, network speeds were much, much slower than they are today. The Gmail team found that runtime JavaScript performance was almost irrelevant compared to download times (<em>Update: this isn&#39;t quite right, <a href="#updates">see below</a></em>). If you wanted to make your page load faster, you needed to make your JavaScript bundle smaller. So this is the central goal of the Closure Compiler and its &quot;advanced optimizations&quot; mode.</p><p>To see how this works, let&#39;s look at some code to fetch and process data from the network.</p><p>Here&#39;s an &quot;externs&quot; file (the CC equivalent of a type declarations file) that defines a type and declares a function:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api-externs.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typedef <span class="hljs-type">&#123;&#123;</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   foo: string,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   bar: number,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> * &#125;</span></span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> APIResponse;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@return <span class="hljs-type">&#123;APIResponse&#125;</span> </span>*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fetchData</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>Some interesting things to note here:</p><ul><li>Types are introduced via <code>@typedef</code> in a JSDoc comment. The <code>APIResponse</code> symbol exists at runtime but is not particularly useful. Just because CC is JavaScript doesn&#39;t mean that the JavaScript always makes sense.</li><li>The declaration of <code>fetchData</code> includes an empty implementation. TypeScript would use <code>declare function</code> here, but this is not JS syntax. So CC uses an empty function body.</li></ul><p>Here&#39;s some more code that fetches data and processes it:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// api.js</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@typedef <span class="hljs-type">&#123;&#123;</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   longPropertyName: string,</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> *   anotherLongName: number</span></span></span><br><span class="hljs-comment"><span class="hljs-doctag"><span class="hljs-type"> * &#125;</span></span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> ProcessedData;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;APIResponse&#125;</span> <span class="hljs-variable">data</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;ProcessedData&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processData</span>(<span class="hljs-params">data</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    longPropertyName: data.foo,<br>    anotherLongName: data.bar,<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> apiData = fetchData();<br><span class="hljs-keyword">const</span> processedData = processData(apiData);<br><span class="hljs-built_in">console</span>.log(processedData.longPropertyName, processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Because it&#39;s just JavaScript, this code can be executed directly, presumably via a <code>&lt;script&gt;</code> tag (CC predates Node.js). No build step is required and your iteration cycle is very tight.</p><p>Let&#39;s look at what happens when you compile this:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;--externs&quot; &quot;api-externs.js&quot; &quot;api.js&quot;<br><br>let ProcessedData;function processData(a)&#123;return&#123;longPropertyName:a.foo,anotherLongName:a.bar&#125;&#125;const apiData&#x3D;fetchData(),processedData&#x3D;processData(apiData);console.log(processedData.longPropertyName,processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Here&#39;s what that looks like when we unminify it:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ProcessedData;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processData</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>        longPropertyName: a.foo,<br>        anotherLongName: a.bar<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> apiData = fetchData(), processedData = processData(apiData);<br><br><span class="hljs-built_in">console</span>.log(processedData.longPropertyName, processedData.anotherLongName);<br></code></pre></td></tr></table></figure><p>Just like TypeScript, compilation here mostly consists of stripping out type information (in this case JSDoc comments).</p><p>Now look at what happens when we turn on &quot;advanced optimizations&quot;:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; google-closure-compiler &quot;--compilation_level&quot; &quot;ADVANCED&quot; &quot;--warning_level&quot; &quot;VERBOSE&quot; &quot;--externs&quot; &quot;api-externs.js&quot; &quot;api.js&quot;<br><br>var a,b&#x3D;fetchData();a&#x3D;&#123;h:b.foo,g:b.bar&#125;;console.log(a.h,a.g);<br></code></pre></td></tr></table></figure><p>The output is <em>much</em> shorter. Here&#39;s what it looks like unminified:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a, b = fetchData();<br><br>a = &#123;<br>    h: b.foo,<br>    g: b.bar<br>&#125;;<br><br><span class="hljs-built_in">console</span>.log(a.h, a.g);<br></code></pre></td></tr></table></figure><p>This is a radical transformation of our original code. In addition to mangling our variable names (<code>apiData</code> became <code>b</code>, <code>processedData</code> became <code>a</code>), the Closure Compiler has mangled property names on <code>ProcessedData</code> (<code>longPropertyName</code>→<code>h</code>, <code>anotherLongName</code>→<code>g</code>) and inlined the call to <code>processData</code>, which let it remove that function entirely.</p><p>The results are dramatic. Whereas the minified code with simple optimizations was 231 bytes, the code with advanced optimizations is only 62 bytes!</p><p>Notice that CC has preserved some symbols: the <code>fetchData</code> function and the <code>foo</code> and <code>bar</code> property names. The rule is that symbols in an &quot;externs&quot; file are externally visible and cannot be changed, whereas the symbols elsewhere are internal and can be mangled or inlined as CC sees fit.</p><p>This is fundamentally unlike anything that TypeScript does. TypeScript does not rename symbols when it emits JavaScript nor does it attempt to minify your code. Even if you run your generated JavaScript through a minifier, it won&#39;t do anything nearly this radical. It&#39;s hard (or impossible) for a minifier to know which symbols or property names are part of an external API. So mangling property names is generally unsafe. You&#39;re unlikely to get anything smaller than the 231 byte &quot;simple optimizations&quot; output with TypeScript.</p><p>These results generally hold up well after gzip compression, and in larger projects as well. I <a href="https://github.com/danvk/dygraphs/pull/267">ported a JavaScript library to Closure</a> in 2013 and shrank my bundle by 40% vs. uglifyjs.</p><p>This is great stuff! So why didn&#39;t the Closure Compiler take off?</p><h2 id="The-Problems-with-Minification-as-a-Design-Goal"><a href="#The-Problems-with-Minification-as-a-Design-Goal" class="headerlink" title="The Problems with Minification as a Design Goal"></a>The Problems with Minification as a Design Goal</h2><p>The externs file was critical to correct minification. Without it, CC would have mangled the <code>fetchData</code> function name and the <code>foo</code> and <code>bar</code> properties, too, which would have resulted in runtime errors. Omitting a symbol from an externs file would result in incorrect runtime behavior that could be extremely difficult to track down. In other words, this was a really bad developer experience (DX).</p><p>CC introduced some extralinguistic conventions to deal with this. For example, in JS (and TS) there&#39;s no distinction between using dot notation and square braces to access a property on an object:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> a = obj.property;<br><span class="hljs-keyword">const</span> b = obj[<span class="hljs-string">&#x27;property&#x27;</span>];<br><span class="hljs-built_in">console</span>.log(a, b);  <span class="hljs-comment">// exact same</span><br></code></pre></td></tr></table></figure><p>This is not true with the Closure Compiler. Its convention is that quoted property access is preserved whereas dotted can be mangled. Here&#39;s how that code comes through the minifier with advanced optimizations:</p><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(obj.g,obj.property);<br></code></pre></td></tr></table></figure><p>Note how the property names have diverged. In other words, while Closurized JavaScript is just JavaScript, it also kind of isn&#39;t.</p><p>There&#39;s another big problem with advanced optimizations: in order to consistently mangle a property name, CC needs to have access to all the source code that might use it. For this to be maximally effective, all the code you import must also be written with the Closure Compiler in mind, as must all the code that <em>that</em> code imports, etc.</p><p>In the context of npm in 2023, this would be impossible. In most projects, at least 90+% of the lines of code are third-party. For this style of minification to be effective, all of that code would have to be written with the Closure Compiler in mind and compiled by it as a unit.</p><p>On the other hand at Google in 2004, or 2012, or perhaps even today, that <em>is</em> quite realistic. At huge companies, the first- to third-party code ratio tends to be flipped. Using third-party code is more painful because there are legal and security concerns that come with it, as well as a loss of control. TypeScript&#39;s <a href="https://yarnpkg.com/package?name=typescript&file=%2Fpackage.json">zero runtime dependencies</a> are a good example of this.</p><p>All of Google&#39;s JavaScript was written with the Closure Compiler in mind and the vast majority of it is first-party. So advanced optimizations works beautifully. But the rest of the JS world doesn&#39;t operate that way. As soon as you pull in any dependencies like React or Lodash that aren&#39;t written with Closure Compiler in mind, it starts to lose its value.</p><p>Contrast this with TypeScript. It only needs to know about the <em>types</em> of existing libraries. This is all that&#39;s needed for type checking. The DefinitelyTyped project has been a monumental undertaking but it does mean that, generally speaking, you can get TypeScript types for almost any JS library. (There&#39;s a similar, though much smaller, set of <a href="https://github.com/google/closure-compiler/blob/929ba03a950b1dfcd60762f954e4833f433cc1d4/contrib/externs/jquery-1.12_and_2.2.js#L184">externs</a> to get type checking for popular JS libraries for the Closure Compiler.)</p><p>Stating it more directly: advanced optimizations requires that the compiler understand a library&#39;s implementation, not just its types, and that&#39;s simply infeasible given the enormous diversity of the JavaScript ecosystem.</p><!-- Mention my desire to use D3? --><h2 id="Timing-Is-Everything"><a href="#Timing-Is-Everything" class="headerlink" title="Timing Is Everything"></a>Timing Is Everything</h2><img src="https://effectivetypescript.com/images/closure-definitive-guide.jpg" title="Cover of Closure: The Definitive Guide (2010)" width="133" height="174" style="float: right; margin-left: 10px;"><p>Google developed Closure c. 2004 but it wasn&#39;t open sourced until <a href="http://googlecode.blogspot.com/2009/11/introducing-closure-tools.html">late 2009</a>. An O&#39;Reilly book on it, <a href="https://www.amazon.com/Closure-Definitive-Guide-Google-JavaScript/dp/1449381871">Closure: The Definitive Guide</a>, came out in 2010.</p><p>In retrospect this timing was terrible. In 2010, JavaScript was just entering its period of maximum churn. <a href="https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742"><em>JavaScript: The Good Parts</em></a> came out in 2008 and ES5 codified many of its recommendations in a new &quot;strict&quot; mode in 2009. Node.js was first released in 2009 and npm followed hot on its heels in 2010, creating the ecosystem of JavaScript packages we know today. npm grew significantly more powerful and useful when <a href="https://browserify.org/">browserify</a> made it applicable to client-side code starting in 2011.</p><p>And finally, <a href="https://coffeescript.org/">CoffeeScript</a> was released in 2010. It normalized the idea of compiling an &quot;improved&quot; JavaScript down to regular JavaScript, as well having a build step. All of these influenced the direction of JavaScript, with ES2015 bringing some of the best elements of CoffeeScript into the language itself.</p><p>The Closure Compiler was developed in the era when JavaScript was a &quot;bad&quot; language that was to be avoided. CC itself is implemented in Java, which made it harder to integrate into an all-JS toolchain. And it attempted to add missing parts to JavaScript. Since it couldn&#39;t add new syntax, it used special functions: <code>goog.provide</code> and <code>goog.require</code> provided a module system and <code>goog.inherits</code> <a href="https://developers.google.com/closure/library/docs/introduction#oop">smoothed out the process</a> of creating class hierarchies. These were real JavaScript functions that did something at runtime. If memory serves, <code>goog.require</code> might inject a <code>&lt;script&gt;</code> tag!</p><p>There were a few problems with this. One was that all the <code>goog</code> functions reinforced the idea that this was a tool primarily built for Google. Putting company names in your packages is common in Java, so presumably it felt natural for the Closure developers. But it&#39;s not in JavaScript. We just <code>import &#39;react&#39;</code>, not &quot;facebook/react&quot;.</p><p>Second, it made it awkward when JavaScript itself gained a module system and <code>class</code> keyword. TypeScript faced some of these problems in its early days, too. It used to have its own module system and class system, but in the interests of ecosystem coherence it deprecated them in favor of the native solutions. TypeScript now lets JavaScript be JavaScript and innovates only in the type system.</p><p>This transition happened early in TypeScript&#39;s history, but late in the Closure Compiler&#39;s. Presumably adaptation was harder.</p><h2 id="Why-TypeScript-won"><a href="#Why-TypeScript-won" class="headerlink" title="Why TypeScript won"></a>Why TypeScript won</h2><p>TypeScript came along at a better time and has been able to adapt to the changes in JavaScript and its ecosystem over the past decade. It&#39;s self-hosted (<code>tsc</code> is written in TypeScript) and distributed with npm.</p><p>TypeScript also won by focusing more on developer tooling. The Closure Compiler is an offline system: you run a command, it checks your program for errors, then you edit and repeat. I&#39;m not aware of any standard Closure language service. There&#39;s no equivalent of inspecting a symbol in your editor to see what CC thinks its type is. TypeScript, on the other hand, places as much emphasis on <code>tsserver</code> as <code>tsc</code>. Especially with Visual Studio Code, which is written in TypeScript and came out in 2015, TypeScript is a joy to use. TypeScript uses types to make you more productive whereas Closure used them to point out your mistakes. No wonder developers preferred TypeScript!</p><p>(Google engineers are no exception to this. In the past decade they&#39;ve <a href="https://neugierig.org/software/blog/2018/09/typescript-at-google.html">adopted TypeScript</a> and migrated to it en masse. You can read about one team&#39;s experience <a href="https://developer.chrome.com/blog/migrating-to-typescript/">porting Chrome Devtools from Closure to TypeScript</a>).</p><p>TypeScript did a better job of engaging the JavaScript community. TypeScript is developed and planned in the open on GitHub. They respond to bug reports from anyone and treat non-Microsoft users as important customers. The Closure Tools, on the other hand, were very much an open source release of an internal Google tool. Google was always the primary consumer and external users were mostly on their own. The <code>goog</code> namespacing reinforced this.</p><p>Closure&#39;s idea of &quot;it&#39;s just JavaScript&quot; was appealing because it let you avoid a build step. This remains appealing in 2023: some TypeScript users still prefer to use JSDoc-style type annotations and <code>--checkJs</code>. But using JSDoc for all types is awkward and noisy. Ergonomics do matter and TypeScript&#39;s are undeniably better.</p><p>Finally, TypeScript&#39;s central idea of &quot;JavaScript + Types&quot; has held up better than the Closure Tools&#39; idea of &quot;minification&quot; and &quot;it&#39;s just JavaScript&quot;. While shaving bytes off your bundle was all the rage in 2008, our connections are much faster now and, while bundle size still matters, it is not as critical as it was back then. Closure forced a uniform system on you and all your dependencies in order to achieve extreme minification. We&#39;ve given up that goal in exchange for more flexibility.</p><p>There&#39;s a general principle here. I&#39;m reminded of Michael Feathers&#39;s 2009 blog post <a href="https://michaelfeathers.silvrback.com/10-papers-every-developer-should-read-at-least-twice">10 Papers Every Developer Should Read at Least Twice</a> which discusses D.L. Parnas&#39;s classic 1972 paper &quot;On the criteria to be used in decomposing systems into modules&quot;:</p><blockquote><p>Another thing I really like in the paper is his comment on the KWIC system which he used as an example. He mentioned that it would take a good programmer a week or two to code. Today, it would take practically no time at all. Thumbs up for improved skills and better tools. We have made progress.</p></blockquote><p>The KWIC system basically sorts a text file. So are we correct to laud our progress as software developers? This would be a one-liner today:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">console</span>.log(<br>  fs.readFileSync(<span class="hljs-string">&#x27;input.txt&#x27;</span>)<br>  .split(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>  .toSorted(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.localeCompare(b))<br>  .join(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>But think about what makes this possible:</p><ul><li>We&#39;re assuming that the entire file fits in memory, which almost certainly would not have been true in 1972.</li><li>We&#39;re using a garbage collected language, which would have been a rarity back then.</li><li>We have an enormous library at our fingertips via node built-ins and npm.</li><li>We have great text editors and operating systems.</li><li>We have the web and StackOverflow: no need to consult a reference manual!</li></ul><p>All of these things are thanks to advances in hardware. The hardware people give us extra transistors and the software people take most of those for ourselves to get a nicer development process. So it is with faster network speeds and the Closure Compiler. We&#39;ve taken back some of that bandwidth in exchange for a more flexible development process and ecosystem.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>There were discussions of <a href="https://github.com/microsoft/TypeScript/issues/8">adding minification to TypeScript</a> in the early days but now optimized output is an explicit <a href="https://github.com/microsoft/TypeScript/wiki/TypeScript-Design-Goals#non-goals">non-goal</a> for the language. If you&#39;ve ever thought that type-driven minification would be a beautiful thing, the Closure Compiler is a fascinating data point. It can be tremendously effective, but it also comes at an enormous cost to the ecosystem.</p><p>The Closure Compiler as a standalone external tool seems mostly dead (the <a href="https://closure-compiler.appspot.com/home">closure playground</a> is badly broken and says &quot;Copyright 2009&quot;!). But it still lives on at Google. Since they&#39;ve adopted TypeScript, they can use the Closure Compiler for just what it does best: minification. To make this work, Google has built a tool, <a href="https://github.com/angular/tsickle">tsickle</a>, that makes TypeScript produce Closurized JavaScript. True to form, this tool is open source but pretty inscrutable to an outsider. It may be used by Angular but I couldn&#39;t tell.</p><p>Hopefully this was an interesting lesson in JavaScript history! The Closure Compiler represents an alternative path that the JavaScript ecosystem could have taken, with different principles and different tradeoffs.</p><p><a name="updates"></a><em>There&#39;s a <a href="https://news.ycombinator.com/item?id=37686633#37697339">lively discussion</a> of this article on Hacker News. In particular Paul Buchheit (the creator of Gmail!) <a href="https://news.ycombinator.com/item?id=37699258">points out</a> that runtime performance was very much a goal of the Closure Compiler and inlining/dead code removal was a way to achieve this. It&#39;s hard to get back in the pre-JIT IE6 mindset where every getter comes with a cost! I don&#39;t think this changes the conclusions of the article. Also, the Closure Compiler is not the <a href="https://en.wikipedia.org/wiki/Google_Web_Toolkit">Google Web Toolkit</a> (GWT).</em></p>]]></content>
    
    <summary type="html">
    
      This post looks at the Closure Compiler, Google&#39;s tool from the mid-2000s for adding types to JavaScript. It looks at how its focus on minification led to very different design choices than TypeScript, and how this and a few other factors led to TypeScript becoming the ubiquitous solution for JavaScript + types. The Closure Compiler represents an alternative path that JavaScript could have taken, and it gives us perspective on TypeScript as it exists today.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>TypeScript and SQL: Six Ways to Bridge the Divide</title>
    <link href="https://effectivetypescript.com/2023/08/29/sql/"/>
    <id>https://effectivetypescript.com/2023/08/29/sql/</id>
    <published>2023-08-29T21:30:00.000Z</published>
    <updated>2023-09-27T20:31:36.483Z</updated>
    
    <content type="html"><![CDATA[<p>If you develop server code with TypeScript, you&#39;ll inevitably come up against the question of how to interact with your database. There&#39;s lots of type information in your database (the structure of the tables) and it&#39;s not immediately clear how to share that type information between the DB and TypeScript.</p><p>Over many years of working with TypeScript and <a href="https://www.postgresql.org/">Postgres</a>, one of the most popular open source databases, I&#39;ve developed some opinions and hard-earned knowledge. This post lays out the decision tree you face as you work with TypeScript and a database and presents my preferred techniques.</p><p>If you&#39;d like to watch in video form, I gave a <a href="https://portal.gitnation.org/contents/typescript-and-the-database-who-owns-the-types">30 minute talk on this</a> at last year&#39;s TS Congress. Watching it again 16 months later, I have to say that it&#39;s pretty good! It goes into more detail on each option than this post does. You can follow along with the <a href="https://docs.google.com/presentation/d/1OsLdyLMtJ79fvuylYgmjlCrPNS_NK9xIAXKqoAyW3SI/edit#slide=id.p">slides</a> and <a href="https://github.com/danvk/ts-sql-tscongress2022">sample repo</a> if you like.</p><p><a href="https://portal.gitnation.org/contents/typescript-and-the-database-who-owns-the-types"><img src="https://effectivetypescript.com/images/tscongress-talk.jpg" alt="Dan speaking at TS Congress April 22, 2022" style="max-height: 458px; max-width: 100%"></a></p><p>The DB Schema looks something like this:</p><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> book(<br>  id uuid <span class="hljs-keyword">DEFAULT</span> gen_random_uuid() <span class="hljs-keyword">PRIMARY</span> KEY,<br>  title <span class="hljs-type">varchar</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  publication_year <span class="hljs-type">integer</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>);<br></code></pre></td></tr></table></figure><h2 id="Raw-SQL-Hand-coded-types"><a href="#Raw-SQL-Hand-coded-types" class="headerlink" title="Raw SQL + Hand-coded types"></a>Raw SQL + Hand-coded types</h2><p>Say you write a query to fetch all the books in your database using <a href="https://node-postgres.com/">node-postgres</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: any[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.year);<br>&#125;<br></code></pre></td></tr></table></figure><p>This code has a bug: it should be <code>book.publication_year</code>, not <code>book.year</code>. But because the the query returns an <code>any</code> type, TypeScript hasn&#39;t been able to flag it. No problem, we&#39;ll just write out an <code>interface</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Book &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query&lt;Book&gt;(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.year);<br>  <span class="hljs-comment">//                           ~~~~ Property &#x27;year&#x27; does not exist on type &#x27;Book&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Voila! TypeScript flags the error and we can easily fix it by changing <code>year</code> to <code>publication_year</code>.</p><p>This <em>is</em> a big improvement over untyped code, and this tends to be the approach that developers fall into by default if they don&#39;t step back back and think about the problem of TypeScript and SQL.</p><p>But this approach also has a big problem: there&#39;s no <a href="https://en.wikipedia.org/wiki/Single_source_of_truth">single source of truth</a>. If the database changes (say because of a migration) then our TypeScript types won&#39;t update. And nothing ensures that they types are accurate to begin with.</p><p>On the other hand, this approach has some strengths: it doesn&#39;t introduce any abstractions (you&#39;re just writing TypeScript and SQL) and it doesn&#39;t introduce any sort of build step into your project.</p><p><strong>Pros and Cons of Raw SQL and Hand-Coded Types</strong></p><ul><li>Pros<ul><li>Zero abstraction</li><li>You do get some type safety</li></ul></li><li>Cons<ul><li>Repetition between DB + TS</li><li>Types don&#39;t stay in sync:</li><li>No Single Source of Truth</li></ul></li></ul><h2 id="ORMs-TypeORM-Sequelize-Waterline-Prisma-…"><a href="#ORMs-TypeORM-Sequelize-Waterline-Prisma-…" class="headerlink" title="ORMs (TypeORM, Sequelize, Waterline, Prisma, …)"></a>ORMs (TypeORM, Sequelize, Waterline, Prisma, …)</h2><p>So you want a single source of truth. The first big question you have to ask is &quot;where is the source of truth?&quot; Since we&#39;re dealing with TypeScript and SQL, the two obvious choices are… TypeScript and SQL. If you want to make TypeScript your source of truth, then you&#39;ll be using an <a href="https://stackoverflow.com/questions/1279613/what-is-an-orm-how-does-it-work-and-how-should-i-use-one">ORM</a>, aka an Object-Relational Mapper.</p><p>Here&#39;s how we might define a <code>Book</code> table using <a href="https://typeorm.io/">TypeORM</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Entity, PrimaryGeneratedColumn, Column &#125; form <span class="hljs-string">&#x27;typeorm&#x27;</span>;<br><br><span class="hljs-meta">@Entity</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br>  <span class="hljs-meta">@PrimaryGeneratedColumn</span>()<br>  id!: <span class="hljs-built_in">number</span>;<br><br>  <span class="hljs-meta">@Column</span>()<br>  title!: <span class="hljs-built_in">string</span>;<br><br>  <span class="hljs-meta">@Column</span>(<span class="hljs-string">&#x27;integer&#x27;</span>, &#123;<span class="hljs-attr">nullable</span>: <span class="hljs-literal">true</span>&#125;)<br>  publication_year!: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeORM handles the messy business of converting this class to SQL for us. And now we can use the <code>Book</code> class in our code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> entityManager.find(Book);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.publication_year);<br>&#125;<br></code></pre></td></tr></table></figure><p>And we have types! There&#39;s a single source of truth. Another nice property of ORMs is that they can often generate migrations for you, so that you don&#39;t have to write the SQL out by hand.</p><p>On the downside, ORMs are the classic example of a <a href="https://en.wikipedia.org/wiki/Leaky_abstraction">&quot;leaky abstraction&quot;</a>. The theory with an ORM is that you can treat the database as an implementation detail and you can just work in TypeScript. But in practice, that doesn&#39;t really work. To use an ORM effectively, you need to know SQL, you need to know TypeScript, and you need to know how to use the ORM. If you want to fine tune the performance of a query, say, you&#39;ll wind up working with your ORM to try to produce a really specific SQL query, which is just adding overhead over writing the SQL query directly. And if you work in an environment where there are multiple users of your database, perhaps working with other languages, then they&#39;ll feel like second class citizens since the database certainly won&#39;t be an implementation detail for them.</p><p>Using an ORM <a href="https://www.reddit.com/r/typescript/comments/jcw28f/typeorm_sucks_something_i_wanted_to_talk_about/">won&#39;t make you popular</a> on Hacker News, but they are undeniably popular. You probably already know how you feel about them. Personally I&#39;m not a fan, but they are ubiquitous and you&#39;ll eventually find yourself working on a project that uses one.</p><p><strong>Pros and Cons of ORMs</strong></p><ul><li>Pros<ul><li>Keep your types &amp; DB in sync: single source of truth!</li><li>Generate migrations for you</li><li>Low boilerplate for simple queries</li><li>ORMs are undeniably popular</li></ul></li><li>Cons<ul><li>The classic &quot;leaky abstraction&quot;: You need to know SQL, TypeScript, <em>and</em> your ORM</li><li>Performance is confusing</li><li>They make other users of your DB second-class citizens</li><li>Lots more churn in ORMs than in databases</li></ul></li></ul><h2 id="Schema-Generator-e-g-pg-to-ts"><a href="#Schema-Generator-e-g-pg-to-ts" class="headerlink" title="Schema Generator (e.g. pg-to-ts)"></a>Schema Generator (e.g. pg-to-ts)</h2><p>So what if you&#39;re not going to use an ORM? Then your database will be the source of truth. But it&#39;s undeniably useful to have a TypeScript version of your database schema. So you can generate TypeScript from your live database. A tool that does this is called a Schema Generator, and they&#39;re an essential part of any system that uses the database as the source of truth.</p><p>The granddaddy in this space is <a href="https://github.com/PSYT/schemats">SchemaTS</a>, which got a lot of GitHub stars but was abandoned in 2018. So lots of people forked it. One popular one was <a href="https://github.com/SweetIQ/schemats">PyST/SchemaTS</a>, but that was abandoned in 2020. I needed to add some Postgres-specific features so I forked that one, updated it and re-released it as <a href="https://github.com/danvk/pg-to-ts">pg-to-ts</a>. Give it a star! 😊</p><p>The idea with pg-to-ts (or any other Schema Generator) is that you point it to your live database and it outputs a <code>dbschema.ts</code> file:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ npx pg-to-ts generate -c <span class="hljs-string">&#x27;postgres://dbhost/database&#x27;</span> --output dbschema.ts<br></code></pre></td></tr></table></figure><p>Here&#39;s what the <code>dbschema.ts</code> file looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Table book</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Book &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> BookInput &#123;<br>  id?: <span class="hljs-built_in">string</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>  publication_year?: <span class="hljs-built_in">number</span> | <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>For each table in your database you get two types: one for a complete row (i.e. the result of a <code>SELECT</code> statement) and one with just the properties you need to insert a new row (note the optional fields).</p><p>You can use this to adapt the &quot;Raw SQL + Hand-coded types&quot; example code:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Book &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> dbPool.query&lt;Book&gt;(<span class="hljs-string">`SELECT * FROM book`</span>);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> book <span class="hljs-keyword">of</span> books) &#123;<br>  <span class="hljs-built_in">console</span>.log(book.title, book.publication_year);<br>&#125;<br></code></pre></td></tr></table></figure><p>This is exactly the same as the hand-coded version, except that we don&#39;t have to write the types by hand. Superficially this doesn&#39;t seem like a big change, but it&#39;s actually a huge win! In practice you&#39;d generate <code>dbschema.ts</code> on your CI to make sure it stays in sync with the database.</p><p>This does add a build step. But schemas tend to change less frequently than code, so in practice most changes don&#39;t require this step.</p><p>Another issue is that we still had to manually add the <code>Book</code> annotation to our query to get the desired type out. For a more complex query, you may wind up writing duplicating logic with complicated <code>Pick</code> expressions or new <code>interfaces</code> based on your <code>dbschema</code>.</p><p>Schema Generators are a key building block for other tools (more on that below), so if you&#39;re not using an ORM then you should absolutely use a Schema Generator.</p><p><strong>Pros and Cons of Schema Generators</strong></p><ul><li>Pros<ul><li>Keep your types &amp; DB in sync</li><li>Key building block (more on this later!)</li></ul></li><li>Cons<ul><li>Add a build step</li><li>Still have to manually add types to queries</li><li>Some DB types are hard to model in TS (e.g. integers)</li></ul></li></ul><h2 id="Query-Builder-e-g-knex-js"><a href="#Query-Builder-e-g-knex-js" class="headerlink" title="Query Builder (e.g. knex.js)"></a>Query Builder (e.g. knex.js)</h2><p>The next question to ask is whether you want to write raw SQL or use a query builder. Probably the most popular query builder for TypeScript is <a href="https://knexjs.org/">knex.js</a>. Here&#39;s what it looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; knex &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;knex&#x27;</span>;<br><span class="hljs-keyword">const</span> knexDb = knex(&#123; <span class="hljs-attr">client</span>: <span class="hljs-string">&#x27;pg&#x27;</span>, <span class="hljs-attr">connection</span>: <span class="hljs-string">&#x27;postgres://...&#x27;</span> &#125;);<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> knexDb(<span class="hljs-string">&#x27;book&#x27;</span>).select();<br><span class="hljs-comment">//    ^? const books: Book[]</span><br></code></pre></td></tr></table></figure><p>A type! How does this work? Assuming you&#39;ve run <code>pg-to-ts</code> to generate a schema, you can tell Knex about it using a type declaration:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; knex &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;knex&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Book &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><span class="hljs-keyword">declare</span> <span class="hljs-built_in">module</span> <span class="hljs-string">&#x27;knex/types/tables&#x27;</span> &#123;<br>  <span class="hljs-keyword">interface</span> Tables &#123;<br>    book: Book;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>This is the bridge between the Schema Generator and the Query Builder and it powers the type generation.</p><p>It&#39;s great that we get accurate types without having to write them out ourselves. You can generate much more complex queries using Knex.js and generally it will do a good job of inferring accurate types.</p><p>So what&#39;s the downside? Just as with ORMs, Query Builders are a classic example of a leaky abstraction. As your queries get more and more complicated, it becomes less clear that writing them with a query builder is any simpler than it would be to write them as raw SQL.</p><p><strong>Pros and Cons of Query Builders</strong></p><ul><li>Pros<ul><li>With schema generation, they get you accurate types for your queries.</li><li>Less context-switching between languages.</li><li>No added build step (beyond schema generation)</li></ul></li><li>Cons<ul><li>Another &quot;leaky abstraction&quot;: You need to know TS, SQL, <em>and</em> your Query Builder</li></ul></li></ul><h2 id="SQL-→-TS-e-g-PgTyped"><a href="#SQL-→-TS-e-g-PgTyped" class="headerlink" title="SQL → TS (e.g. PgTyped)"></a>SQL → TS (e.g. PgTyped)</h2><p>If you&#39;re not going to use a Query Builder, then you have another option: a tool reads your raw SQL queries, tests them against your live database and outputs types. This like a Schema Generator, but for your individual queries, not your database as a whole. The best example of this is <a href="https://github.com/adelsz/pgtyped">PgTyped</a>.</p><p>Here&#39;s what a query looks like with PgTyped:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; sql &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@pgtyped/query&#x27;</span>;<br><br><span class="hljs-keyword">const</span> getBooks = sql<span class="hljs-string">`SELECT * FROM book;`</span>;<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks.run(<span class="hljs-comment">/* query parameters */</span> <span class="hljs-literal">undefined</span>, dbPool);<br><span class="hljs-comment">//    ^? const books: any</span><br></code></pre></td></tr></table></figure><p>What? <code>any</code>!? What&#39;s the point of that?</p><p>With PgTyped you have another step: you need to run the <code>pgtyped</code> command to get types for your query:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ yarn run pgtyped -c config.json<br>Processing src/index.ts<br>Saved 1 query to src/index.types.ts<br></code></pre></td></tr></table></figure><p>PgTyped read our tagged SQL query, inspected it against our live database (configured in <code>config.json</code>) and produced a types file:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** Types generated for queries found in &quot;src/index.ts&quot; */</span><br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; parameters type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">type</span> IGetBooksParams = <span class="hljs-built_in">void</span>;<br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; return type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IGetBooksResult &#123;<br>  id: <span class="hljs-built_in">string</span>;<br>  publication_year: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;<br>  title: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-comment">/** &#x27;GetBooks&#x27; query type */</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> IGetBooksQuery &#123;<br>  params: IGetBooksParams;<br>  result: IGetBooksResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>PgTyped has produced two <code>interface</code>s: one for query parameters (we have none, so this is <code>void</code>) and one for the results of our query. The third <code>interface</code> bundles these up for us. We can plug these back into our original code to get types:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; sql &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@pgtyped/query&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; IGetBooksQuery &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./index.types&#x27;</span>;<br><br><span class="hljs-keyword">const</span> getBooks = sql&lt;IGetBooksQuery&gt;<span class="hljs-string">`SELECT * FROM book;`</span>;<br><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks.run(<span class="hljs-comment">/* query parameters */</span> <span class="hljs-literal">undefined</span>, dbPool);<br><span class="hljs-comment">//    ^? const books: IGetBooksResult[]</span><br></code></pre></td></tr></table></figure><p>Since it runs against your live database, PgTyped doesn&#39;t require a DB Schema. But with TypeScript&#39;s structural typing system, the <code>IGetBooksResult</code> interface is compatible with <code>Book</code>, so you can freely interchange them. You may wish to wrap your query to consistently use the DB Schema type.</p><p>PgTyped shines with more complex queries. You can use any features of PostgreSQL and PgTyped will follow along. There&#39;s no abstraction here, you&#39;re just writing SQL.</p><p>What are the downsides? As with other non-ORM tools, PgTyped does add a build step that you&#39;ll need to run as part of your development flow and on your CI (to make sure your types and queries stay in sync). Sometimes the types you get back aren&#39;t perfect, there are some <a href="https://github.com/adelsz/pgtyped/issues/375">issues around nullability</a>. While the types are usually accurate, it can feel a little &quot;duck typey&quot; to have so many distinct but compatible types floating around. And finally, it&#39;s a lot of ceremony for simple queries like <code>SELECT * FROM book</code>.</p><p><strong>Pros and Cons of PgTyped</strong></p><ul><li>Pros<ul><li>You get types for your queries, however complex they are</li><li>Zero abstraction: you&#39;re just writing SQL</li></ul></li><li>Cons<ul><li>Not all types can be accurately derived this way (nullability issues)</li><li>Adds a build step</li><li>A little &quot;ducky&quot; w/o dbschema</li><li>Lots of fuss for simple queries</li></ul></li></ul><h2 id="SQL→TS-a-smidge-of-query-building-zapatos-databases-PgTyped-crudely-typed"><a href="#SQL→TS-a-smidge-of-query-building-zapatos-databases-PgTyped-crudely-typed" class="headerlink" title="SQL→TS + a smidge of query building (zapatos, @databases, PgTyped + crudely-typed)"></a>SQL→TS + a smidge of query building (zapatos, @databases, PgTyped + crudely-typed)</h2><p>Finally, we get to my preferred approach! A Schema Generator produces the best-looking types and a Query Builder works with that schema. PgTyped excels at complex queries where you&#39;d rather write raw SQL. So the idea here is to use a minimal, TypeScript-first query builder that won&#39;t tempt you into writing complex queries with it because it doesn&#39;t support them. You should be using PgTyped for those, anyway.</p><p>Enter: <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>!</p><p>crudely-typed (which I built at my <a href="https://www.sidewalklabs.com/">last job</a>) is a query builder that generates only relatively simple queries with a focus on working with your dbschema to get perfect types. Here&#39;s what it looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;TypedSQL&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crudely-typed&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123;tables&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;  <span class="hljs-comment">// &lt;-- output of pg-to-ts</span><br><br><span class="hljs-keyword">const</span> typedSql = <span class="hljs-keyword">new</span> TypedSQL(tables);<br><span class="hljs-keyword">const</span> booksTable = typedSql.table(<span class="hljs-string">&#x27;book&#x27;</span>);<br><span class="hljs-keyword">const</span> getBooks = booksTable.select();<br><span class="hljs-comment">//    ^? const getBooks: (db: Queryable) =&gt; Promise&lt;Book[]&gt;</span><br><span class="hljs-keyword">const</span> books = <span class="hljs-keyword">await</span> getBooks(dbPool);<br><span class="hljs-comment">//    ^? const books: Book[]</span><br></code></pre></td></tr></table></figure><p>You still have to regenerate <code>dbschema.ts</code> when your DB Schema changes, but there&#39;s no build step or overhead for the simple queries that crudely-typed supports. These include the basic CRUD (Create, Read, Update, Delete) queries as well as some very minimal support for 1-1 joins. Because it knows about your DB Schema, you&#39;ll get nice-looking type signatures on your functions:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> updateBook = bookTable.updateByPrimaryKey();<br><span class="hljs-comment">//    ^? const updateBook:</span><br><span class="hljs-comment">//          (db: Queryable, where: &#123; id: string; &#125;, update: Partial&lt;Book&gt;)</span><br><span class="hljs-comment">//          =&gt; Promise&lt;Book | null&gt;</span><br></code></pre></td></tr></table></figure><p>In practice this covers 90+% of the SQL queries that you run in most applications. For the remaining 10% you can fall back to using PgTyped. The net effect is that you have a single source of truth (your database) and you get accurate TypeScript types with relatively minimal fuss.</p><p>While I&#39;ve never personally used them, I believe <a href="https://jawj.github.io/zapatos/">zapatos</a> and <a href="https://www.atdatabases.org/">@databases</a> follow a similar approach.</p><p><strong>Pros and Cons of hybrid Schema Generator + Query Builder / PgTyped</strong></p><ul><li>Pros<ul><li>Zero abstraction/overhead for complex SQL queries (PgTyped)</li><li>Minimum fuss, dbschema types for simple queries (crudely-typed)</li></ul></li><li>Cons<ul><li>Adds a build step</li><li>You might be tempted to put logic in JS instead of SQL, i.e. run 10 crudely-typed queries instead of one SQL query.</li></ul></li></ul><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Here&#39;s the final decision tree from my <a href="https://docs.google.com/presentation/d/1OsLdyLMtJ79fvuylYgmjlCrPNS_NK9xIAXKqoAyW3SI/edit#slide=id.p">slides</a>:</p><img src="https://effectivetypescript.com/images/ts-sql-decision-tree.png" alt="Decision Tree for using TypeScript and SQL" style="max-height: 300px; max-width: 100%"><p>There are no perfect choices here. Depending on how you feel about ORMs and Query Builders, you&#39;ll wind up in a different place. Regardless, the key thing is to make a conscious, informed decision about how you want to combine TypeScript and SQL. However you do it, try to have a single source of truth.</p><p>The final, hybrid option is where I&#39;ve wound up after years of dealing with this problem. How do you like to work with databases in TypeScript? Let me know in the comments!</p>]]></content>
    
    <summary type="html">
    
      If you develop server code with TypeScript, you&#39;ll inevitably come up against the question of how to interact with your database. There&#39;s lots of type information in your database (the structure of the tables) and it&#39;s not immediately clear how to share that type information between the DB and TypeScript.

This post and its accompanying video present six ways to solve this problem and offer some advice gleaned from years of experience combining Postgres and TypeScript.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Recommendation Update: ✂️ Use knip to detect dead code and types</title>
    <link href="https://effectivetypescript.com/2023/07/29/knip/"/>
    <id>https://effectivetypescript.com/2023/07/29/knip/</id>
    <published>2023-07-29T14:20:00.000Z</published>
    <updated>2023-07-29T14:23:45.043Z</updated>
    
    <content type="html"><![CDATA[<p>TL;DR: Use <a href="https://github.com/nadeesha/ts-prune">ts-prune</a> is in maintenance mode. Use <a href="https://github.com/webpro/knip">knip</a> to find dead code instead. It&#39;s great!</p><span id="more"></span><p>Three years ago I <a href="https://effectivetypescript.com/2020/10/20/tsprune/">recommended</a> using <code>--noUnusedLocals</code> and <a href="https://github.com/nadeesha/ts-prune"><code>ts-prune</code></a> to find dead code and dead types in your projects. <code>ts-prune</code> worked well enough, but it&#39;s now in maintenance mode and won&#39;t be receiving updates. This is a fine decision and it&#39;s the responsible thing to do when you no longer plan to maintain an open source project (I sometimes <a href="https://github.com/danvk/dygraphs/issues/727">struggle</a> with this!).</p><p>While <code>ts-prune</code> was effective at its core job, it always had a few shortcomings: it couldn&#39;t detect <a href="https://github.com/nadeesha/ts-prune/issues/96">unused dependencies</a> or <a href="https://github.com/nadeesha/ts-prune/issues/97">mutually recursive dead code</a>. It also made no attempts to understand whether your test code was alive or dead. So when I noticed that <a href="https://www.joshuakgoldberg.com/">Josh&#39;s</a> <a href="https://github.com/JoshuaKGoldberg/template-typescript-node-package">template-typescript-node-package</a> was using a new tool called <a href="https://github.com/webpro/knip">Knip</a>, I was intrigued. Could this be the dead code removal tool of my dreams?</p><p>Basically, yes! <code>knip</code> uses the same sort of mark-and-sweep algorithm as <code>ts-prune</code> to find dead code (see my <a href="https://effectivetypescript.com/2020/10/20/tsprune/">previous post</a> for why this is what you want). But it&#39;s much more ambitious in the sorts of issues it tries to find:</p><ul><li>It will report unused <code>dependencies</code> and even <code>devDependencies</code> from your <code>package.json</code>. Removing these can be a huge win since it reduces your package size and eases the burden of keeping up to date with the latest versions.</li><li>It will report files that are never imported by non-test code.</li><li>It will report missing dependencies. This can happen if you depend on <code>A</code> which depends on <code>B</code>. You import something from <code>B</code> and it works, but you didn&#39;t list it in your dependencies. If you ever remove the dependency on <code>A</code>, this will be a problem. Best to depend on <code>B</code> directly if you use it directly.</li><li>It will report duplicate exports.</li><li>It will report unused class members and enum members.</li></ul><p>Because of the enormous diversity of JS/TS libraries and tools, you&#39;d expect that explaining your project setup to a tool like <code>knip</code> would involve writing a complicated configuration file. But that&#39;s usually not the case. knip&#39;s models this enormous diversity with an enormous collection of <a href="https://github.com/webpro/knip#plugins">plugins</a>. Chances are that your test runner and framework are already on the list.</p><p>Give <code>knip</code> a try! You might be surprised at the dead code you&#39;ve accumulated. You can use <a href="https://github.com/refstudio/refstudio/pull/225">this PR</a> as a template for setting it up in a project. Once you get down to zero errors, add <code>knip</code> to your CI to ensure that you never have dead code again!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TL;DR: Use &lt;a href=&quot;https://github.com/nadeesha/ts-prune&quot;&gt;ts-prune&lt;/a&gt; is in maintenance mode. Use &lt;a href=&quot;https://github.com/webpro/knip&quot;&gt;knip&lt;/a&gt; to find dead code instead. It&amp;#39;s great!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Notes on TypeScript 5.1</title>
    <link href="https://effectivetypescript.com/2023/06/27/ts-51/"/>
    <id>https://effectivetypescript.com/2023/06/27/ts-51/</id>
    <published>2023-06-27T20:40:00.000Z</published>
    <updated>2023-06-27T20:41:34.046Z</updated>
    
    <content type="html"><![CDATA[<p>Every three months we get a new TypeScript release and <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/">TypeScript 5.1</a> landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&#39;s take a look!</p><span id="more"></span><h2 id="Performance-Improvements"><a href="#Performance-Improvements" class="headerlink" title="Performance Improvements"></a>Performance Improvements</h2><p>When you hear &quot;new TypeScript version&quot;, the natural tendency is to think about new language features. But what would you be more excited about: an exciting new feature like <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">template literal types</a> or a 10% faster compiler? Sorry, you can&#39;t have both!</p><p>The TypeScript team takes compiler performance incredibly seriously and every single set of release notes includes a few performance optimizations. A recent theme has been improving build times for projects that use complex libraries like Material-UI. The 5.1 release includes several <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#optimizations">optimizations</a> that add up to a big win.</p><p>As readers of this blog may recall, <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> is itself type-checked using <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. The idea is that when new versions of TypeScript come out, I can quickly check whether any of the hundreds of code samples in the book produce new and unexpected errors. This is a great confidence booster that my book still matches reality, but it also means that <em>Effective TypeScript</em> can serve as a good gauge of what&#39;s changed between releases.</p><p>First let&#39;s look at performance:</p><ul><li>Checking Effective TypeScript (TS 5.0.4): 180.6s average</li><li>Checking Effective TypeScript (TS 5.1.3): 170.9s average</li></ul><p>That&#39;s about a 5% speedup. Not bad!</p><h2 id="Improved-Error-Messages"><a href="#Improved-Error-Messages" class="headerlink" title="Improved Error Messages"></a>Improved Error Messages</h2><p>literate-ts is very sensitive to how error messages and types <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a>. TypeScript 5.1 includes a <a href="https://github.com/microsoft/TypeScript/issues/52934">nice change</a> in how type errors on <code>return</code> statements are displayed that didn&#39;t make it into the release notes. In previous versions of TypeScript, if you returned an expression of the wrong type, you&#39;d get the dreaded red squiggles under both the <code>return</code> keyword and the entire expression. For multiline expressions, this could be a lot of red!</p><img src="/images/red-return.png" alt="Code sample showing lots of red"><p>With TypeScript 5.1, the red squiggles only appear under the <code>return</code> keyword:</p><img src="/images/red-return-less-red.png" alt="Code sample showing much less red"><p>This is less distracting and makes it easier for you to inspect your code to find the source of the error. Not a huge change, but a nice win nonetheless. Next time you&#39;re debugging a type error in a <code>return</code> statement, thank Mateusz Burzyński for the <a href="https://github.com/microsoft/TypeScript/pull/52943">change</a>!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Upgrading TypeScript often uncovers existing mistakes in your code and TS 5.1 was no exception. There was one new error that came up in a few of my projects.</p><p>TypeScript has long flagged duplicate keys in object literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>    foo: <span class="hljs-number">12</span>,<br>    bar: <span class="hljs-number">34</span>,<br>    foo: <span class="hljs-number">56</span>,<br><span class="hljs-comment">//  ~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>But if you used <em>computed</em> keys, this error would go away:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> FOO = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-keyword">const</span> BAR = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,  <span class="hljs-comment">// (not an error in TS 5.0)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>With TS 5.1, this is an error:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  [FOO]: <span class="hljs-number">12</span>,<br>  [BAR]: <span class="hljs-number">34</span>,<br>  [FOO]: <span class="hljs-number">56</span>,<br><span class="hljs-comment">// ~~~~ An object literal cannot have multiple properties with the same name.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>This check only occurs for single-valued literal types.</p><!-- Error messages for `Expression4` have improved! --><!--Performance stats- TS 5.1.3:  - yarn verify  170.84s user 13.34s system 151% cpu 2:01.52 total (7/601 failed)  - yarn verify  171.54s user 13.09s system 151% cpu 2:01.72 total (4/601 failed)  - yarn verify  170.26s user 13.19s system 151% cpu 2:01.19 total (3/601 failed)- TS 5.0.4:  - yarn verify  180.57s user 13.05s system 145% cpu 2:12.67 total (3/601 failed)  - yarn verify  181.27s user 12.56s system 144% cpu 2:13.70 total (3/601 failed)  - yarn verify  180.83s user 13.00s system 145% cpu 2:12.92 total (3/601 failed)--><h2 id="Notes-on-other-changes"><a href="#Notes-on-other-changes" class="headerlink" title="Notes on other changes"></a>Notes on other changes</h2><p>The &quot;headline&quot; features in the official release notes for TS 5.1 are mostly niche changes that won&#39;t affect many users immediately. Here&#39;s a quick rundown:</p><ul><li><strong>Easier Implicit Returns for undefined-Returning Functions</strong> I&#39;ve never personally run across a function that was declared to return <code>undefined</code> rather than <code>void</code>. But if you work with such functions, your life gets easier with TS 5.1.</li><li><strong>Unrelated Types for Getters and Setters</strong> This <em>seems</em> like a bad idea though as the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/#unrelated-types-for-getters-and-setters">CSS example</a> in the release notes makes clear, this is an established pattern in the wild that TypeScript needs to model. I tend to avoid getters and setters (and classes in general). This relates to <em>Effective TypeScript</em>&#39;s Item 29: Be Liberal in What You Accept and Strict in What You Produce.</li><li><strong>Decoupled Type-Checking Between JSX Elements and JSX Tag Types</strong> This seems quite in the weeds, but the gist is that it&#39;s future-proofing for async React components, which may land sometime in the future. When these eventually land, we&#39;ll be happy that TypeScript supports them out of the box.</li></ul><p>I was extremely excited about one other change in the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-1-rc/#move-declarations-to-existing-files">TypeScript 5.1 RC</a> that sadly got cut for the release: a &quot;move to existing file&quot; refactor. There&#39;s a nice video of this in action in the RC release notes. This has been a long-standing and much-upvoted <a href="https://github.com/microsoft/TypeScript/issues/29988">feature request</a>. You can move a symbol to a <em>new</em> file, but not to an existing file.</p><p>I have a workaround, but it&#39;s a bit gross. Say you want to move a symbol to an existing file <code>src/utils/my-utils.ts</code>. Instead, move it to a new file <code>src/utils/new-file.ts</code>. This will update all the imports for the symbol to point to the new file. Then cut/paste the definition of your symbol into <code>my-utils.ts</code>, delete <code>new-file.ts</code> and run a big Find/Replace to update all the imports:</p><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git ls-files | xargs perl -i -pe <span class="hljs-string">&#x27;s,new-file.ts,my-utils.ts,`</span><br></code></pre></td></tr></table></figure><p>Like I said, gross! Hopefully this feature lands more permanently in TypeScript 5.2.</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>TypeScript 5.1 is not a major release when it comes to new language features, but it does include some performance wins, it may catch some new errors in your project, and it lays the groundwork for more changes in the future. Keep your eyes out for the TypeScript 5.2 beta which should be landing <a href="https://github.com/microsoft/TypeScript/issues/54298">any day now</a> and looks to have some <a href="https://www.totaltypescript.com/type-argument-placeholders-typescript-5-2-most-discussed-feature">exciting new features</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Every three months we get a new TypeScript release and &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-1/&quot;&gt;TypeScript 5.1&lt;/a&gt; landed on June 1, 2023. This release has a few interesting new features, but by far the most noticeable changes are performance improvements and error message ergonomics. Let&amp;#39;s take a look!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Item 30: Don’t Repeat Type Information in Documentation</title>
    <link href="https://effectivetypescript.com/2023/05/31/jsdoc-repeat/"/>
    <id>https://effectivetypescript.com/2023/05/31/jsdoc-repeat/</id>
    <published>2023-05-31T15:36:00.000Z</published>
    <updated>2023-06-26T16:02:57.861Z</updated>
    
    <content type="html"><![CDATA[<p><em>Chapter 4 of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!</em></p><p>What’s wrong with this code?</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a string with the foreground color.</span><br><span class="hljs-comment"> * Takes zero or one arguments. With no arguments, returns the</span><br><span class="hljs-comment"> * standard foreground color. With one argument, returns the foreground color</span><br><span class="hljs-comment"> * for a particular page.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> page === <span class="hljs-string">&#x27;login&#x27;</span> ? &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">127</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">127</span>&#125; : &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>The code and the comment disagree! Without more context it’s hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &quot;when your code and your comments disagree, they’re both wrong!&quot;</p><span id="more"></span><p>Let’s assume that the code represents the desired behavior. There are a few issues with this comment:</p><ul><li>It says that the function returns the color as a <code>string</code> when it actually returns an <code>&#123;r, g, b&#125;</code> object.</li><li>It explains that the function takes zero or one arguments, which is already clear from the type signature.</li><li>It’s needlessly wordy: the comment is longer than the function declaration <em>and</em> implementation!</li></ul><p>TypeScript’s type annotation system is designed to be compact, descriptive, and readable. Its developers are language experts with decades of experience. It’s almost certainly a better way to express the types of your function’s inputs and outputs than your prose!</p><p>And because your type annotations are checked by the TypeScript compiler, they&#39;ll never get out of sync with the implementation. Perhaps <code>getForegroundColor</code> used to return a string but was later changed to return an object. The person who made the change might have forgotten to update the long comment.</p><p>Nothing stays in sync unless it&#39;s forced to. With type annotations, TypeScript&#39;s type checker is that force! If you put type information in annotations and not in documentation, you greatly increase your confidence that it will remain correct as the code evolves.</p><p>A better declaration and comment might look like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123;<br>  r: <span class="hljs-built_in">number</span>;<br>  g: <span class="hljs-built_in">number</span>;<br>  b: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-comment">/** Get the foreground color for the application or a specific page. */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getForegroundColor</span>(<span class="hljs-params">page?: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Color</span> </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>If you want to describe a particular parameter, use an <code>@param</code> JSDoc annotation. For more on this, see Item 48: Use TSDoc for API Comments.</p><p>Comments about a lack of mutation are also suspect. Don&#39;t just say that you don&#39;t modify a parameter:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">/** Does not modify nums */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>Instead, declare it <code>readonly</code> (See Item 17: Use readonly to Avoid Errors Associated with Mutation) and let TypeScript enforce the contract:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sort</span>(<span class="hljs-params">nums: <span class="hljs-keyword">readonly</span> <span class="hljs-built_in">number</span>[]</span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>What&#39;s true for comments is also true for variable names. Avoid putting types in them: rather than naming a variable <code>ageNum</code>, name it <code>age</code> and make sure it&#39;s really a <code>number</code>.</p><p>An exception to this is for numbers with units. If it&#39;s not clear what the units are, you may want to include them in a variable or property name. For instance, <code>timeMs</code> is a much clearer name than just <code>time</code>, and <code>temperatureC</code> is a much clearer name than <code>temperature</code>. Item 37 describes &quot;brands,&quot; which provide a more type-safe approach to modeling units.</p><h3 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h3><ul><li>Avoid repeating type information in comments and variable names. In the best case it is duplicative of type declarations, and in the worst it will lead to conflicting information.</li><li>Consider including units in variable names if they aren&#39;t clear from the type (e.g., <code>timeMs</code> or <code>temperatureC</code>).</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;Chapter 4 of &lt;a href=&quot;https://amzn.to/3HIrQN6&quot;&gt;Effective TypeScript&lt;/a&gt; covers type design: the process of crafting your types to accurately model your domain. This item has always been a favorite of mine because of how immediately actionable it is. When you review code, be on the lookout for violations!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;What’s wrong with this code?&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Returns a string with the foreground color.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * Takes zero or one arguments. With no arguments, returns the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * standard foreground color. With one argument, returns the foreground color&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; * for a particular page.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt; */&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getForegroundColor&lt;/span&gt;(&lt;span class=&quot;hljs-params&quot;&gt;page?: &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;br&gt;  &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; page === &lt;span class=&quot;hljs-string&quot;&gt;&amp;#x27;login&amp;#x27;&lt;/span&gt; ? &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;127&lt;/span&gt;&amp;#125; : &amp;#123;&lt;span class=&quot;hljs-attr&quot;&gt;r&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;g&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-attr&quot;&gt;b&lt;/span&gt;: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&amp;#125;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;The code and the comment disagree! Without more context it’s hard to say which is right, but something is clearly amiss. As a professor of mine used to say, &amp;quot;when your code and your comments disagree, they’re both wrong!&amp;quot;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A first look at Deno through the Advent of Code 2022</title>
    <link href="https://effectivetypescript.com/2023/04/27/aoc2022/"/>
    <id>https://effectivetypescript.com/2023/04/27/aoc2022/</id>
    <published>2023-04-27T21:00:00.000Z</published>
    <updated>2023-04-27T21:16:24.172Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/advent-of-code.png" title="Advent of Code Logo" width="64" height="64" style="float: right; margin-left: 10px;">Every year I do the <a href="https://adventofcode.com/">Advent of Code</a> in a different programming language. If you aren&#39;t familiar, it&#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&#39;s a great way to learn a language and bond over coding. In <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd">2019</a> I used Python, in <a href="https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc">2020</a> I used Rust and in <a href="https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/">2021</a> I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&#39;s 2022! (As a partial excuse, I have been writing on a <a href="https://danvk.org/catskills/">very different blog</a>!)</p><p>This past December I chose TypeScript, specifically <a href="https://deno.land">Deno</a>, which <a href="https://www.youtube.com/watch?v=1gIiZfSbEAE">brands itself</a> as &quot;a new way to TypeScript&quot;. While TypeScript certainly isn&#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.</p><p>This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&#39;s Advent of Code.</p><span id="more"></span><p>My code and more notes on each day&#39;s puzzles can be found on GitHub at <a href="https://github.com/danvk/aoc2022">danvk/aoc2022</a>.</p><h2 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h2><p>Deno brands itself as a more secure JavaScript runtime that&#39;s more standards-compliant and easier to use. The comparison here is obviously Node.js. Deno was created by <a href="https://en.wikipedia.org/wiki/Ryan_Dahl">Ryan Dahl</a>, who also created Node.js, and it&#39;s fair to think of it as a &quot;take two&quot; on Node that avoids some of its questionable decisions.</p><p>Overall these claims hold up well. Deno is much easier to set up than Node: it already uses TypeScript, it has a built-in linter and formatter, and it comes with a system for unit tests. These are all things you <em>can</em> set up with Node, but it takes an extra step. That&#39;s a hurdle for beginners, and an opportunity for mistakes for all of us. For the most part, writing code in Deno feels just like writing TypeScript in any other environment, only with much less configuration.</p><p>(Just like a browser, Deno <a href="https://deno.com/manual@v1.32.1/advanced/typescript/overview">doesn&#39;t run your TypeScript directly</a>. It translates it to JavaScript first using <a href="https://swc.rs/">swc</a> and then runs that.)</p><p>Deno&#39;s sandboxing is a great security feature. Unless you specifically allow a capability (such as reading or writing to the file system), Deno won&#39;t allow it. This makes it safer to run programs that you download from the internet. Since I was running mostly my own code for the Advent of Code, in practice this meant that every solution started with this <a href="https://en.wikipedia.org/wiki/Shebang_(Unix)">shebang line</a>:</p><pre><code>#!/usr/bin/env -S deno run --allow-read --allow-write</code></pre><p>Deno tries to embrace web standards to the extent that it makes sense. Rather than using a library to make HTTP requests, you use <code>fetch</code>, just like you would in a web browser. Perhaps the most notable example of this comes with dependencies. Rather than a <code>require</code> statement or running <code>npm install</code>, you depend on third-party libraries by using a standard ES <code>import</code> statement from a URL:</p><pre><code>import &#123; assert &#125; from &quot;https://deno.land/std@0.166.0/testing/asserts.ts&quot;;</code></pre><p>The version goes right there in the import URL. If you&#39;re used to npm, you probably have a few objections in your head right now! Rest assured, the Deno folks have thought through them:</p><ul><li>What if someone takes over deno.land and swaps in a malicious version of the library? You can use a <a href="https://deno.com/manual@v1.32.5/basics/modules/integrity_checking">lock file</a> for integrity checking.</li><li>Won&#39;t this be unwieldy? In practice, the Deno team recommends <a href="https://deno.com/manual@v1.32.5/basics/modules#it-seems-unwieldy-to-import-urls-everywhere">creating a <code>deps.ts</code> file</a> that consolidates all these imports in one place. This replaces <code>package.json</code>. It&#39;s a good example of Deno&#39;s preference using JS standards. I have some misgivings about this, though, see below.</li><li>What about dev dependencies? I haven&#39;t seen anything written about this explicitly, but I assume the suggestion is to have a <code>dev-deps.ts</code> file or some such.</li><li>Won&#39;t this cause an explosion of versions in transitive dependencies?</li></ul><p>To see why this might happen, imagine that module A depends on <code>lodash@4.17.20</code> and module B depends on <code>lodash@4.17.21</code>. With deno imports, you wind up with two versions of lodash:</p><p><img src="/images/aoc2022/deps-deno.png" alt="Dependencies in Deno yield two copies of lodash"></p><p>When you import from a URL that includes the full version, all your (transitive) dependencies are pinned. Node.js avoids this by specifying compatible ranges in dependencies. Perhaps A just requires <code>lodash&gt;=4</code> and B requires <code>lodash&gt;=4.10</code>. In that case, we can get down to a single version:</p><p><img src="/images/aoc2022/deps-node.png" alt="Dependencies in Node.js yield one copy of lodash"></p><p>The Deno answer to this dilemma is an <a href="https://deno.com/manual@v1.32.5/basics/import_maps">import map</a>, which lets you reach in and tweak the versions. Again, this is a <a href="https://github.com/WICG/import-maps">JavaScript standard</a>, but it feels a bit unwieldy. Would you actually do this to reduce the number of dependencies in your code? And how would you know which versions of <code>lodash</code> a module is compatible with unless it specifies.</p><p>I didn&#39;t personally run into any issues with this in the Advent of Code since I only had one or two dependencies. But projects I&#39;ve worked on professionally have had thousands, and I&#39;m nervous about any patterns that would lead to an even greater proliferation of dependencies. If you have experience building larger projects in Deno and have run into this (or not), I&#39;d love to hear about it in the comments.</p><p>I also have some concerns about the <code>deps.ts</code> system. It&#39;s clever to use a plain old TypeScript file as a <code>package.json</code> replacement in this way. But because it&#39;s a TypeScript file, my concern is that you&#39;ll be tempted to write real code in it, i.e. logic. Why is this a problem? Just look at the mess that is <code>setup.py</code> in Python land. In general it&#39;s impossible to know how a package is configured without executing <code>setup.py</code>, which could cause any number of side effects. This makes analysis harder, for example writing tools like dependabot. Simpler configuration enables more accurate, powerful tools. (<a href="https://deno.com/blog/v1.31#packagejson-support">Deno 1.31</a> added support for <code>package.json</code> to ease transitioning from Node but still recommends using import maps.)</p><p>While Deno works best when you import other Deno modules (from <code>deno.land</code>), the headline feature of <a href="https://deno.com/blog/v1.28">Deno 1.28</a> was support for npm modules. Here&#39;s what this looks like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; chalk &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:chalk@5&quot;</span>;<br></code></pre></td></tr></table></figure><p>Easy, right? But what about TypeScript? Often the type declarations for npm libraries are hosted in a different package via DefinitelyTyped. I struggled mightily to get typings for lodash (see some <a href="https://stackoverflow.com/questions/64979829/deno-import-lodash-from-deno-land-x/66073607#66073607">crazy solutions</a> on Stack Overflow) before asking for help <a href="https://twitter.com/danvdk/status/1598502672319057925">on Twitter</a>. Here&#39;s where I wound up:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// @deno-types=&quot;npm:@types/lodash&quot;</span><br><span class="hljs-keyword">import</span> &#123;<span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> ld&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;npm:lodash&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> _ = ld;<br></code></pre></td></tr></table></figure><p>So much for standards! But in fairness to Deno, once I had this magic in place I never had to think about it again.</p><p>Another pain point: I ran into <a href="https://github.com/denoland/deno/issues/17055">several</a> different <a href="https://github.com/denoland/deno/issues/17056">issues</a> with the VS Code extension, including one that changed my code to give me a wrong answer! To the Deno team&#39;s credit, they fixed both issues that I reported quickly, before Christmas. Deno is a relatively new project that is moving fast, but this also means you&#39;re more likely to run into glitches like this.</p><p>In the end, Deno is pretty nice to work with. If we were starting from scratch, it would be a much better choice than Node.js. But the Node/npm ecosystem has a ten year headstart on Deno, and I&#39;d like to give the npm integration story a bit more time to play out before I commit to using Deno on a larger project.</p><p>For a more glowing endorsement of Deno, see <a href="https://matklad.github.io/2023/02/12/a-love-letter-to-deno.html">A Love Letter to Deno</a> by <a href="https://matklad.github.io/">Alex Kladov</a>.</p><h2 id="TypeScript-JavaScript-for-Coding-Competitions"><a href="#TypeScript-JavaScript-for-Coding-Competitions" class="headerlink" title="TypeScript/JavaScript for Coding Competitions"></a>TypeScript/JavaScript for Coding Competitions</h2><p>TypeScript is a more natural fit for web programming and servers than for coding competitions, which are more the home turf for Python. So I was curious to see how doing AoC in TypeScript would feel.</p><p>JavaScript is famous for its <a href="https://en.wiktionary.org/wiki/footgun">footguns</a> and TypeScript/Deno inherit many of these. One of them got me on the <a href="https://adventofcode.com/2022/day/1">very first problem</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> sums = [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>];<br>sums.sort();<br><span class="hljs-built_in">console</span>.log(sums);<br><span class="hljs-comment">// logs [1, 10, 2] -- the sort is lexicographic!</span><br></code></pre></td></tr></table></figure><p>Yes, this is one of many reasons why we always use lodash!</p><p>I&#39;d hoped that this year&#39;s Advent of Code would force me to play around more with <code>BigInt</code> (for huge numbers) and web workers (for parallelism), but neither of these proved to be necessary this year.</p><p>I did make extensive use of ES2015&#39;s <code>Set</code> and <code>Map</code> classes. These make amends for the &quot;original sin of JavaScript&quot;, namely the conflation of objects and associative arrays. While <code>Set</code> and <code>Map</code> do fix many of the issues with objects (accessing <code>prototype</code>, supporting non-<code>string</code> keys), they have some footguns of their own.</p><p>For example, I learned back in 2019 that a map with (x, y) tuples as keys is often a <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">more convenient way</a> to represent a grid than a 2D array. Python handles this pattern nicely with its built-in tuple type:</p><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">grid = &#123;&#125;<br>grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] = <span class="hljs-number">3</span><br>print(grid[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)])<br><span class="hljs-comment"># prints 3</span><br></code></pre></td></tr></table></figure><p>The equivalent in JS/TS doesn&#39;t work as you&#39;d hope:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>&lt;[<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>], <span class="hljs-built_in">number</span>&gt;();<br>grid.set([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs undefined</span><br></code></pre></td></tr></table></figure><p>The issue is that <code>Map</code> and <code>Set</code> keys are (<a href="https://stackoverflow.com/questions/56195369/how-does-same-value-zero-algorithm-works">roughly</a>) compared using <code>===</code>, which tests for reference equality, not value equality:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br></code></pre></td></tr></table></figure><p>This situation will be improved greatly if the <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a> is ratified by TC39 (<a href="https://rickbutton.github.io/record-tuple-playground/#eyJjb250ZW50IjoiY29uc29sZS5sb2coI1sxLCAyXSA9PT0gI1sxLCAyXSk7XG5cbmNvbnN0IGdyaWQgPSBuZXcgTWFwKCk7XG5ncmlkLnNldCgjWzEsIDJdLCAzKTtcbmNvbnNvbGUubG9nKGdyaWQuZ2V0KCNbMSwgMl0pKTtcbiIsInN5bnRheCI6Imhhc2giLCJkb21Nb2RlIjpmYWxzZX0=">playground link</a>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">console</span>.log(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] === #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]);<br><span class="hljs-comment">// logs true</span><br><br><span class="hljs-keyword">const</span> grid = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>grid.set(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.log(grid.get(#[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]));<br><span class="hljs-comment">// logs 3</span><br></code></pre></td></tr></table></figure><p>Here&#39;s hoping! Without this, my implementations of standard algorithms like <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">shortest path</a> required lots of <a href="https://github.com/danvk/aoc2022/blob/da3b5af9aef99cff8c1f739d07958d7c75a5794a/dijkstra.ts#L18-L19">serialization and deserialization code</a>.</p><p>Another JS/TS feature that I really embraced was Iterators and Generators. Say you have a <code>sum</code> function that takes an array of numbers:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: <span class="hljs-built_in">number</span>[]</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br></code></pre></td></tr></table></figure><p>What if you want this to accept the output of a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">generator function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">squares</span>(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-keyword">yield</span> n ** <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TypeScript will give you an error if you try to compose these:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));<br><span class="hljs-comment">//                 ~~~~~~~~~~ Argument of type &#x27;Generator&lt;number, void, unknown&gt;&#x27;</span><br><span class="hljs-comment">//                            is not assignable to parameter of type &#x27;number[]&#x27;.</span><br></code></pre></td></tr></table></figure><p>Interestingly, though, this works at runtime and gives the correct answer (125)! To make it type check, we just need to loosen the parameter type for <code>sum</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">xs: Iterable&lt;<span class="hljs-built_in">number</span>&gt;</span>): <span class="hljs-title">number</span> </span>&#123;<br>  <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> x <span class="hljs-keyword">of</span> xs) &#123;<br>    total += x;<br>  &#125;<br>  <span class="hljs-keyword">return</span> total;<br>&#125;<br><span class="hljs-keyword">const</span> sumto5 = sum(squares(<span class="hljs-number">5</span>));  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>Whenever I write functions that accept arrays now, I&#39;m going to ask &quot;could this take an Iterable instead?&quot; Often the answer is yes, and this gives you more flexibility in how you call the function. I found this particularly nice for callbacks that returned arrays, which are often cleaner to write as generators. See <a href="https://github.com/danvk/aoc2022/commit/c81b90e25db7617f42f8e78d6b76276f9c8a039c">this commit</a>.</p><p>Iterators are a great feature, but they are somewhat held back by their <a href="https://github.com/lodash/lodash/issues/737">lack of support</a> in lodash. There&#39;s a TC39 proposal to add <a href="https://2ality.com/2022/12/iterator-helpers.html">iterator helpers</a> to the standard library.</p><p>Because JavaScript doesn&#39;t have a built-in <a href="https://immutable-js.com/docs/v4.2.2/List/">deque</a> structure, I just used an <code>Array</code> in a very suboptimal way when I implemented <a href="https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm">Dijkstra</a>. After wrapping up the whole competition, I tried <a href="https://github.com/danvk/aoc2022/compare/57c04a892ca52a1909d872e674984d557a59c86e...08f25f52ef4d018094a08df92c38dd8f15a87aae">plugging in</a> a priority queue. Suddenly some of my code ran 100x faster! Asymptotic performance: sometimes it matters!</p><p>Overall using TypeScript for the Advent of Code was OK but not great. It was a good excuse to try out a few new features of JavaScript, but it left me really wanting a few other proposals to get adopted!</p><h2 id="Advent-of-Code-2022"><a href="#Advent-of-Code-2022" class="headerlink" title="Advent of Code 2022"></a>Advent of Code 2022</h2><p>This was probably the easiest Advent of Code I&#39;ve done (easier than 2018, 2019, 2020, 2021). Again, there were no dependencies between days. There was also no matrix math, which was a change from previous years.</p><p>I usually do some kind of warmup project in a new language before day 1, traditionally implementing a <a href="https://github.com/danvk/rusty-boggle">Boggle Solver</a>. Since I&#39;d already implemented <a href="https://github.com/danvk/bogglets">Boggle in TypeScript</a>, I decided to do the first few puzzles of the 2018 Advent of Code instead. This was fun and very effective at preparing me for the 2022 Advent of Code. But it was a dangerous decision! Once I started the 2018 puzzles, I couldn&#39;t stop. So I wound up doing two Advents of Code simultaneously. This really highlighted that the 2018 Advent of Code was more difficult than 2022.</p><p>I tend to solve AoC problems in the morning: I&#39;m usually asleep well before midnight when they&#39;re posted on the east coast. But I&#39;d always been curious to try solving one at midnight to see what my global rank would be. I finally did it on day 15 this year. It was a roller coaster experience. Debugging while sleepy was unpleasant and really took me back to college. But I did manage to finish both parts before 1 AM and got my first-ever top 1000 finish:</p><p><img src="/images/aoc2022/rank-831.png" alt="Rank #831 on Day 15 part 2"></p><p>I was lucky -- had I tried this on day 16, which was much harder, I would have been up until 3 AM! Falling asleep after racing to solve a puzzle isn&#39;t easy.</p><p>I&#39;d hoped to stay up late enough to solve the final puzzle live. I was in Costa Rica at that point so it only would have been 11 PM and the Christmas is usually an easy puzzle. But by 10 PM I was in bed and couldn&#39;t keep my eyes open, so I just wrapped things up the next morning. I was finisher #5127 overall.</p><p>There were a few standout problems this year:</p><p><img src="/images/aoc2022/dans-cube.jpg" alt="My cube for day 222"></p><ul><li><a href="https://github.com/danvk/aoc2022#day-22-8786--4298">Day 22</a>: The Cube. Not hard, just very annoying. Though I did enjoy seeing photos of everyone&#39;s <a href="https://www.reddit.com/r/adventofcode/comments/zsct8w/2022_day_22_solutions/">cubes</a>.</li><li><a href="https://github.com/danvk/aoc2022#day-24-6284--6073">Day 24</a>: Blizzards, a fun application of Dijkstra where the state space isn&#39;t just your coordinate.</li><li><a href="https://github.com/danvk/aoc2022#day-20-7780--6961">Day 20</a>: Memorable for a pernicious off-by-one error.</li><li><a href="https://github.com/danvk/aoc2022#day-19-7649--6570">Day 19</a>: Robot Factories. This was the hardest one of the year for me. I never produced a fully correct solution, but I did discover <a href="https://en.wikipedia.org/wiki/Beam_search">beam search</a> which is something that will stick with me.</li><li><a href="https://github.com/danvk/aoc2022#day-16-6564--4162">Day 16</a>: Valves; this was probably the second hardest problem.</li><li><a href="https://github.com/danvk/aoc2022#day-9-31369--23800">Day 9</a>: Snake; really have to trust your implementation on this one. I was very glad to not have a bug!</li></ul><p>Overall, though, my favorite problem was probably <a href="https://adventofcode.com/2018/day/23">2018 day 23</a>.</p><p>So there you have it, Advent of Code 2022 in Deno. See you next December (or maybe April!).</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/advent-of-code.png&quot; title=&quot;Advent of Code Logo&quot; width=&quot;64&quot; height=&quot;64&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;Every year I do the &lt;a href=&quot;https://adventofcode.com/&quot;&gt;Advent of Code&lt;/a&gt; in a different programming language. If you aren&amp;#39;t familiar, it&amp;#39;s an online coding competition with a new two-part problem every day from December 1st to the 25th. Thousands of programmers participate and share their solutions. It&amp;#39;s a great way to learn a language and bond over coding. In &lt;a href=&quot;https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd&quot;&gt;2019&lt;/a&gt; I used Python, in &lt;a href=&quot;https://danvdk.medium.com/advent-of-code-2020-this-time-in-rust-7904559e24bc&quot;&gt;2020&lt;/a&gt; I used Rust and in &lt;a href=&quot;https://effectivetypescript.com/2022/02/06/advent-of-code-2021-golang/&quot;&gt;2021&lt;/a&gt; I used Go. I also post an increasingly-belated writeup of my experience and impressions of the language so, at the end of April, here&amp;#39;s 2022! (As a partial excuse, I have been writing on a &lt;a href=&quot;https://danvk.org/catskills/&quot;&gt;very different blog&lt;/a&gt;!)&lt;/p&gt;
&lt;p&gt;This past December I chose TypeScript, specifically &lt;a href=&quot;https://deno.land&quot;&gt;Deno&lt;/a&gt;, which &lt;a href=&quot;https://www.youtube.com/watch?v=1gIiZfSbEAE&quot;&gt;brands itself&lt;/a&gt; as &amp;quot;a new way to TypeScript&amp;quot;. While TypeScript certainly isn&amp;#39;t a new language for me, Deno is a new way to use it. I was also curious how JavaScript/TypeScript would do on AoC-style coding competitions and, frankly, I hadn&amp;#39;t been doing much coding of late and was keen to have an excuse to use my favorite language more.&lt;/p&gt;
&lt;p&gt;This post is broken into three parts: thoughts on Deno, thoughts on TypeScript/JavaScript for coding competitions, and my thoughts on this year&amp;#39;s Advent of Code.&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Notes on TypeScript 5.0 beta</title>
    <link href="https://effectivetypescript.com/2023/02/07/ts-50-beta/"/>
    <id>https://effectivetypescript.com/2023/02/07/ts-50-beta/</id>
    <published>2023-02-08T01:50:00.000Z</published>
    <updated>2023-06-27T19:46:20.403Z</updated>
    
    <content type="html"><![CDATA[<p>TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">TypeScript 5.0 beta</a> came out on January 26, 2023. Let&#39;s take a look at what&#39;s new!</p><span id="more"></span><h2 id="Why-not-TypeScript-4-10"><a href="#Why-not-TypeScript-4-10" class="headerlink" title="Why not TypeScript 4.10?"></a>Why not TypeScript 4.10?</h2><p>First, a note on version numbers. With <a href="https://docs.npmjs.com/about-semantic-versioning">semantic versioning</a>, a change in the major version typically means breaking changes. And the number after 4.9 is 4.10, not 5.0. TypeScript doesn&#39;t really do semantic versioning. The whole <em>point</em> of new TypeScript releases is to find (existing) issues in your code. So in that sense, each release contains breaking changes.</p><p>Microsoft also counts in decimal. The version after 4.9 is 5.0, not 4.10. This causes some pain every tenth release since many packages on npm declare that they require <code>typescript@4.x</code>. This can either hold you back on an old version of TypeScript or lead to fragmentation, as I noticed with TypeScript 4.0 back in 2020:</p><blockquote class="twitter-tweet"><p lang="en" dir="ltr">TIL I have five copies of <a href="https://twitter.com/typescript?ref_src=twsrc%5Etfw">@typescript</a> in node_modules! <a href="https://twitter.com/orta?ref_src=twsrc%5Etfw">@orta</a> was there much debate about whether the version after 3.9 was 3.10 or 4.0? In terms of branding and math, I agree it&#39;s 4.0. But since so many packages pin tsc@~3, this seems unnecessarily disruptive… <a href="https://t.co/FBiAxZBM15">pic.twitter.com/FBiAxZBM15</a></p>&mdash; Dan Vanderkam (@danvdk) <a href="https://twitter.com/danvdk/status/1319652924050595841?ref_src=twsrc%5Etfw">October 23, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script><p>Why doesn&#39;t TypeScript do versioning in the usual way? The <a href="https://github.com/Microsoft/TypeScript/issues/14116">definitive answer</a> comes from TypeScript Tech Lead Ryan Cavanaugh:</p><blockquote><p>The trade-off for getting millions of dollars of engineering investment in the TypeScript project is that marketing gets to control version numbers to a certain extent.</p></blockquote><p>So there you go. Every 2.5 years we have to deal with this extra pain. At least marketing didn&#39;t decide that the version after 3.1 was 95!</p><h2 id="New-Errors"><a href="#New-Errors" class="headerlink" title="New Errors"></a>New Errors</h2><p>Every new version of TypeScript has the potential to surface new errors in your code. As long-time readers of this blog know, the code samples in <em>Effective TypeScript</em> <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">are all type-checked</a>. One of the benefits of this is that when new TS versions come out, I can type-check my book against them. Sometimes I learn that <a href="https://twitter.com/danvdk/status/1414343269522227207">my book is out of date</a> and sometimes I <a href="https://twitter.com/danvdk/status/1513629136790634497">find new bugs in TypeScript</a>.</p><p>TypeScript 5.0 didn&#39;t surface any new errors in <em>Effective TypeScript</em>. Huzzah! 🎉</p><p>There <em>were</em> a few new errors in my work project. All of them involved <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#forbidden-implicit-coercions-in-relational-operators">comparing <code>string|number</code> to <code>number</code></a>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">error TS2365: Operator &#39;&gt;&#x3D;&#39; cannot be applied to types &#39;string | number&#39; and &#39;number&#39;.<br><br>96       (val &gt;&#x3D; minVal) &amp;&amp;<br>          ~~~~~~~~~~~~~<br></code></pre></td></tr></table></figure><p>The full code looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">if</span> (val &gt;= minVal &amp;&amp; val &lt;= maxVal) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Here <code>val</code> has type <code>string | number</code> while <code>minVal</code> and <code>maxVal</code> have type <code>number</code>. JavaScript is notoriously eager to coerce types so that operations make sense:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; 10 &gt; &quot;9&quot;<br>true<br>&gt; 10 &gt; &quot;x&quot;<br>false<br></code></pre></td></tr></table></figure><p>Not helpful, JS! TypeScript has always barred comparisons between strings and numbers. Now the noose has tightened just a bit more and you may have to be more explicit about conversions.</p><h2 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h2><p>The TypeScript team claims a <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">10-20% speedup in build times</a> with TypeScript 5.0 beta. I was able to confirm this both on my work project (<a href="https://delve.sidewalklabs.com">Delve</a>) and in running literate-ts against <em>Effective TypeScript</em>:</p><ul><li>literate-ts / Effective TypeScript:<ul><li>TS 4.9.5: 194.12s</li><li>TS 5.0-beta: 181.31s (6.6% speedup)</li></ul></li><li>Delve:<ul><li>TS 4.9.5: 46.36s</li><li>TS 5.0-beta: 38.27s (17.5% speedup)</li></ul></li></ul><p>Compiler speed is <a href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/">important</a> and these are both welcome improvements! You can read the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#speed-memory-and-package-size-optimizations">release notes</a> for more details on how these speedups were achieved.</p><h2 id="const-type-parameters"><a href="#const-type-parameters" class="headerlink" title="const type parameters"></a><code>const</code> type parameters</h2><p><a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/#const-type-parameters"><code>const</code> type parameters</a> are the one new language feature in this release. These are like <code>as const</code> but applied on the function declaration, rather than at the call site.</p><p>The applications I see for this in my own code are mostly small quality of life wins. For example, my work project has a <code>DropdownList</code> component that takes a list of options and a selected option. The list of options should be a tuple of string literals, and the selected option should be one of those literals:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    dropdownOptions=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>With TypeScript 5.0 we can move the <code>const</code> into the declaration of <code>DropdownList</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> DropdownList = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">const</span> <span class="hljs-attr">DropdownOption</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">string</span>&gt;</span>(</span><br><span class="xml">  props: &#123;</span><br><span class="xml">    options: readonly DropdownOption[];</span><br><span class="xml">    selectedOption: DropdownOption;</span><br><span class="xml">  &#125;</span><br><span class="xml">) =&gt; &#123;</span><br><span class="xml">  // ...</span><br><span class="xml">&#125;</span><br></code></pre></td></tr></table></figure><p>And drop the <code>as const</code> at the callsite:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyComponent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &lt;DropdownList<br>    options=&#123;[<span class="hljs-string">&#x27;Option A&#x27;</span>, <span class="hljs-string">&#x27;Option B&#x27;</span>, <span class="hljs-string">&#x27;Option C&#x27;</span>]&#125;<br>    selectedOption=<span class="hljs-string">&quot;Option A&quot;</span><br>  /&gt;<br>&#125;<br></code></pre></td></tr></table></figure><p>If you inspect <code>options</code> here, you can see that its type is inferred as <code>readonly (&quot;Option A&quot; | &quot;Option B&quot; | &quot;Option C&quot;)[]</code> whereas before it would have been inferred as <code>readonly string[]</code>. Nice! If you factor the list of options out into a variable, though, the context will be lost and you&#39;ll be back to using <code>as const</code>.</p><p>What else is this useful for? Back in 2020 I talked about the <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/"><code>tuple</code> helper function</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>[]&gt;</span>(...args: T): T =&gt; args;</span><br><br><span class="xml">const p1 = [1, 2];  // type is number[]</span><br><span class="xml">const p1 = tuple(3, 4);  // type is [number, number]</span><br></code></pre></td></tr></table></figure><p>What if we use a <code>const</code> type parameter on <code>tuple</code>? Interestingly, it becomes a sort of &quot;deep tuple&quot;:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tuple</span>&lt;<span class="hljs-title">const</span> <span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">readonly</span> <span class="hljs-title">unknown</span>[]&gt;(<span class="hljs-params">...x: T</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br><br><span class="hljs-keyword">const</span> coords1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br><span class="hljs-comment">//    ^? number[][]</span><br><br><span class="hljs-keyword">const</span> coords2 = tuple([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>]);<br><span class="hljs-comment">//    ^? readonly [readonly [1, 2], readonly [3, 4], readonly [5, 6]]</span><br></code></pre></td></tr></table></figure><p>Is this useful? Maybe. There are always compelling applications of new language features and I&#39;m sure I&#39;m missing some here. Do you have a use for <code>const</code> type parameters? Let me know in the comments!</p><h2 id="Enums-are-unions"><a href="#Enums-are-unions" class="headerlink" title="Enums are unions"></a>Enums are unions</h2><p>In <em>Effective TypeScript</em> Item 53 (&quot;Prefer ECMAScript Features to TypeScript Features&quot;) I discourage using enums since they&#39;re not an ECMAScript feature and generally break the mold of how TypeScript relates to JavaScript (&quot;JavaScript + Types&quot;).</p><p>With TypeScript 5.0, enums become a little more sane. Whereas this <a href="https://www.typescriptlang.org/play?ts=4.9.5#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">was OK</a> in TypeScript 4.9:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-built_in">enum</span> E &#123;<br>  a = <span class="hljs-number">1</span>,<br>  b = <span class="hljs-number">2</span>,<br>&#125;<br><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure><p>It&#39;s <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iAxgPYgDOALlMAFyykDMADANwoA9EKh0A1oiA">an error</a> in TypeScript 5.0:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> e: E = <span class="hljs-number">30</span>;<br><span class="hljs-comment">//    ~ Type &#x27;30&#x27; is not assignable to type &#x27;E&#x27;. (2322)</span><br></code></pre></td></tr></table></figure><p>So are enums OK now? As it turns out, the newfound sanity is <a href="https://www.typescriptlang.org/play?ts=5.0.4#code/KYOwrgtgBAolDeAoKKoEMoF4oEYA0yqARllAEwEC+iiANsAC5QikDMADANyIDGA9iADOTYAC5YpEJxQB6GVD4BrKKIAUiIA">only surface deep</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> n = <span class="hljs-number">30</span>;<br><span class="hljs-keyword">const</span> e: E = n;  <span class="hljs-comment">// ok :(</span><br></code></pre></td></tr></table></figure><p>TypeScript enums are complicated and problematic. While they become slightly saner with TypeScript 5.0, I still say &quot;avoid them.&quot;</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>There are more changes in the new release than what I&#39;ve written about here. Check out the <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/">release notes</a> for full details. With any luck, a release candidate (RC) will arrive on February 28th and the final cut of TypeScript 5.0 will be out on March 14th.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TypeScript developers are a lucky bunch: for us, Christmas comes four times a year when the TypeScript team releases a new beta version. This is our opportunity to try out the latest features. &lt;a href=&quot;https://devblogs.microsoft.com/typescript/announcing-typescript-5-0-beta/&quot;&gt;TypeScript 5.0 beta&lt;/a&gt; came out on January 26, 2023. Let&amp;#39;s take a look at what&amp;#39;s new!&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>All I Want for Christmas Is… These Seven TypeScript Improvements</title>
    <link href="https://effectivetypescript.com/2022/12/25/christmas/"/>
    <id>https://effectivetypescript.com/2022/12/25/christmas/</id>
    <published>2022-12-25T19:00:00.000Z</published>
    <updated>2024-04-30T21:34:48.394Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://freesvg.org/vector-clip-art-of-cartoon-presents-under-christmas-tree"><img src="https://effectivetypescript.com/images/christmas-tree.png" width="200" height="200" style="float: right" alt="Christmas tree with presents"></a> It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s <a href="https://adventofcode.com">Advent of Code</a> in Deno (look forward to a <a href="https://effectivetypescript.com/2023/04/27/aoc2022/">blog post</a> in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?</p><h2 id="A-faster-language-service"><a href="#A-faster-language-service" class="headerlink" title="A faster language service"></a>A faster language service</h2><p>When you install TypeScript, you get two executables:</p><ul><li><code>tsc</code>, which checks your code for type errors and converts it to executable JavaScript</li><li><code>tsserver</code>, which provides language services for your editor.</li></ul><p>(This is discussed in Item 6 of <em>Effective TypeScript</em>: Use Your Editor to Interrogate and Explore the Type System.)</p><p>The faster these two programs can do their job, the happier you&#39;ll be as a developer. The TypeScript team is acutely aware of this: the release notes for new versions of TypeScript always talk about performance improvements in addition to new language features. The sluggishness of <code>tsc</code> remains a pain point for many developers, though. One of them even got so frustrated that he <a href="https://www.totaltypescript.com/rewriting-typescript-in-rust">decided to rewrite <code>tsc</code> in Rust!</a>.</p><p>Personally, I don&#39;t care much about the performance of <code>tsc</code>. I only tend to run as part of a continuous integration service or in &quot;watch&quot; mode without type checking via <code>webpack</code> or <code>ts-node</code>. The performance there is good enough for me.</p><p>What I <em>do</em> care about is the performance of <code>tsserver</code>. When you apply a refactor or change a type and have to wait for the red squiggly lines to catch up, that&#39;s <code>tsserver</code> being slow. Here&#39;s a GIF showing the language service having trouble keeping up:</p><img src="https://effectivetypescript.com/images/sluggish-ts-comment-with-user.gif" with=636 height=488 alt="A type error appearing and disappearing slowly after changing an import" style="max-height: 488px"><p>These performance issues impact your moment-to-moment experience of TypeScript: did that red squiggle go away because I fixed the error, or because I&#39;m waiting for <code>tsserver</code> to catch up? They&#39;re also hard to isolate for a bug report. If <code>tsc</code> is slow, I can point the TS team at my repo and report how long <code>tsc</code> takes to run. But to reproduce language server issues, you have to open a repo in your editor and then perform a particular action. It&#39;s not automated. And performance is inconsistent since it depends on caching.</p><p>So for 2023, I&#39;d love to see a faster <code>tsserver</code>. Maybe we should rewrite that in Rust, too!</p><h2 id="A-typed-pipe"><a href="#A-typed-pipe" class="headerlink" title="A typed pipe"></a>A typed <code>pipe</code></h2><p>When you compose several functions:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">f(g(h(x)))<br></code></pre></td></tr></table></figure><p>the functions are run in the right-to-left order: first <code>h</code> then <code>g</code> then <code>f</code>. This is counter to how code typically executes: top to bottom, left to right.</p><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">pipeline proposal</a> aims to offer a more readable alternative by introducing a new operator, <code>|&gt;</code>:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">x<br>|&gt; h<br>|&gt; g<br>|&gt; f<br></code></pre></td></tr></table></figure><p>The <a href="https://github.com/tc39/proposal-pipeline-operator">proposal page</a> has lots of great material about why this is a good idea and is well worth reading. Unfortunately, though, there are two competing operator proposals and I don&#39;t anticipate this making it into JavaScript (and hence TypeScript) anytime soon. Axel Rauschmayer&#39;s blog has a good writeup on the <a href="https://2ality.com/2022/01/pipe-operator.html">current state of things</a>.</p><p>There&#39;s an alternative, though: we can implement a function (commonly called <a href="https://ramdajs.com/docs/#pipe"><code>pipe</code></a>, or <a href="https://lodash.com/docs/4.17.15#flow"><code>flow</code></a> in lodash) that composes the functions in the order we expect:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n ** <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> add1 = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> halve = <span class="hljs-function">(<span class="hljs-params">n: <span class="hljs-built_in">number</span></span>) =&gt;</span> n / <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> f = pipe(square, add1, halve, <span class="hljs-built_in">String</span>);<br><span class="hljs-comment">//    ^? (arg: number) =&gt; string</span><br><span class="hljs-keyword">const</span> x = f(<span class="hljs-number">2</span>);  <span class="hljs-comment">// &quot;2.5&quot;</span><br></code></pre></td></tr></table></figure><p>Here <code>square</code> is applied first, then <code>add1</code>, then <code>halve</code> and finally <code>String</code> to convert the number to a <code>string</code>.</p><p>This solves the pipelining problem nicely but it has a problem: it&#39;s impossible to type. For details, see this <a href="https://github.com/microsoft/TypeScript/pull/39094#issuecomment-647042984">Anders comment</a>. The issue is that there needs to be a relationship between each of the arguments to <code>pipe</code>: the parameter type of each argument needs to match the return type of the previous one. And this just can&#39;t be modeled with TS.</p><p>The lodash and Ramda typings resort to the classic <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-0/#:~:text=like%20to%20call%20%E2%80%9C-,death%20by%20a%20thousand%20overloads,-%E2%80%9D%2C%20and%20it%20doesn%E2%80%99t">&quot;death by a thousand overloads&quot;</a> solution: define safe versions for a small number of arguments (<a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/266cf9b006800a1de3836257443920b828c2e589/types/lodash/common/util.d.ts#L169-L204">seven</a> in lodash&#39;s case, <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/76ebb1cce06b08cc5ef2f31d718fd84cb9df7cc6/types/ramda/index.d.ts#L1458-L1513">ten in Ramda&#39;s</a>) and give up on typing larger invocations.</p><p>This probably works fine in 99% of cases, but it doesn&#39;t feel right! I&#39;d love to see the TypeScript type system expand to be able to type <code>pipe</code>, or see some form of the pipeline operator proposal adopted.</p><h2 id="Records-and-Tuples"><a href="#Records-and-Tuples" class="headerlink" title="Records and Tuples"></a>Records and Tuples</h2><p>I&#39;m cheating here since this is more of a JavaScript Christmas wish. But JS is TS, right? The <a href="https://github.com/tc39/proposal-record-tuple">Records and Tuples proposal</a>, currently at Stage 2, seeks to add two new data structures to JavaScript. As the proposal puts it:</p><blockquote><p>This proposal introduces two new deeply immutable data structures to JavaScript:</p><ul><li><code>Record</code>, a deeply immutable Object-like structure #{ x: 1, y: 2 }</li><li><code>Tuple</code>, a deeply immutable Array-like structure #[1, 2, 3, 4]</li></ul></blockquote><p>TypeScript already has a notion of tuple <em>types</em> (<code>[number, number]</code>). This proposal would add tuple values, which would neatly resolve a number of ambiguities in type inference.</p><p>For example, if you write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>then what should the type of <code>pt</code> be? It could be:</p><ul><li>a tuple type (<code>[number, number]</code>)</li><li>a readonly type (<code>readonly [number, number]</code>)</li><li>a mutable list (<code>number[]</code>)</li><li>an immutable list (<code>readonly number[]</code>)</li></ul><p>Without more information, TypeScript has to guess. In this case it infers the mutable list, <code>number[]</code>. You can use a <a href="https://stackoverflow.com/questions/66993264/what-does-the-as-const-mean-in-typescript-and-what-is-its-use-case">const assertion</a> (<code>as const</code>) to get (<code>readonly [number, number]</code>) or a <a href="https://effectivetypescript.com/2020/06/16/typed-identity-functions/">typed identity function</a> to get one of the others.</p><p>With this proposal, you&#39;d write:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> pt = #[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>and it would be unambiguous that you want a tuple type. This is just the tip of the iceberg: functional programming and static typing work much better when you don&#39;t have to worry about mutability (see Item 27 of <em>Effective TypeScript</em>: Use Functional Constructs and Libraries to Help Types Flow).</p><p>The other great thing about this proposal is that we&#39;d be able to use <code>===</code> to do structural comparisons between tuples and records:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; [1, 2] &#x3D;&#x3D;&#x3D; [1, 2]<br>false<br>&gt; #[1, 2] &#x3D;&#x3D;&#x3D; #[1, 2]<br>true<br></code></pre></td></tr></table></figure><p>The first comparison is <code>false</code> because the two arrays aren&#39;t the same object. Tuples have a more intuitive behavior. There is some risk of the Array / Tuple distinction being confusing, but Python has this and generally it works great.</p><p>We&#39;d also be able to use tuples as keys in <code>Set</code> and <code>Map</code> structures. This is top of mind because tuples would have been wildly useful in the Advent of Code this year (see my <a href="https://danvdk.medium.com/python-tips-tricks-for-the-advent-of-code-2019-89ec23a595dd#9719">2020 post</a> about using tuples as <code>dict</code> keys in Python).</p><h2 id="Optional-generics"><a href="#Optional-generics" class="headerlink" title="Optional generics"></a>Optional generics</h2><p>While building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> and <a href="https://github.com/danvk/crudely-typed">crudely-typed</a> libraries, I frequently ran into this situation: you have a function that takes several generic arguments, you want the user to provide one of them explicitly, but you want TypeScript to infer the others.</p><p>Here&#39;s an example of what this would like:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeLookup</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">K</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">T</span>&gt;(<span class="hljs-params">k: K</span>): (<span class="hljs-params">obj: T</span>) =&gt; <span class="hljs-title">T</span>[<span class="hljs-title">K</span>] </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">obj: T</span>) =&gt;</span> obj[k];<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> lookupName = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;name&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupName: (obj: Student) =&gt; string;</span><br><span class="hljs-keyword">const</span> lookupAge = makeLookup&lt;Student&gt;(<span class="hljs-string">&#x27;age&#x27;</span>);<br><span class="hljs-comment">//    ^? const lookupAge: (obj: Student) =&gt; number;</span><br></code></pre></td></tr></table></figure><p>TypeScript doesn&#39;t let you do this. If you <a href="https://www.typescriptlang.org/play?#code/GYVwdgxgLglg9mABAWwIYGsCmAZOd0gAOAPACoA0iA0opgB5SZgAmAzolgJ5zCKkB8ACnQAuagEoxguACMAVmNLjEAXn58A2lQC6iAN4BYAFCJEAJ0xQQZpNPmLlaxLLkb02gNzGAvseMwwRjNgVAhMRABlK2YmKH1jUzBUZEwxVigzAIBzLxNEVCzUxDAQZBlMM1zfI2MIBHTEABs8AkIAOWTwlRQMHBaiYiiQGMChAHIklLHxXIB6WdNTAD0AfkQ6sAbm-CIOlKkXMSGRqEd1dMywHNr6uO3WgEFC1R6sXB2SY9jxgsxpuYWi1W61uTX6hCeRTsCki0ViZ2KpXKlSAA">try it on the TypeScript playground</a> you&#39;ll get this error: &quot;Expected 2 type arguments, but got 1.&quot; Generics are all or nothing.</p><p>I wrote about two workarounds back in 2020: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a>. But these are workarounds. I&#39;d really love to have a way to do this without having to change my API!</p><p>The canonical issue for this feature request is <a href="https://github.com/microsoft/TypeScript/issues/10571">#10571</a>. There was <a href="https://github.com/microsoft/TypeScript/pull/26349">some work on it in 2018</a> and I put up a <a href="https://github.com/microsoft/TypeScript/issues/42388">proposal</a> two years ago, but it hasn&#39;t seen much attention recently.</p><h2 id="quot-Evolving-quot-function-types"><a href="#quot-Evolving-quot-function-types" class="headerlink" title="&quot;Evolving&quot; function types"></a>&quot;Evolving&quot; function types</h2><p>TypeScript typically does a great job of inferring function parameter types from whatever context it has:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>);<br><span class="hljs-comment">//                            ^? (parameter) x: number</span><br></code></pre></td></tr></table></figure><p>The key point here is that you don&#39;t need to write <code>(x: number) =&gt; x ** 2</code>: TypeScript is able to infer that <code>x</code> is of type <code>number</code> from the types of <code>[1, 2, 3]</code> and the type of <code>Array.prototype.map</code>.</p><p>Now try factoring out a <code>square</code> function:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> square = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x ** <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Parameter &#x27;x&#x27; implicitly has an &#x27;any&#x27; type. (7006)</span><br><span class="hljs-keyword">const</span> squares = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(square);<br></code></pre></td></tr></table></figure><p>What worked so well in the first example completely fails here. This code is correct and is a simple refactor of the other code, but TypeScript demands a type annotation here. This is a frequent source of frustration in React components, where factoring out a callback can require writing out some very complex types. I wrote a blog post about this in 2019: <a href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/">How TypeScript breaks referential transparency…and what to do about it</a>.</p><p>Why doesn&#39;t TypeScript infer the type of <code>square</code> (and hence <code>x</code>) from its usage on the next line? Anders is famously skeptical of &quot;spooky action at a distance&quot; where changing code in one place can cause a type to change and produce errors in other places that aren&#39;t obviously related.</p><p>But it does have one limited form of this: &quot;evolving <code>any</code>&quot;, which is discussed in <em>Effective TypeScript</em> Item 41: <a href="https://effectivetypescript.com/2020/03/09/evolving-any/">Understand Evolving any</a>. The gist is that TypeScript will sometimes let the type of a symbol change based on subsequent usage:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> out = [];<br>out.push(<span class="hljs-number">1</span>);<br>out.push(<span class="hljs-number">2</span>);<br> out<br><span class="hljs-comment">// ^? const out: number[]</span><br></code></pre></td></tr></table></figure><p>I have a <a href="https://github.com/microsoft/TypeScript/issues/38083">three year old proposal</a> to expand this behavior to local function variables and make the <code>square</code> example valid. React developers around the world don&#39;t know that they want this feature for Christmas, but they do!</p><h2 id="ES-Module-clarity"><a href="#ES-Module-clarity" class="headerlink" title="ES Module clarity"></a>ES Module clarity</h2><p>The JavaScript world is finally moving to ES modules (<code>import</code> and <code>export</code>). I&#39;ve been blissfully ignoring some of the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-7.html#control-over-module-detection">changes</a> that Node.js and TypeScript have been making to support them, but I get the <a href="https://github.com/microsoft/TypeScript/issues/51302">sense</a> that this is an awkward transition for both of them. Hopefully we&#39;ll be through this by the end of 2023!</p><h2 id="A-canonical-types-→-runtime-path"><a href="#A-canonical-types-→-runtime-path" class="headerlink" title="A canonical types → runtime path"></a>A canonical types → runtime path</h2><p>One of the keys to really understanding TypeScript is recognizing that TypeScript types don&#39;t exist at runtime. They are <em>erased</em>. This is so fundamental that it&#39;s Item 1 in <em>Effective TypeScript</em> (&quot;Understand the Relationship Between TypeScript and JavaScript&quot;).</p><p>But sometimes you really do want access to your TypeScript types at runtime, perhaps to do validation on untrusted inputs. There&#39;s a proliferation of libraries that let you define types in JavaScript and derive TypeScript types from them: <a href="https://github.com/colinhacks/zod">zod</a>, <a href="https://github.com/jquense/yup">yup</a>, <a href="https://github.com/gcanti/io-ts">io-ts</a> and <a href="https://reactjs.org/docs/typechecking-with-proptypes.html">React PropTypes</a> are just a few. Here&#39;s how you&#39;d define a <code>Student</code> type with Zod, for example:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Student = z.object(&#123;<br>  name: z.string(),<br>  age: z.number(),<br>&#125;);<br><br><span class="hljs-keyword">type</span> Student = z.infer&lt;<span class="hljs-keyword">typeof</span> Student&gt;;<br><span class="hljs-comment">// type Student = &#123; name: string; age: number; &#125;</span><br></code></pre></td></tr></table></figure><p>The advantage of defining a type in this way (rather than with a TypeScript <code>interface</code>) is that you can do runtime validation using the <code>Student</code> value (which you cannot do with the <code>Student</code> <em>type</em>):</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> missingAge = Student.parse(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Bobby&quot;</span>&#125;);<br><span class="hljs-comment">// throws an error at runtime.</span><br></code></pre></td></tr></table></figure><p>I prefer a different approach, though. TypeScript already has a great language for defining types and the relationships between them. Why learn another one? In <a href="https://github.com/danvk/crosswalk">crosswalk</a>, I use <a href="https://github.com/YousefED/typescript-json-schema">typescript-json-schema</a> to generate JSON Schema from my TypeScript type declarations. This JSON Schema is used to validate requests and generate Swagger/OpenAPI documentation.</p><p>But again, all these approaches are workarounds for the root issue: there&#39;s no way to get access to a TypeScript type at runtime. I&#39;d love it if there were a canonical solution to this problem, so that we could all use the same solution. Perhaps <a href="https://2ality.com/2022/10/javascript-decorators.html">decorators</a> can help.</p><p>This would be a big change for TypeScript, and would generally go against its design philosophy. So while I have some hope for my other wishes, I have very little hope for this last one.</p><hr><p>Would you be excited about any of these changes? What&#39;s on the top of your TypeScript Christmas list? Let me know in the comments or <a href="https://twitter.com/danvdk">on Twitter</a>.</p>]]></content>
    
    <summary type="html">
    
      It&#39;s Christmastime and I&#39;ve been happily working through this year&#39;s Advent of Code in Deno (look forward to a blog post in the new year). What with all the presents, it&#39;s a good time to think about what we&#39;d most like to see from TypeScript in the new year. Here are my top seven feature requests for 2023. Yes, that&#39;s a lot, but really I&#39;d be thrilled with just one or two. Pretty please?

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>What&#39;s TypeScript compiling? Use a treemap to find out.</title>
    <link href="https://effectivetypescript.com/2022/07/30/treemap-for-source-files/"/>
    <id>https://effectivetypescript.com/2022/07/30/treemap-for-source-files/</id>
    <published>2022-07-30T18:30:00.000Z</published>
    <updated>2022-07-30T18:47:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>What would you be most excited to see in the next set of TypeScript <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-7/">release notes</a>? Perhaps a fancy new language feature that makes generic types <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">more powerful</a>? A new way to do <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">type inference</a>? Or maybe a <a href="https://github.com/microsoft/TypeScript/issues/29988">new refactor</a> in the language service?</p><p>Now would you rather have that shiny new feature, or would you rather have TypeScript build your code 20% faster? In terms of your daily happiness and productivity, the speedup will almost certainly be the bigger win.</p><p>TypeScript performance is an important and sometimes frustrating part of the developer experience. Projects tend to start small and fast, but as they grow, type checking (<code>tsc</code>) and editor interactions (<code>tsserver</code>) get slower and TypeScript becomes less of a joy to use.</p><p>How can you make TypeScript run faster? Microsoft has a <a href="https://github.com/microsoft/TypeScript/wiki/Performance">guide</a> to TypeScript performance, and that&#39;s a great place to start. This post will talk about one particularly easy and effective way to debug performance issues: looking at what TypeScript is compiling using a treemap visualization.</p><p>Before we get started, let&#39;s be clear what we mean by performance. This is <em>not</em> the runtime performance of your code. For the most part, TypeScript is compiled to JavaScript by stripping out all the type annotations. So it cannot affect the runtime performance of your code. (If you see claims that TS affects runtime performance, for example this <a href="https://hackaday.com/2021/11/18/c-is-the-greenest-programming-language/">notoriously shoddy</a> paper, be very skeptical!) When I say &quot;performance&quot;, I mean compiler performance and language service performance: How long does it take <code>tsc</code> to compile your code and report type errors? And how long does it take after you edit a source file for errors to appear and disapper in your editor? These affect developer experience (DX) directly, but not user experience (UX).</p><p>One of the best ways to be fast is to do less stuff. In the case of TypeScript, that means compiling fewer lines of code.</p><p>The <code>tsc</code> command has a handy <code>--listFiles</code> option that will show you exactly what it&#39;s looking at when it compiles your code:</p><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">$ tsc --listFiles<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es5.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2015.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2016.d.ts<br>...&#x2F;lib&#x2F;node_modules&#x2F;typescript&#x2F;lib&#x2F;lib.es2017.d.ts<br>...<br></code></pre></td></tr></table></figure><p>If TypeScript has gotten sluggish on your project, then you should look at this list! There might be source files that surprise you.</p><p>For a large project, this list can include thousands of source files, so you&#39;ll want some way to visualize it. My preferred approach is a <a href="https://en.wikipedia.org/wiki/Treemapping">treemap</a>, which you can quickly generate using the <a href="https://www.npmjs.com/package/webtreemap-cli">webtreemap-cli</a> package. Since <code>tsc</code> will spend more time on a large file than a small file, we&#39;ll want to visualize the number of bytes in each file being compiled.</p><p>Here&#39;s the magic incantation (see <a href="https://unix.stackexchange.com/a/22227/139786">here</a> for the &quot;stat&quot; syntax):</p><pre><code># macOS / BSDtsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli# Linux:tsc --noEmit --listFiles | xargs stat -c &quot;%s %n&quot; | npx webtreemap-cli</code></pre><p>For my project, here&#39;s what that looks like:</p><img src="https://effectivetypescript.com/images/googleapis-treemap.png" alt="Treemap visualization showing googleapis contribution 80MB of source" style="max-height: 458px; max-width: 100%" /><p>First off: that&#39;s a <em>lot</em> of code! Over 111 megabytes. With that much source to churn through, it&#39;s no wonder TypeScript has gotten sluggish.</p><p>Second: my project is mostly <code>googleapis</code>? That&#39;s surprising. We do use the Google Cloud Storage API and the Google Sheets API, but that&#39;s it. And yet <code>tsc</code> reports that it&#39;s pulling in 80+ MB of Google APIs, including multiple versions of APIs that I never use (e.g. compute alpha, beta, v1).</p><p>This is exactly the sort of insight that treemaps are good at producing! Before I saw that visualization, I hadn&#39;t thought much about my project&#39;s usage of <code>googleapis</code>. Now I can&#39;t think about anything else!</p><p>The root issue here is that Google distributes all 300+ of its APIs as a single npm package. This has been a <a href="https://github.com/googleapis/google-api-nodejs-client/issues/806">long-standing issue</a> with Google&#39;s Node.js APIs. Fortunately for us, the issue was <a href="https://github.com/googleapis/google-api-nodejs-client/pull/2557">recently fixed</a>! Google now publishes individual packages for each API. Instead of depending on all of <code>googleapis</code>, you can now depend on just <code>@googleapis/sheets</code>.</p><p>After this change, the treemap for my project looks substantially different:</p><img src="https://effectivetypescript.com/images/treemap-after.png" alt="Treemap showing many fewer googleapis" style="max-height: 459px; max-width: 100%"/><p>The most important change is the top-line number: there&#39;s 80MB (70%) less source code for <code>tsc</code> to churn through. It&#39;s interesting to note that many of the large blocks that remain (<code>@octokit</code>, <code>csstype</code>, <code>firestore</code>) have the same problem as <code>googleapis</code>, if less egregiously so: they ship a single giant source file containing every API you could ever depend on.</p><p>Now for the big question… did this make my build faster? At least in this case, the answer is a clear &quot;yes&quot;. I ran:</p><pre><code>time tsc --noEmit --incremental=false</code></pre><p>five times before and after my change. The average time went from 35.7s → 28.9s, a 20% speedup. Not bad! And while it&#39;s harder to measure language service (<code>tsserver</code>) performance, one hopes that this change will help there, too. It&#39;s notable that the 20% speedup doesn&#39;t match the 70% reduction in source code. Just reading all those unused type declarations doesn&#39;t take as much time as type checking the code that is used. Still, this is a nice win.</p><p>Try running the magic command to visualize your TypeScript code as a treemap. You might be surprised what&#39;s making it into your build!</p><pre><code>tsc --noEmit --listFiles | xargs stat -f &quot;%z %N&quot; | npx webtreemap-cli</code></pre><p>In a future post, we&#39;ll look at strategies for reducing how much code you have to import, both as a library author and a consumer.</p>]]></content>
    
    <summary type="html">
    
      Has TypeScript gotten slow for you? Run this one magic command to visualize what TypeScript is compiling, and maybe get to the root of the issue.

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>A new way to test types</title>
    <link href="https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/"/>
    <id>https://effectivetypescript.com/2022/05/28/eslint-plugin-expect-type/</id>
    <published>2022-05-28T21:55:00.000Z</published>
    <updated>2022-05-28T23:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>Readers of <a href="https://amzn.to/3HIrQN6">Effective TypeScript</a> and followers of this blog will know that testing types is a long-standing interest of mine:</p><ul><li><a href="https://github.com/danvk/typings-checker">typings-checker</a> (2017) implemented <code>$ExpectType</code> and <code>$ExpectError</code> directives and helped to influence <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, which is used to test types on DefinitelyTyped.</li><li>I gave a talk at TSConf 2019 entitled <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">Testing Types: An Introduction to dtslint</a>.</li><li>I included Item 52: Be Aware of the Pitfalls of Testing Types in <em>Effective TypeScript</em> (2019)</li><li>I created <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a> (2020) to type check Effective TypeScript and this blog.</li></ul><p>There are many tools out there for testing types, from tricks with <code>tsc</code> to <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>, <a href="https://github.com/SamVerschueren/tsd">tsd</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>. But I can&#39;t say I really love any of them. I&#39;ve always felt like I was writing tests because I should do it, rather than because it was fun and I wanted to.</p><p>When I started working on <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>, I wondered whether there might be a better way. In the years since <em>Effective TypeScript</em> came out, largely thanks to Orta&#39;s advocacy, <a href="https://shikijs.github.io/twoslash/">twoslash</a> has become a widespread standard. You can <a href="https://www.typescriptlang.org/play?#code/MYewdgzgLgBGCuBbCMC8MDaBGANDATHgMx4AsAugNwCwAUKJLAB5pxIQB0ATgKYAm8YDwAUwpngCeASjQA+GCwDUMaTVoB6dTG0wAegH46QA">see this</a> on the TypeScript playground: if you write a twoslash comment (<code>// ^?</code>) then the TypeScript language service&#39;s &quot;quick info&quot; appears next to it:</p><img src="https://effectivetypescript.com/images/twoslash-play.png" title="twoslash comment showing an inferred type on the TypeScript playground" width="364" height="69" /><p>This <a href="https://twitter.com/danvdk/status/1505209336414547968">got me thinking</a>: what if we used this same syntax to do type assertions?</p><p>So rather than <a href="https://github.com/microsoft/DefinitelyTyped-tools/tree/master/packages/dtslint">dtslint</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y); <span class="hljs-comment">// $ExpectType number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure><p>or <a href="https://github.com/SamVerschueren/tsd">tsd</a>&#39;s:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br>expectType&lt;<span class="hljs-built_in">number</span>&gt;(x);<br></code></pre></td></tr></table></figure><p>you could just write a twoslash comment:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = nums.reduce(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> x + y);<br><span class="hljs-comment">//    ^? const x: number</span><br></code></pre></td></tr></table></figure><p>And have something enforce that this comment matched the real Quick Info.</p><p>This has a few nice properties:</p><ol><li>It&#39;s a syntax that&#39;s already widely used.</li><li>It&#39;s unambiguous which symbol the assertion refers to: it&#39;s the one one the caret (<code>^</code>) points at. (This is a source of ambiguity for dtslint and literate-ts.)</li><li>It&#39;s clearly distinct from runtime code and is making an assertion about the <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">display</a> of the type, rather than its structure. (Structural checks will happily let you replace a nice-looking type with something cryptic but equivalent, or even with <code>any</code>.)</li></ol><p>There was an existing eslint plugin, <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type"><code>eslint-plugin-expect-type</code></a>, which did something similar. So I set about <a href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/">adding support for twoslash syntax</a>. One really nice thing came out of this: eslint makes it easy to write and test auto-fixers, so doing type assertions has some of the same feel as Jest&#39;s <a href="https://jestjs.io/docs/snapshot-testing">snapshot testing</a>.</p><p>Here&#39;s a GIF of the autofixing in action:</p><p><img src="https://user-images.githubusercontent.com/98301/162592605-184fe6e5-e069-4a63-aa87-387f4e1b85df.gif" alt="Animation of eslint-plugin-expect-type filling in the correct type assertion"></p><p>More than anything else, this autofixer is what&#39;s made writing type tests fun!</p><p>Here&#39;s an example of a type test from <a href="https://github.com/danvk/crudely-typed">crudely-typed</a>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> typedDb = <span class="hljs-keyword">new</span> TypedSQL(tables);<br><span class="hljs-keyword">const</span> docTable = typedDb.table(<span class="hljs-string">&#x27;doc&#x27;</span>);<br><span class="hljs-keyword">const</span> update = docTable.update(&#123;<span class="hljs-attr">where</span>: [<span class="hljs-string">&#x27;title&#x27;</span>]&#125;);<br><span class="hljs-comment">//    ^? const update: (db: Queryable, where: &#123;</span><br><span class="hljs-comment">//           title: string | null;</span><br><span class="hljs-comment">//       &#125;, update: Partial&lt;Doc&gt;) =&gt; Promise&lt;Doc[]&gt;</span><br><span class="hljs-keyword">const</span> newDoc = <span class="hljs-keyword">await</span> update(<br>    mockDb,<br>    &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Great Expectations&#x27;</span>&#125;,<br>    &#123;<span class="hljs-attr">created_by</span>: <span class="hljs-string">&#x27;Charles Dickens&#x27;</span>&#125;,<br>);<br>newDoc;<br><span class="hljs-comment">// ^? const newDoc: Doc[]</span><br></code></pre></td></tr></table></figure><p>crudely-typed uses <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">many</a> of the <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">fancy types</a> that I&#39;ve <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">written about</a> on this blog. But users of the library should never be aware of any of this chicanery. The types that come out should make sense in the context of the types that go in. They shouldn&#39;t require you to understand the internals of the library. It&#39;s easy to <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">accidentally break</a> this property while refactoring, for example to make the type of <code>newDoc</code> display as something more complicated than <code>Doc[]</code> in the example above. Testing how types <em>display</em> gives you the freedom to refactor without the fear that you&#39;ll inadvertently worsen the experience of your library&#39;s users. And the autofixer makes it a delight to do so!</p><p>If you&#39;re writing a TypeScript library that makes use of any heavy type machinery, I&#39;d highly recommend writing tests with <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type">eslint-plugin-expect-type</a>. You&#39;re using eslint already (you are, aren&#39;t you?) so adding this plugin it doesn&#39;t require new tooling. You can see examples of how to wire it up on <a href="https://github.com/danvk/crudely-typed/pull/18/files#diff-46e9201b2cf8dec2bcf89b7b86965fdbfe1210504118198f3b33b2cb9b94dc27">crudely-typed</a> and <a href="https://github.com/danvk/crosswalk/pull/35">crosswalk</a>.</p>]]></content>
    
    <summary type="html">
    
      Readers of Effective TypeScript and followers of this blog will know that testing types is a long-standing interest of mine. In this post I show how eslint-plugin-expect-type provides new syntax and tooling to make testing types so easy and fun that you&#39;ll &lt;i&gt;want&lt;/i&gt; to do it!

    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>My Twitch Debut (eslint-plugin-expect-type with Josh Goldberg)</title>
    <link href="https://effectivetypescript.com/2022/04/18/twitch-expect-type/"/>
    <id>https://effectivetypescript.com/2022/04/18/twitch-expect-type/</id>
    <published>2022-04-18T16:00:00.000Z</published>
    <updated>2022-05-28T21:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://effectivetypescript.com/images/twitch-screengrab.jpg" title="Screengrab from Twitch" width="320" height="180" style="float: right; margin-left: 10px;">I made my <a href="https://www.twitch.tv/videos/1455722291">Twitch debut</a> last week with <a href="https://twitter.com/JoshuaKGoldberg">Josh Goldberg</a>, who&#39;s writing O&#39;Reilly&#39;s upcoming <a href="https://learning.oreilly.com/library/view/learning-typescript/9781098110321/"><em>Learning TypeScript</em></a> title.</p><p>We talked through a <a href="https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47">recent PR</a> I created to add TwoSlash support for Josh&#39;s expect-type eslint plugin. That syntax looks like this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> four = <span class="hljs-number">4</span>;<br><span class="hljs-comment">//  ^? let four: number</span><br></code></pre></td></tr></table></figure><span id="more"></span><p>The eslint plugin will then check that TypeScript reports <code>let four: number</code> when you get quickinfo for <code>four</code>. This lets you write tests for <a href="https://effectivetypescript.com/2022/02/25/gentips-4-display/">the display of types</a>. The idea is similar to <a href="https://github.com/microsoft/dtslint">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, but with a few key advantages:</p><ol><li>It uses a widely-adopted syntax (TwoSlash is even supported on the TypeScript playground).</li><li>It&#39;s implemented through an eslint plugin, so you don&#39;t need another tool to make type assertions.</li><li>It has an autofixer, which makes this pleasant to use.</li></ol><p>Once the PR is merged, this will be my new preferred way to test types, and I&#39;ll have to update the recommendations from my <a href="https://www.youtube.com/watch?v=nygcFEwOG8w">TSConf 2019 talk</a> as well as Item 52 in <a href="https://amzn.to/3HIrQN6"><em>Effective TypeScript</em></a> (&quot;Be Aware of the Pitfalls of Testing Types&quot;). I&#39;m already using it on my latest open source project, <a href="https://github.com/danvk/crudely-typed/">crudely-typed</a> (more on that soon!).</p><p>I had a great time chatting with Josh, and I think we both learned a thing or two. Hopefully you will, too!</p><!-- Add a placeholder for the Twitch embed --><div id="twitch-embed"></div><!-- Load the Twitch embed script --><script src="https://player.twitch.tv/js/embed/v1.js"></script><!-- Create a Twitch.Player object. This will render within the placeholder div --><script type="text/javascript">  new Twitch.Player("twitch-embed", {    video: "1455722291",    width: 620,    height: 378,    autoplay: false,  });</script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://effectivetypescript.com/images/twitch-screengrab.jpg&quot; title=&quot;Screengrab from Twitch&quot; width=&quot;320&quot; height=&quot;180&quot; style=&quot;float: right; margin-left: 10px;&quot;&gt;I made my &lt;a href=&quot;https://www.twitch.tv/videos/1455722291&quot;&gt;Twitch debut&lt;/a&gt; last week with &lt;a href=&quot;https://twitter.com/JoshuaKGoldberg&quot;&gt;Josh Goldberg&lt;/a&gt;, who&amp;#39;s writing O&amp;#39;Reilly&amp;#39;s upcoming &lt;a href=&quot;https://learning.oreilly.com/library/view/learning-typescript/9781098110321/&quot;&gt;&lt;em&gt;Learning TypeScript&lt;/em&gt;&lt;/a&gt; title.&lt;/p&gt;
&lt;p&gt;We talked through a &lt;a href=&quot;https://github.com/JoshuaKGoldberg/eslint-plugin-expect-type/pull/47&quot;&gt;recent PR&lt;/a&gt; I created to add TwoSlash support for Josh&amp;#39;s expect-type eslint plugin. That syntax looks like this:&lt;/p&gt;
&lt;figure class=&quot;highlight ts&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs ts&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;let&lt;/span&gt; four = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;;&lt;br&gt;&lt;span class=&quot;hljs-comment&quot;&gt;//  ^? let four: number&lt;/span&gt;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>The display of types</title>
    <link href="https://effectivetypescript.com/2022/02/25/gentips-4-display/"/>
    <id>https://effectivetypescript.com/2022/02/25/gentips-4-display/</id>
    <published>2022-02-25T16:00:00.000Z</published>
    <updated>2023-07-09T18:42:18.509Z</updated>
    
    <content type="html"><![CDATA[<p><em>This is part of an ongoing series on tips I learned for working with TypeScript generics from building the <a href="https://github.com/danvk/crosswalk">crosswalk</a> library. Check out <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">part 1</a> for more background.</em></p><ul><li>Part 0: <a href="/2020/08/12/generics-golden-rule/">The Golden Rule of Generics</a></li><li>Part 1: <a href="https://effectivetypescript.com/2020/12/04/gentips-1-curry/">Use Classes and Currying to create new inference sites</a></li><li>Part 2: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a></li><li>Part 3: <a href="https://effectivetypescript.com/2021/01/20/gentips-3-aliases/">Avoid Repeating Type Expressions</a></li><li>Part 4: The display of types</li></ul><p>We talk all the time about how to define and use types in TypeScript, but we rarely talk about how TypeScript chooses to <em>display</em> our types. There are often several possible ways to display the same type, and the choice can have a big impact on the usability of your library. TypeScript tries to make good decisions on its own about type display, but it also gives us a few levers by which we can control it ourselves.</p><p>Let&#39;s dive in to the strange world of type display!</p><!-- more --><p>Suppose you have a <code>Comments</code> table in your database and you&#39;ve defined a <code>selectComments</code> function. As you prepare to call it, TypeScript shows you some type information:</p><img src="https://effectivetypescript.com/images/type-bad.png" width="579" height="98" title="Cryptic type display"><p>This leaves something to be desired. One issue is that it feels a bit &quot;implementation-y&quot;: why should I care that the parameter is constructed using <code>Pick</code> and an intersection (<code>&amp;</code>)? It&#39;s also a bit opaque. Is <code>author_id</code> nullable? What about <code>metadata</code> in the return type? What&#39;s its type? And is <em>it</em> nullable?</p><p>It&#39;s hard to answer these questions without wading through some type declarations or experimenting.</p><p>Here&#39;s an alternative display of exactly the same types:</p><img src="https://effectivetypescript.com/images/type-better.png" width="565" height="94" title="Clearer type display"><p>This is much better. All hints of the metaprogramming that went into deriving this type are gone, and you can see exactly what the type of each field is. <code>author_id</code> is not nullable, but <code>metadata</code> is. The type of <code>metadata</code> is <code>CommentMetadata | null</code>.</p><p>When you&#39;re writing code that works with types, you should consider safety and correctness first and foremost. But once you have those, you should <em>also</em> consider how your types display. The rest of this post walks through some of the techniques that you can use to change how TypeScript displays a type.</p><h2 id="Resolving-a-type"><a href="#Resolving-a-type" class="headerlink" title="Resolving a type"></a>Resolving a type</h2><p>This is the situation described above. TypeScript is showing a generic type expression (often involving <code>Pick</code>) and you&#39;d like it to do a little more work to resolve that type:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;</span>;<br><br><span class="hljs-keyword">const</span> c: Color = &#123; <span class="hljs-attr">r</span>: <span class="hljs-number">255</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">128</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">a</span>: <span class="hljs-number">0.5</span>&#125;;<br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: Pick&lt;Color, &quot;r&quot;&gt;</span><br></code></pre></td></tr></table></figure><p>Here&#39;s the magic incantation:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Resolve&lt;T&gt; = T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Function</span> ? T : &#123;[K <span class="hljs-keyword">in</span> keyof T]: T[K]&#125;;<br></code></pre></td></tr></table></figure><p>(<code>Resolve</code> is my choice of name. This type alias also goes by <code>Simplify</code> or <code>NOP</code> or <code>NOOP</code>.)</p><p>This is an odd-looking type to be sure. Both cases of the conditional type are variations on the identity function. It doesn&#39;t look like it should do anything at all! But our goal isn&#39;t to change the type so much as to change how it&#39;s displayed, and, for whatever reason, this does the trick:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pickChannels</span>&lt;<span class="hljs-title">Chan</span> <span class="hljs-title">extends</span> <span class="hljs-title">keyof</span> <span class="hljs-title">Color</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">    c: Color, chan: Chan</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Resolve</span>&lt;<span class="hljs-title">Pick</span>&lt;<span class="hljs-title">Color</span>, <span class="hljs-title">Chan</span>&gt;&gt;</span>;<br><br><span class="hljs-keyword">const</span> red = pickChannels(c, <span class="hljs-string">&#x27;r&#x27;</span>);<br><span class="hljs-comment">//    ^? const red: &#123; r: number; &#125;</span><br></code></pre></td></tr></table></figure><p>(The conditional type <em>does</em> seem to be necessary: <code>type Resolve&lt;T&gt; = &#123;[K in keyof T]: T[K]&#125;</code> does not resolve this type in the same way.)</p><p>This trick is also helpful in resolving the intersection types like <code>T[K &amp; keyof T]</code> described in part 2 of this series: <a href="https://effectivetypescript.com/2020/12/09/gentips-2-intersect/">Intersect what you have with whatever TypeScript wants</a>. For example, here&#39;s the code from the start of this post:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Select&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>&gt; &#123;<br>  (<br>    where:<br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectComments: Select&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectComments()<br><span class="hljs-comment">// ^? let selectComments: Select</span><br><span class="hljs-comment">//    (where: Pick&lt;Comment, &quot;author_id&quot; | &quot;doc_id&quot;&gt; &amp; &#123;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>The <code>Select</code> function takes a table type and two sets of keys: one containing the columns that have to be set to a specific value and one containing the columns that may be any value in a set. The resulting function call has a parameter with that tell-tale implementation-y look.</p><p>As you&#39;d hope, <code>Resolve</code> makes short work of this:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><br><span class="hljs-keyword">interface</span> SelectResolved&lt;<br>  TableT,<br>  WhereCols <span class="hljs-keyword">extends</span> keyof TableT,<br>  SetCols <span class="hljs-keyword">extends</span> keyof TableT<br>  &gt; &#123;<br>  (<br>    where: Resolve&lt;        <span class="hljs-comment">// &lt;-- Resolve added here</span><br>      Pick&lt;TableT, WhereCols&gt; &amp;<br>      &#123; [K <span class="hljs-keyword">in</span> SetCols]: <span class="hljs-built_in">Set</span>&lt;TableT[K &amp; keyof TableT]&gt; &#125;<br>    &gt;<br>  ): <span class="hljs-built_in">Promise</span>&lt;TableT&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> selectCommentsResolved: SelectResolved&lt;Comment, <span class="hljs-string">&#x27;author_id&#x27;</span> | <span class="hljs-string">&#x27;doc_id&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>&gt;;<br>selectCommentsResolved()<br><span class="hljs-comment">// ^? let selectCommentsResolved: SelectResolved</span><br><span class="hljs-comment">//    (where: &#123;</span><br><span class="hljs-comment">//        author_id: string;</span><br><span class="hljs-comment">//        doc_id: string;</span><br><span class="hljs-comment">//        id: Set&lt;string&gt;;</span><br><span class="hljs-comment">//    &#125;) =&gt; Promise&lt;Comment&gt;</span><br></code></pre></td></tr></table></figure><p>All vestiges of the implementation of this type are gone and we&#39;re left with a clean display. Hooray! (Full example on the <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osE4EWANJ2XBwVXARDe4ol6LFedlnIWavIVCuiIZgAKAjQqtb4rnHYYcHPl+vcAXADJl6v12395MnC5UAAypowAjs2kilOUwDFKKkgAOpCg8HhyIMPZ4H2H5rgKEEKNBkhATASEoSAvaDCumElGUOFMB2oSsAAFJIrByghwCRIxrAPheV7YVB4rwVkwCER2r7sawM7zoucD4YRm5SYoraUVBEnvmR66KRuHZ5KwACU0SnlAWAesACmQe2uSWBoaByDwqBaDEwEjky+BENEQEKKBTkwOK3CnOcUCXJwUjqNsAXecsnDfkwGbuQRVTOXR2m1EUAB645MEAA">playground</a>.)</p><p>The <code>Resolve</code> alias can sometimes resolve <code>keyof</code> expressions. More on this below.</p><p><em>h/t to <a href="https://stackoverflow.com/users/5827215/tadhg-mcdonald-jensen">Tadhg McDonald-Jensen</a> on Stack Overflow for <a href="https://stackoverflow.com/a/69976234/388951">introducing</a> me to this helpful type alias!</em></p><h2 id="Special-casing-important-types"><a href="#Special-casing-important-types" class="headerlink" title="Special-casing important types"></a>Special-casing important types</h2><p>Sometimes the display of a type is bad for a specific, important case of your generic. In these situations it can be worthwhile to handle those cases specially using a conditional type.</p><p>For example, say you have a function that can either select all the columns from a table or just a few specific columns:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Pick&lt;TableT, Cols&gt;;<br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br></code></pre></td></tr></table></figure><p>It makes sense that the <code>Cols</code> type parameter defaults to <code>keyof TableT</code> since that corresponds to selecting all the columns and <code>Pick&lt;T, keyof T&gt; = T</code>.</p><p>The type <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMSZOFyoADKmmAaBgAHlcMAADylcrAYrijxyQagXmiQaq4CIb09hTFRhwCdTgUzvsAPkWrFYAAo5UKHtFgntrodjDkAJTRAAKAjQqu7ZVnA4gQ9XuUsGjQch4qC0cGMiiZfAACFEAASSuRsFBbdsu0AmBX0sDBzXgbN4AYP8AKqYCwNELdDyuTgAEYACYAGZOHPCxCk3OAAD0AH4gA">doesn&#39;t display very cleanly</a> when we use the function, though:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Pick&lt;Comment, keyof Comment&gt;</span><br></code></pre></td></tr></table></figure><p>This is cryptic and quite implementation-y. And the <code>Resolve</code> trick doesn&#39;t quite do what we want here:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>    (where: &#123;<span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>&#125;): Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- Resolve</span><br>&#125;<br><br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: &#123;id: string; doc_id: string; author_id: string, ...&#125;</span><br></code></pre></td></tr></table></figure><p><code>Resolve</code> has fully inlined this type. What it&#39;s displaying is exactly equivalent to <code>Comment</code>, but that&#39;s hard to tell without a careful comparison. It would be much nicer if it just said <code>Comment</code>!</p><p>You can improve the display here by explicitly checking for the default case:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> SelectOne&lt;TableT, Cols <span class="hljs-keyword">extends</span> keyof TableT = keyof TableT&gt; &#123;<br>  (where: &#123; <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span> &#125;):<br>    keyof TableT <span class="hljs-keyword">extends</span> Cols       <span class="hljs-comment">// &lt;-- conditional type</span><br>    ? TableT                        <span class="hljs-comment">// &lt;-- special case</span><br>    : Resolve&lt;Pick&lt;TableT, Cols&gt;&gt;;  <span class="hljs-comment">// &lt;-- default case</span><br>&#125;<br><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> getCommentById: SelectOne&lt;Comment&gt;;<br><br><span class="hljs-keyword">const</span> comment = getCommentById(&#123;<span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;);<br><span class="hljs-comment">//    ^? const comment: Comment</span><br></code></pre></td></tr></table></figure><p>Much better! Here&#39;s a <a href="https://www.typescriptlang.org/play?#code/KYDwDg9gTgLgBDAnmYcDGEC2ngDsYD6AzjAIYwCuRBeFmcAvAFBxwA+cA5KVGgBYBLAG7AAJpxbsuGTGAA2wGMAmsOnUcAVLxktSlyiBuAOacA3EyahIsOEaVQAZqTSoAwlhz4AsotKjyUjgAb0lHCAgALjgSKCNjC1YAIx5o3Dok4CgLAF9LAHp8uAAVUiSFdE88GCZ8gCo6uAA1HgFSfABaBRE5Suxqojg6-KtwaHh7LOdXOA9+-BDJAVFo2PjEuFEINAJl1Zg4kw3SChg+aF2VmIP1yTQoYHIxAnJogBEnqXS5OQ3MCEMjgEz1ecA+Si+FB+G3qjQAgqJDDABBBcKRejIvBNcOE4AABJAoEJzLG+MgBMg5IYjVg4cmBaIk6pk-yBSHQySw2aopQLCCOBB8VCY6oAGjg4SgmHI2jgAHcBGc4N4eABrLZy3AAOmVpEQlXwpCM+KxKNwRB1wzuPOqBEwVzWR05DTgABkBCQ4PzruQqMAiGY4AApKjwdpwHhQPUS6AIf3IkwAQmpkhIvqI-uiIvwxDIlGotEwAG0ALrs35MPJMQmoABK-ogchEAB5igA+RglOCgXmiQYAMQouDQyNRcAA-F3osEiwBpOy4OCq4CIb3FEvRYpzks5CxMSZOFyoADKmmAI4A8rhgK2ygpiuKPHJBj28H2lyu13fgMVO8vVwKpTlD+HahKwrAABRykKDzTns1yHMYOQAJTRP+X7Ab+r4GIMT6DJOQH3nA0T1kQjYtgACgIaCqremGPo2RBtm2uSWBoaByDwqBaHAxiKEy+AAEKIAAklcp4KJe17NgJMAsZYGDmvA2bwAwvH8VUQmiaIEHBPBnAAIwAEwAMycChFiFOBcAAHrjmx56cQ8cA8XxMCyXh0QSeeMBXjesnipwyycFI6jbJcIVqHSrJkJF0g2jm9qcPJimeipx4oGgAhAmgeGdm5HmMbp+nGWZFm1EU4F2UwQA">full playground</a> for this example.</p><h2 id="Other-techniques-that-don-39-t-work-as-well"><a href="#Other-techniques-that-don-39-t-work-as-well" class="headerlink" title="Other techniques that don&#39;t work as well"></a>Other techniques that don&#39;t work as well</h2><p>There are a few other techniques I&#39;ve run across for simplifying type display that don&#39;t work as well as <code>Resolve</code>. They&#39;re included here for completeness. If you&#39;re using them, you may as well just use <code>Resolve</code> instead.</p><h3 id="Exclude-lt-keyof-T-never-gt"><a href="#Exclude-lt-keyof-T-never-gt" class="headerlink" title="Exclude&lt;keyof T, never&gt;"></a><code>Exclude&lt;keyof T, never&gt;</code></h3><p>This can be used to inline the display of <code>keyof</code>:</p><figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Color &#123; r: <span class="hljs-built_in">number</span>; g: <span class="hljs-built_in">number</span>; b: <span class="hljs-built_in">number</span>; a: <span class="hljs-built_in">number</span> &#125;;<br><span class="hljs-keyword">type</span> Chan = keyof Color;<br><span class="hljs-comment">//   ^? type Chan = keyof Color</span><br><span class="hljs-keyword">type</span> ChanInline = Exclude&lt;keyof Color, <span class="hljs-built_in">never</span>&gt;;<br><span class="hljs-comment">//   ^? type ChanInline = &quot;r&quot; | &quot;g&quot; | &quot;b&quot; | &quot;a&quot;;</span><br></code></pre></td></tr></table></figure><p>The <code>Resolve</code> trick <a href="https://www.typescriptlang.org/play?#code/JYOwLgpgTgZghgYwgAgMIHsA26rIN7JQBcyIArgLYBG0A3MgOYnnV3JXOU1T1yeu4AvrQBQIsAE8ADigBKEAM5YAbhAA8AFQB8yALzINyCAA9IIACYLkAMTIgEYYOhDIA-AeQk8AbQDSyUGQAawgJdBgDAF0SDT9I4XFpFFQACzgXfXklTFU1ELCIjGwoLVEAejLkKoA9d0kZNDSM5AAiKBbkAB9Whg7ulqo+1rgWsQRnBTBkBBIinD18QhIAJgBWVYAaRhIARmWADi2OZAAGLb5TgDpVhPMIBEw4KBQYOwcnFwYIMFT0kAhMAAKGZoLA4LYIJokLIqdT5cKg4paACU-G4ojGEymuH0Xx+TX+QIQGzEFWQAAUyFMwmRcAhaUpcHApmAUigIBZkAjWSgpM9lE4yFZMKAUOlzMgaQByTCYZAKCAQIgiMl434gQnA2ZgqAQqHBUIIuZQVGkLjQFVlS3IADubOecCsAEkpRKRSFkGB0PLFcrVd91ZqQca9ekSG0hi1el1WoMYy0RqaWNwREA">works just as well</a> in this case, and can resolve many types that excluding <code>never</code> cannot. So just use <code>Resolve</code>.</p><p>Side note: why does TypeScript display <code>keyof</code> types in this way? Prior to <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">TypeScript 4.2</a>, TypeScript <em>always</em> inlined <code>keyof</code> display. This sometimes led to comical results:</p><img src="https://effectivetypescript.com/images/keyof-button.png" width="907" height="78" title="keyof HTMLButtonElement showing a union of 260 string literal types"><p>Count &#39;em, that&#39;s a union of 260 string literal types! Newer versions of TypeScript simply display this as <code>keyof HTMLButtonElement</code>, which seems like a win. But I think they <a href="https://github.com/microsoft/TypeScript/issues/42322">threw the baby out with the bathwater</a> here; for the common case of small unions (say less than 10 strings), it&#39;s clearer to <a href="https://twitter.com/danvdk/status/1414343269522227207">just show the type union</a>. This makes the behavior of <code>keyof</code> much easier to understand. Perhaps someday this will improve and we won&#39;t need to <code>Resolve</code> this type.</p><h3 id="unknown-amp-T"><a href="#unknown-amp-T" class="headerlink" title="unknown &amp; T"></a><code>unknown &amp; T</code></h3><p>I learned about this one from Titian&#39;s <a href="https://stackoverflow.com/a/56416192/388951">classic answer about typing <code>_.invert</code></a> on Stack Overflow. Sometimes you can replace <code>TypeExpr</code> with <code>&#123;&#125; &amp; TypeExpr</code> or <code>unknown &amp; TypeExpr</code> to force TypeScript to resolve a type.</p><p>You can see an example of this technique working in <a href="https://www.typescriptlang.org/play?#code/PTAEBUEsBdIQwHYHIDOpoE8AOBTNAzAJwHsBbUAC2mixQC4QVo4BjAa2IDcdD8AbYgHcAdCzLA4wAKwA2ACwBGGQoCcAJmABmABzaVUhQChMuUAEE+fAGpw+AVzwAecKBwAPaDgQATNACUcMUJvRwAFElxCTABpHAwAGlBw4kiYuIA+dNAAXlAAb0NQItAAbVDQSARQNjjifAgAXTp86rjm0MTOWwdm8DKG0ABfQ0GSmow6xoBuY2wcUABJBG4ogJQ7PmhnVw8vX1AAoJDk1IxYhKSInjSMTJz8wuKyiqqLa26ncHSSpC77HCQDSaoAAoh5CKwtm8bP8UM50ok8qA-j0kkNvkhxoCZoMZoYxAgmKBiPcCsVQHBmkg3Eh4o8igAjKkYWkjCloAlMPEmeYuXJLFbQNYbLY8ybEdIzEBFAB6AH5DLNTALrsLNgAhHDUHjbdyeHz+QLEYJhK5RM5xRIna4W25ZXJ2BBsBBCKoAMge5OelXMlhhDjhXx+KIBQOaYOgEJYUL9H0DCJaIfa6J+WIaOLx3kCfDghHm+Ed0cgxCqlUFut2BoORpN1vN5ytZpumQAFMQGQArXoASmaKtWeBF8JmWZYObzoALCCLJZegs12sIFf1+0OxuOTdtjZSNvOrfbXYgvcWy1Vg41Ws8S6+I+zufzhdgs7LZ5QxD43BCLj1e0NR1NO71palyAc26Rtp2PbNGs77cI4-ZCueWxfJKirSuAFCQGgFBwGgiCgAARJApBYHwOCkF4zBPggGAEegcygN4WGkXAGDCKAADqOHQKgJ6Cmq0AKpy0BzvcL5RG23ZSmAxTymhYBmN4TEIAA5hSoCCDglgALQsSwODeKAAAGjrOq6oBukZoCkHANRoDAjHMTmGDWca8xjjgiB8BgdD4iWRJlmoYmnlEC5XpJ0nknJhjSmY1Zvh+OCOFkrCYTg3BoNAFDzCgcAUaAebrJsvnCXOmjBfxeCwQZEUxTJsoKvJECYfZeFVLYV4IHAsDcBUJFkRRCBUcWVQoBQQiVGpWXzN4EKCAyrBsGgkwmU6LqCO6Vn4O+AiCJNdWUNQtAMMAOD4PggQ9VqcwoCwhCQFg0CiOIagAAxvcAr1SMACgaI6I2QAAXjg2kHpdkD4BgwCKjyoAAKoIADwPLr+xKdpd9qeqUbAvK0Ez1OAwJ5GwzRsFMyK9GMDTDKM4yTIT3IMdEVihHAkCEKSJMgac5zk5wzSmetCDDLDADy6NFpDKNVszrPs5jZLY7jfSYoCwIRlGyGIlzbCDBinCAiMjOmAAyoIcBYMz8I5I836VvsxPNJUF0c9EnROwgLugFYwxFHK+Rc1YfPNNE5ODEU0qONp2mgC6njoNloAoObWAAISPM0CDpTwxvzDBiXW7kdsrmgABij4jaA-suM0eQlNEuN0wTwJ9NE1MzLDCFw6L0v7GD0aY+LHbg1LZsW1bCNI0lKEWaAsts4QqFKvMXei-nn698tEvQJj69JUPI8YI4Y+W1YjiTyWQPT3cHrz-LS+juOD7TtRc7XN3m-Vv+dY3NuPMZOBA8UE+Lvx7jeQwj97yTgrs+EK0Bu57y-DsEuX91wAX-hcH+tp9yQSPH2OBCCqqJS-EvdCLUKR8DfJQXCFIqhEX6uRSi3URq0XoqYJiKAWI+T8oSESZY4YklyOJeBotarSlko1aUe9kqTkgG4PAFRoCJAZHYESEw7CgBYIgJAIk4BKWMoLcyllaEYEENlCc0ASTeBJDAYQPCArLAEUFIRBC15EM-GI+qoA5JAA">this playground</a>. I&#39;ll spare you the full details, but from hard-earned experience I&#39;ve learned that this trick is much more finnicky than <code>Resolve</code>. Just use <code>Resolve</code> instead.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>While it may seem that you&#39;re stuck with however TypeScript chooses to display your type, that&#39;s not actually the case! You do have a few levers at your disposal. The <code>Resolve</code> alias is wonderful for removing implementation details from generic types. And where it doesn&#39;t work, you can sometimes add a special case to get the display that you want.</p><p>Remember that <a href="https://twitter.com/SeaRyanC/status/1414347018646921216">all representations are equally valid</a>, and that the TypeScript team might choose to change the display of your type at any time (as <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-4-2.html#smarter-type-alias-preservation">happened</a> with <code>keyof</code> in TypeScript 4.2). So once you&#39;ve got your types displaying the way you like, it&#39;s worth writing some tests to make sure they stay that way. Tools like <a href="https://medium.com/hackernoon/testing-types-an-introduction-to-dtslint-b178f9b18ac8">dtslint</a> and <a href="https://effectivetypescript.com/2020/06/30/literate-ts/">literate-ts</a>, which make assertions about the textual display of types, are the way to go here.</p><p>Do you have other tricks for controlling type display? Let me know <a href="https://twitter.com/danvdk">on Twitter</a> or in the comments below.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;We talk all the time about how to define and use types in TypeScript, but we
rarely talk about how TypeScript chooses to &lt;i&gt;display&lt;/i&gt; our types. There
are often several possible ways to display the same type, and the choice can
have a big impact on the usability of your library. TypeScript tries to make
good decisions on its own about type display, but it also gives us a few very
obscure levers by which we can control it ourselves.&lt;/p&gt;
&lt;p&gt;Let&#39;s dive in to the strange world of type display!&lt;/p&gt;

    
    </summary>
    
    
    
  </entry>
  
</feed>
