<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>The trouble with Jsonify: Unify types instead of modeling small differences</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta name="twitter:description" content="Last year I wrote about Jsonify, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with Jsonify and 2) It&#39;s a bad idea!
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta property="og:description" content="Last year I wrote about Jsonify, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with Jsonify and 2) It&#39;s a bad idea!
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>The trouble with Jsonify: Unify types instead of modeling small differences</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2021-04-09T13:45:00.000Z" itemprop="datePublished">
              Fri 09 April 2021
            </time>
          </div>
          <div class="entry-content">
            <!-- Alternate title: the trouble with Jsonify -->

<p>Last year I wrote about <a href="/2020/04/09/jsonify/"><code>Jsonify</code></a>, a generic that models how a type changes as it goes through JSON serialization and deserialization. This is especially relevant for JavaScript <code>Date</code>s, which get converted to strings in this process:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; JSON.parse(JSON.stringify(d))<br>&#39;2021-04-07T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure>

<p>If you use a type on your server, <code>Jsonify</code> tells you what that type will look like on your client:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <a href="/2020/04/09/jsonify/">original post</a> generated some <a target="_blank" rel="noopener" href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">strong</a> <a target="_blank" rel="noopener" href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">reactions</a>. Since I posted it, I&#39;ve learned two things:</p>
<p>First, <strong>I didn&#39;t come up with this.</strong> In fact, Anders presented it at <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s', event);">his keynote</a> at the original TSConf, in 2018. He, in turn, based it on <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545', event);">discussion</a> on GitHub. What&#39;s surprising is that <em>I was at that talk</em>! But it must have gone in one ear and out the other. In any case, <code>Jsonify</code> became much more compelling once TypeScript 3.7 introduced <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases', event);">recursive type aliases</a> in Nov. 2019.</p>
<p>Second, I&#39;ve learned that <strong><code>Jsonify</code> isn&#39;t a good idea</strong>.</p>
<p>Why not? While it&#39;s neat that you can model a transformation like this in the type system, it wound up being quite annoying when my team put it into practice.</p>
<p>For example, if you have an API on the server that produces a <code>Student</code>, then your client-side code should work in terms of <code>Jsonify&lt;Student&gt;</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>As you pass the <code>student</code> object around your application, you&#39;ll get long error messages any time you forget the <code>Jsonify</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);<br>  <span class="hljs-comment">//             ~~~~~~~</span><br>  <span class="hljs-comment">// Argument of type &#x27;&#123; id: number; name: string; birthday: string | null; &#125;&#x27; is not assignable to parameter of type &#x27;Student&#x27;.</span><br>  <span class="hljs-comment">//   Types of property &#x27;birthday&#x27; are incompatible.</span><br>  <span class="hljs-comment">//     Type &#x27;string | null&#x27; is not assignable to type &#x27;Date | null&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;string&#x27; is not assignable to type &#x27;Date | null&#x27;. (2345)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Nothing about this error says &quot;you forgot <code>Jsonify</code>.&quot; We just had to learn &quot;any time you see something about <code>Date</code> and <code>string</code>, it means you forgot a <code>Jsonify</code> somewhere.&quot; In more realistic code, there can be many <code>Date</code> objects that are deeply nested, leading to even longer, more confusing errors. These <code>Date</code> fields typically weren&#39;t used by the function producing the error, so we weren&#39;t even gaining safety for our trouble.</p>
<p>After battling <code>Jsonify</code> for a few months, we decided to get rid of it by eliminating <code>Date</code>s from our API. Most of these were coming from our database. By default, <code>node-postgres</code> <a target="_blank" rel="noopener" href="https://node-postgres.com/features/types#date--timestamp--timestamptz" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://node-postgres.com/features/types#date--timestamp--timestamptz', event);">converts Postgres date/timestamp columns</a> to <code>Date</code> objects. This makes a lot of sense as a default. But to keep our server and and client types equal, we decided to just use strings instead.</p>
<p>To make this work, we had to reconfigure the types returned by node-postgres:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;types&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br>types.setTypeParser(types.builtins.DATE, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMPTZ, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMP, _.identity);<br></code></pre></td></tr></table></figure>

<p>We use <a target="_blank" rel="noopener" href="https://github.com/danvk/pg-to-ts" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/danvk/pg-to-ts', event);"><code>pg-to-ts</code></a> (a fork of <a target="_blank" rel="noopener" href="https://github.com/PSYT/schemats" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/PSYT/schemats', event);"><code>schemats</code></a>) to generate types from our database schema (which we consider a source of truth). So we had to <a target="_blank" rel="noopener" href="https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c', event);">adapt it</a> with a <code>--datesAsStrings</code> flag.</p>
<p>With these changes in place, our API types were fully unified: they were exactly the same on the server and the client:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Used to be Date | null</span><br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Student&gt;;  <span class="hljs-comment">// exactly the same!</span><br></code></pre></td></tr></table></figure>

<p>So we could drop <code>Jsonify</code>! Now we could write code like this error-free:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);  <span class="hljs-comment">// ok!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The lesson here is that <strong>you should prefer to unify your types rather than model small differences between them.</strong> By unifying your types, you&#39;ll save all the time and effort you would have spent getting the transformations exactly correct and applied in exactly the right places.</p>
<p>As another example, it&#39;s common to have <code>snake_case</code> column names in your database and convert them to <code>camelCase</code> for JS/TS variable names and types in your API:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> StudentTable &#123;<br>  first_name: <span class="hljs-built_in">string</span>;<br>  last_name: <span class="hljs-built_in">string</span>;<br>  birth_date: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  firstName: <span class="hljs-built_in">string</span>;<br>  lastName: <span class="hljs-built_in">string</span>;<br>  birthDate: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>As I discussed in my <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> post, <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types', event);">as of TypeScript 4.1</a> you can model this snake_case → camelCase transformation in the type system. But should you? Following the mantra of &quot;unify rather than model small differences,&quot; clearly you should not! In this case you could either use <code>snake_case</code> names in your API or use a tool like <a target="_blank" rel="noopener" href="https://github.com/hoegaarden/pg-camelcase" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/hoegaarden/pg-camelcase', event);">pg-camelcase</a> to convert the <code>snake_case</code> names to <code>camelCase</code> as you load them from the database (you can do something similar with <a target="_blank" rel="noopener" href="http://knexjs.org/#Installation-wrap-identifier" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'http://knexjs.org/#Installation-wrap-identifier', event);">knex</a>). In either case, you&#39;ll be able to forget about the type transformations entirely.</p>
<p>Of course, any rule comes with caveats.</p>
<p>First, this isn&#39;t always an option. You may need the two types if the database and the API aren&#39;t under your control. If this is the case, then modeling these sorts of differences systematically in the type system will help you find bugs in your transformation code. It&#39;s better than creating types ad-hoc and hoping they stay in sync.</p>
<p>Second, don&#39;t unify types that aren&#39;t representing the same thing! Say you have a tagged union, for example:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseSuccess &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span>;<br>  payload: PayloadType;<br>&#125;<br><span class="hljs-keyword">interface</span> ResponseError &#123;<br>  status: <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  error: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Response = ResponseSuccess | ResponseError;<br></code></pre></td></tr></table></figure>

<p>It would be counterproductive to &quot;unify&quot; these types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don&#x27;t do this!</span><br><span class="hljs-keyword">interface</span> Response &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span> | <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  payload?: PayloadType;<br>  error?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This will make TypeScript less effective at finding bugs in your <code>Response</code>-handling code. The two <code>Response</code> types are fundamentally different, so they should not be unified. This rule is best applied to types that are fundamentally the same but superficially different.</p>
<p>If you find yourself creating lots of types that are only slightly different from one another, consider unifying them. You&#39;ll be happy you did!</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="💬 blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('post learn more hover', 'https://amzn.to/3HIrQN6', event);">Buy the Book</a>
        <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" class="btn btn-info btn-lg hidden-xs" onclick="return trackOutboundLink('post learn more hover', 'https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1', event);">Buy eBook</a>
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript’s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more »</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
