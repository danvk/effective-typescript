<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>The trouble with Jsonify: Unify types instead of modeling small differences</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta name="twitter:description" content="Last year I wrote about Jsonify, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with Jsonify and 2) It&#39;s a bad idea!
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; The trouble with Jsonify: Unify types instead of modeling small differences">
    <meta property="og:description" content="Last year I wrote about Jsonify, a generic that models how a type changes as it goes through JSON serialization and deserialization. Since then I&#39;ve learned two important things: 1) I didn&#39;t come up with Jsonify and 2) It&#39;s a bad idea!
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>The trouble with Jsonify: Unify types instead of modeling small differences</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2021-04-09T13:45:00.000Z" itemprop="datePublished">
              Fri 09 April 2021
            </time>
          </div>
          <div class="entry-content">
            <!-- Alternate title: the trouble with Jsonify -->

<p>Last year I wrote about <a href="/2020/04/09/jsonify/"><code>Jsonify</code></a>, a generic that models how a type changes as it goes through JSON serialization and deserialization. This is especially relevant for JavaScript <code>Date</code>s, which get converted to strings in this process:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; d &#x3D; new Date();<br>&gt; JSON.parse(JSON.stringify(d))<br>&#39;2021-04-07T01:07:48.835Z&#39;<br></code></pre></td></tr></table></figure>

<p>If you use a type on your server, <code>Jsonify</code> tells you what that type will look like on your client:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">type</span> T1 = Jsonify&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <a href="/2020/04/09/jsonify/">original post</a> generated some <a target="_blank" rel="noopener" href="https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.reddit.com/r/programming/comments/fzbb45/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">strong</a> <a target="_blank" rel="noopener" href="https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.reddit.com/r/typescript/comments/fxub0f/if_x_has_a_type_of_t_then_whats_the_type_of/', event);">reactions</a>. Since I posted it, I&#39;ve learned two things:</p>
<p>First, <strong>I didn&#39;t come up with this.</strong> In fact, Anders presented it at <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.youtube.com/watch?v=wpgKd-rwnMw&t=2550s', event);">his keynote</a> at the original TSConf, in 2018. He, in turn, based it on <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/microsoft/TypeScript/pull/21496#issuecomment-363449545', event);">discussion</a> on GitHub. What&#39;s surprising is that <em>I was at that talk</em>! But it must have gone in one ear and out the other. In any case, <code>Jsonify</code> became much more compelling once TypeScript 3.7 introduced <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#more-recursive-type-aliases', event);">recursive type aliases</a> in Nov. 2019.</p>
<p>Second, I&#39;ve learned that <strong><code>Jsonify</code> isn&#39;t a good idea</strong>.</p>
<p>Why not? While it&#39;s neat that you can model a transformation like this in the type system, it wound up being quite annoying when my team put it into practice.</p>
<p>For example, if you have an API on the server that produces a <code>Student</code>, then your client-side code should work in terms of <code>Jsonify&lt;Student&gt;</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">Student</span>&gt;&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>As you pass the <code>student</code> object around your application, you&#39;ll get long error messages any time you forget the <code>Jsonify</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);<br>  <span class="hljs-comment">//             ~~~~~~~</span><br>  <span class="hljs-comment">// Argument of type &#x27;&#123; id: number; name: string; birthday: string | null; &#125;&#x27; is not assignable to parameter of type &#x27;Student&#x27;.</span><br>  <span class="hljs-comment">//   Types of property &#x27;birthday&#x27; are incompatible.</span><br>  <span class="hljs-comment">//     Type &#x27;string | null&#x27; is not assignable to type &#x27;Date | null&#x27;.</span><br>  <span class="hljs-comment">//       Type &#x27;string&#x27; is not assignable to type &#x27;Date | null&#x27;. (2345)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Nothing about this error says &quot;you forgot <code>Jsonify</code>.&quot; We just had to learn &quot;any time you see something about <code>Date</code> and <code>string</code>, it means you forgot a <code>Jsonify</code> somewhere.&quot; In more realistic code, there can be many <code>Date</code> objects that are deeply nested, leading to even longer, more confusing errors. These <code>Date</code> fields typically weren&#39;t used by the function producing the error, so we weren&#39;t even gaining safety for our trouble.</p>
<p>After battling <code>Jsonify</code> for a few months, we decided to get rid of it by eliminating <code>Date</code>s from our API. Most of these were coming from our database. By default, <code>node-postgres</code> <a target="_blank" rel="noopener" href="https://node-postgres.com/features/types#date--timestamp--timestamptz" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://node-postgres.com/features/types#date--timestamp--timestamptz', event);">converts Postgres date/timestamp columns</a> to <code>Date</code> objects. This makes a lot of sense as a default. But to keep our server and and client types equal, we decided to just use strings instead.</p>
<p>To make this work, we had to reconfigure the types returned by node-postgres:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;types&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;pg&#x27;</span>;<br><br>types.setTypeParser(types.builtins.DATE, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMPTZ, _.identity);<br>types.setTypeParser(types.builtins.TIMESTAMP, _.identity);<br></code></pre></td></tr></table></figure>

<p>We use <a target="_blank" rel="noopener" href="https://github.com/danvk/pg-to-ts" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/danvk/pg-to-ts', event);"><code>pg-to-ts</code></a> (a fork of <a target="_blank" rel="noopener" href="https://github.com/PSYT/schemats" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/PSYT/schemats', event);"><code>schemats</code></a>) to generate types from our database schema (which we consider a source of truth). So we had to <a target="_blank" rel="noopener" href="https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/danvk/pg-to-ts/commit/7f3f5e9e059a983ce861fa88d24074abf945123c', event);">adapt it</a> with a <code>--datesAsStrings</code> flag.</p>
<p>With these changes in place, our API types were fully unified: they were exactly the same on the server and the client:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">string</span> | <span class="hljs-literal">null</span>;  <span class="hljs-comment">// Used to be Date | null</span><br>&#125;<br><span class="hljs-keyword">type</span> T = Jsonify&lt;Student&gt;;  <span class="hljs-comment">// exactly the same!</span><br></code></pre></td></tr></table></figure>

<p>So we could drop <code>Jsonify</code>! Now we could write code like this error-free:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudent</span>(<span class="hljs-params">studentId: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">Promise</span>&lt;<span class="hljs-title">Student</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">displayStudent</span>(<span class="hljs-params">student: Student</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123;id, name, birthday&#125; = student;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;id&#125;</span>: <span class="hljs-subst">$&#123;name&#125;</span> <span class="hljs-subst">$&#123;birthday&#125;</span>`</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderStudent</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> student = <span class="hljs-keyword">await</span> getStudent(<span class="hljs-string">&#x27;123&#x27;</span>);<br>  displayStudent(student);  <span class="hljs-comment">// ok!</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The lesson here is that <strong>you should prefer to unify your types rather than model small differences between them.</strong> By unifying your types, you&#39;ll save all the time and effort you would have spent getting the transformations exactly correct and applied in exactly the right places.</p>
<p>As another example, it&#39;s common to have <code>snake_case</code> column names in your database and convert them to <code>camelCase</code> for JS/TS variable names and types in your API:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> StudentTable &#123;<br>  first_name: <span class="hljs-built_in">string</span>;<br>  last_name: <span class="hljs-built_in">string</span>;<br>  birth_date: <span class="hljs-built_in">string</span>;<br>&#125;<br><br><span class="hljs-keyword">interface</span> Student &#123;<br>  firstName: <span class="hljs-built_in">string</span>;<br>  lastName: <span class="hljs-built_in">string</span>;<br>  birthDate: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>As I discussed in my <a href="https://effectivetypescript.com/2020/11/05/template-literal-types/">TypeScript Splits the Atom</a> post, <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://devblogs.microsoft.com/typescript/announcing-typescript-4-1/#template-literal-types', event);">as of TypeScript 4.1</a> you can model this snake_case â†’ camelCase transformation in the type system. But should you? Following the mantra of &quot;unify rather than model small differences,&quot; clearly you should not! In this case you could either use <code>snake_case</code> names in your API or use a tool like <a target="_blank" rel="noopener" href="https://github.com/hoegaarden/pg-camelcase" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://github.com/hoegaarden/pg-camelcase', event);">pg-camelcase</a> to convert the <code>snake_case</code> names to <code>camelCase</code> as you load them from the database (you can do something similar with <a target="_blank" rel="noopener" href="http://knexjs.org/#Installation-wrap-identifier" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'http://knexjs.org/#Installation-wrap-identifier', event);">knex</a>). In either case, you&#39;ll be able to forget about the type transformations entirely.</p>
<p>Of course, any rule comes with caveats.</p>
<p>First, this isn&#39;t always an option. You may need the two types if the database and the API aren&#39;t under your control. If this is the case, then modeling these sorts of differences systematically in the type system will help you find bugs in your transformation code. It&#39;s better than creating types ad-hoc and hoping they stay in sync.</p>
<p>Second, don&#39;t unify types that aren&#39;t representing the same thing! Say you have a tagged union, for example:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ResponseSuccess &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span>;<br>  payload: PayloadType;<br>&#125;<br><span class="hljs-keyword">interface</span> ResponseError &#123;<br>  status: <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  error: <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Response = ResponseSuccess | ResponseError;<br></code></pre></td></tr></table></figure>

<p>It would be counterproductive to &quot;unify&quot; these types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// Don&#x27;t do this!</span><br><span class="hljs-keyword">interface</span> Response &#123;<br>  status: <span class="hljs-string">&#x27;ok&#x27;</span> | <span class="hljs-string">&#x27;failed&#x27;</span>;<br>  payload?: PayloadType;<br>  error?: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This will make TypeScript less effective at finding bugs in your <code>Response</code>-handling code. The two <code>Response</code> types are fundamentally different, so they should not be unified. This rule is best applied to types that are fundamentally the same but superficially different.</p>
<p>If you find yourself creating lots of types that are only slightly different from one another, consider unifying them. You&#39;ll be happy you did!</p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="ðŸ’¬ blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('post learn more hover', 'https://amzn.to/3HIrQN6', event);">Buy the Book</a>
        <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" class="btn btn-info btn-lg hidden-xs" onclick="return trackOutboundLink('post learn more hover', 'https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1', event);">Buy eBook</a>
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScriptâ€™s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more Â»</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('the trouble with jsonify unify types instead of modeling small differences', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
