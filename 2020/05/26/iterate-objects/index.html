<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Item 54: Know How to Iterate Over Objects</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: Item 54: Know How to Iterate Over Objects">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; Item 54: Know How to Iterate Over Objects">
    <meta name="twitter:description" content="Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. This item explains why the types you get from Object.keys or a for-in loop aren&#39;t quite what you&#39;d expect, and what your available workarounds are.
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; Item 54: Know How to Iterate Over Objects">
    <meta property="og:description" content="Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. This item explains why the types you get from Object.keys or a for-in loop aren&#39;t quite what you&#39;d expect, and what your available workarounds are.
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>Item 54: Know How to Iterate Over Objects</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2020-05-26T13:30:45.000Z" itemprop="datePublished">
              Tue 26 May 2020
            </time>
          </div>
          <div class="entry-content">
            <p><em>Iterating over the keys and values in an object is a common operation that&#39;s surprisingly hard to write without type assertions in TypeScript. The difficulty results from a combination of the <a target="_blank" rel="noopener" href="https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c" onclick="return trackOutboundLink('item  know how to iterate over objects', 'https://medium.com/node-modules/what-is-prototype-pollution-and-why-is-it-such-a-big-deal-2dd8d89a93c', event);">quirks</a> of JavaScript objects and <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/interfaces.html" onclick="return trackOutboundLink('item  know how to iterate over objects', 'https://www.typescriptlang.org/docs/handbook/interfaces.html', event);">duck typing</a>. Reading through this item again, I&#39;d add that this is all a good reason to consider using an <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map" onclick="return trackOutboundLink('item  know how to iterate over objects', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map', event);">ES6 <code>Map</code></a> instead of an object to store key/value pairs!</em></p>
<p>This code runs fine, and yet TypeScript flags an error in it. Why?</p>
<!-- #one-two-three -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<br>  one: <span class="hljs-string">&#x27;uno&#x27;</span>,<br>  two: <span class="hljs-string">&#x27;dos&#x27;</span>,<br>  three: <span class="hljs-string">&#x27;tres&#x27;</span>,<br>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];<br>         <span class="hljs-comment">// ~~~~~~ Element implicitly has an &#x27;any&#x27; type</span><br>         <span class="hljs-comment">//        because type ... has no index signature</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>Inspecting the <code>obj</code> and <code>k</code> symbols gives a clue:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br><span class="hljs-comment">// const obj: &#123;</span><br><span class="hljs-comment">//     one: string;</span><br><span class="hljs-comment">//     two: string;</span><br><span class="hljs-comment">//     three: string;</span><br><span class="hljs-comment">// &#125;</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> obj) &#123;  <span class="hljs-comment">// const k: string</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>The type of <code>k</code> is <code>string</code>, but you&#39;re trying to index into an object whose type only has three specific keys: <code>&#39;one&#39;</code>, <code>&#39;two&#39;</code>, and <code>&#39;three&#39;</code>. There are strings other than these three, so this has to fail.</p>
<p>Plugging in a narrower type declaration for <code>k</code> fixes the issue:</p>
<!-- verifier:prepend-id-to-following:one-two-three -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">let</span> k: keyof <span class="hljs-keyword">typeof</span> obj;  <span class="hljs-comment">// Type is &quot;one&quot; | &quot;two&quot; | &quot;three&quot;</span><br><span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-keyword">const</span> v = obj[k];  <span class="hljs-comment">// OK</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>So the real question is: why is the type of <code>k</code> in the first example inferred as <code>string</code> rather than <code>&quot;one&quot; | &quot;two&quot; | &quot;three&quot;</code>?</p>
<p>To understand, let&#39;s look at a slightly different example involving an interface and a function:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> ABC &#123;<br>  a: <span class="hljs-built_in">string</span>;<br>  b: <span class="hljs-built_in">string</span>;<br>  c: <span class="hljs-built_in">number</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// const k: string</span><br>    <span class="hljs-keyword">const</span> v = abc[k];<br>           <span class="hljs-comment">// ~~~~~~ Element implicitly has an &#x27;any&#x27; type</span><br>           <span class="hljs-comment">//        because type &#x27;ABC&#x27; has no index signature</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>It&#39;s the same error as before. And you can &quot;fix&quot; it using the same sort of declaration (<code>let k: keyof ABC</code>). But in this case TypeScript is right to complain. Here&#39;s why:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> x = &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attr">b</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">d</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()&#125;;<br>foo(x);  <span class="hljs-comment">// OK</span><br></code></pre></td></tr></table></figure>

<p>The function <code>foo</code> can be called with any value <em>assignable</em> to <code>ABC</code>, not just a value with &quot;a,&quot; &quot;b,&quot; and &quot;c&quot; properties. It&#39;s entirely possible that the value will have other properties, too (see Item 4: Get Comfortable with Structural Typing). To allow for this, TypeScript gives <code>k</code> the only type it can be confident of, namely, <code>string</code>.</p>
<p>Using the <code>keyof</code> declaration would have another downside here:</p>
<!--
// verifier:reset
// verifier:prepend-to-following

    interface ABC {
      a: string;
      b: string;
      c: number;
    }

-->

<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> k: keyof ABC;<br>  <span class="hljs-keyword">for</span> (k <span class="hljs-keyword">in</span> abc) &#123;  <span class="hljs-comment">// let k: &quot;a&quot; | &quot;b&quot; | &quot;c&quot;</span><br>    <span class="hljs-keyword">const</span> v = abc[k];  <span class="hljs-comment">// Type is string | number</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If <code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code> is too narrow for <code>k</code>, then <code>string | number</code> is certainly too narrow for <code>v</code>. In the preceding example one of the values is a <code>Date</code>, but it could be anything. The types here give a false sense of certainty that could lead to chaos at runtime.</p>
<p>So what if you just want to iterate over the object&#39;s keys and values without type errors? <code>Object.entries</code> lets you iterate over both simultaneously:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">abc: ABC</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(abc)) &#123;<br>    k  <span class="hljs-comment">// Type is string</span><br>    v  <span class="hljs-comment">// Type is any</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>While these types may be hard to work with, they are at least honest!</p>
<p>You should also be aware of the possibility of <em>prototype pollution</em>. Even in the case of an object literal that you define, for-in can produce additional keys:</p>
<pre data-type="programlisting">&gt; <strong>Object.prototype.z = 3;</strong> // Please don't do this!
&gt; <strong>const obj = {x: 1, y: 2};</strong>
&gt; <strong>for (const k in obj) { console.log(k); }</strong>
x
y
z</pre>

<p>Hopefully this doesn&#39;t happen in a nonadversarial environment (you should never add enumerable properties to <code>Object.prototype</code>), but it is another reason that for-in produces <code>string</code> keys even for object literals.</p>
<p>If you want to iterate over the keys and values in an object, use either a <code>keyof</code> declaration (<code>let k: keyof T</code>) or <code>Object.entries</code>. The former is appropriate for constants or other situations where you know that the object won&#39;t have additional keys and you want precise types. The latter is more generally appropriate, though the key and value types are more difficult to work with.</p>
<h4 id="Things-to-Remember"><a href="#Things-to-Remember" class="headerlink" title="Things to Remember"></a>Things to Remember</h4><ul>
<li>Use <code>let k: keyof T</code> and a for-in loop to iterate objects when you know exactly what the keys will be. Be aware that any objects your function receives as parameters might have additional keys.</li>
<li>Use <code>Object.entries</code> to iterate over the keys and values of any object.</li>
</ul>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="💬 blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('preorder', 'https://amzn.to/3UjPrsK', event);">Pre-order 2nd Ed.</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript’s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more »</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('item  know how to iterate over objects', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
