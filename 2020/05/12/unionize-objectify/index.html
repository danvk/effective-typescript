<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Unionize and Objectify: A Trick for Applying Conditional Types to Objects</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: Unionize and Objectify: A Trick for Applying Conditional Types to Objects">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; Unionize and Objectify: A Trick for Applying Conditional Types to Objects">
    <meta name="twitter:description" content="Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents Unionize and Objectify, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.
">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; Unionize and Objectify: A Trick for Applying Conditional Types to Objects">
    <meta property="og:description" content="Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents Unionize and Objectify, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.
">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-769809-4"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'UA-769809-4');

      var trackOutboundLink = function(category, url, e) {
        if (!window.google_tag_manager) {
          console.log('blocked!');
          return true;  // probably blocked
        }

        // No need to use event_callback if the link is opening in a new tab.
        var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
        gtag('event', 'click', {
            'event_category': category,
            'event_label': url,
            'transport_type': 'beacon',
            'event_callback': !newTab ? function() {
              document.location = url;
            } : undefined
        });

        return newTab;
      }
    </script>
  <meta name="generator" content="Hexo 5.4.0"></head>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>Unionize and Objectify: A Trick for Applying Conditional Types to Objects</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2020-05-12T17:00:00.000Z" itemprop="datePublished">
              Tue 12 May 2020
            </time>
          </div>
          <div class="entry-content">
            <p><em>Conditional types are the most powerful weapon TypeScript gives us for mapping between types. They do their best work on union types, so sometimes it pays to apply slightly counterintuitive transformations to get a union of types, rather than an object. This post presents <code>Unionize</code> and <code>Objectify</code>, two tools I&#39;ve found extremely helpful for constructing complex mappings between object types.</em></p>
<p>Sometimes the easiest way to get from A to B isn&#39;t the direct path. If you have great tools to solve problems in another domain, then mapping your problem onto that domain might just do the trick:</p>
<p><img src="/images/problem-domain-mapping.png" alt="Going from A to B is hard, but f(A) to f(B) is easy"></p>
<p>Examples of this are everywhere in math, science and software. It&#39;s not obvious that assigning <a href="https://en.wikipedia.org/wiki/Cartesian_coordinate_system" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Cartesian_coordinate_system', event);">cartesian coordinates</a> to points in a geometry problem will help solve it, but it works because we have great tools for solving algebra problems. It&#39;s not obvious that writing computer programs as a series of matrix operations will help you recognize <a href="https://en.wikipedia.org/wiki/MNIST_database" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/MNIST_database', event);">handwritten digits</a>, but it does because we have great tools like GPUs, <a href="https://en.wikipedia.org/wiki/Backpropagation" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Backpropagation', event);">backprop</a> and <a href="https://en.wikipedia.org/wiki/Gradient_descent" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://en.wikipedia.org/wiki/Gradient_descent', event);">gradient descent</a> for working with the matrix formulation.</p>
<p>So what does this have to do with TypeScript? In TypeScript our most powerful tool is <a href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/', event);">conditional types</a>. This is because they have two unique abilities:</p>
<ol>
<li>They distribute over unions.</li>
<li>They enable you to use the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types', event);"><code>infer</code> keyword</a>.</li>
</ol>
<p>So to the extent that we can map TypeScript problems into the domain of unions and conditional types, we&#39;ll find them easier to solve.</p>
<h3 id="Jsonify-with-methods"><a href="#Jsonify-with-methods" class="headerlink" title="Jsonify with methods"></a>Jsonify with methods</h3><p>As an example, consider a <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a> where we looked at the type of a variable before and after JSON serialization:</p>
<!--
// verifier:prepend-to-following
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br></code></pre></td></tr></table></figure>
<p>--&gt;</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  id: <span class="hljs-built_in">number</span>;<br>  name: <span class="hljs-built_in">string</span>;<br>  birthday: <span class="hljs-built_in">Date</span> | <span class="hljs-literal">null</span><br>&#125;<br><span class="hljs-keyword">const</span> student: Student = &#123;<br>  id: <span class="hljs-number">123</span>, name: <span class="hljs-string">'Bobby'</span>, birthday: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2007-10-10'</span>)<br>&#125;;<br><span class="hljs-keyword">const</span> studentRT = jsonRoundTrip(student);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   id: number;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   birthday: string | null;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The definition of JSON serialization in that post wasn&#39;t quite complete. If there&#39;s a method defined on an object, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify" target="_blank" rel="noopener">the MDN docs</a> say it will be omitted during serialization:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">&gt; JSON.stringify(&#123; name: &#39;Bobby&#39;, age: 12, greet() &#123; return &#39;Hi!&#39;; &#125;&#125;)<br>&#39;&#123;&quot;name&quot;: &quot;Bobby&quot;,&quot;age&quot;: 12&#125;&#39;<br></code></pre></td></tr></table></figure>

<p>Using the last version of <code>Jsonify</code> from the <a href="https://effectivetypescript.com/2020/04/09/jsonify/">previous post</a>, however, we get something different (<a href="https://www.typescriptlang.org/play/#code/C4TwDgpgBAUgzgewHYEsBmIA8AVAfFAXimyggA9gIkATOKAb2ARgGUB5AOQAoBKALigokaCACcoAVQC+AKChQA-JLlQBJcpRp0EAIwBWEAMbAVS+ivnyA2gGtBSKDYggEaYgF0B8ZOizZb7rgA3BZQsvJqITJoAK5IxijIUHqISABKCHHU2KIoYDi4XGRq-LCpvgUMKqIQwDGiDqycAHRgAIaicBBcTRzNcMC5SADmvkU8PCGyMobIA1AAboTJqRlZOXlc5vJIbQC2EAIA5ABCujogRwA0Km3Dh1AAjABMN-LDNbW8DFA1dQ1QI4ACRQAEIjkEwjcpJMZAB6OFQUCQQR0cwIyxQXYHAQDIbDEIYyx3B5IGJ7HRiQmIywfCC1AT0KTUsIyIA" target="_blank" rel="noopener">playground</a>):</p>
<!-- verifier:reset -->

<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> keyof T]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">//    greet: &#123;&#125;;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>To get a more accurate type, we&#39;ll need to filter out the properties with function values. But how do you do that? More generally, how do you filter out properties from an object type that are assignable to some other type?</p>
<!-- verifier:skip because it's fill in the blank -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = ???;<br></code></pre></td></tr></table></figure>

<h3 id="OmitProperties"><a href="#OmitProperties" class="headerlink" title="OmitProperties"></a>OmitProperties</h3><p>One idea is to use <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types', event);">mapped types</a> and conditional types together:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: T[k] <span class="hljs-keyword">extends</span> V ? never : T[k];<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>If the value type for a key (<code>T[k]</code>) extends <code>V</code>, then we change it to a <code>never</code> type. Otherwise we leave it as-is. Here&#39;s how that shakes out:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Person &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>  greet: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>;<br>&#125;<br><span class="hljs-keyword">type</span> NonFunctionalPeople = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">//   greet: never;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>This is close to what we want, but it&#39;s not exactly right. The <code>getId</code> key is still in the result type. It has a <code>never</code> value type, sure, but it&#39;s distracting and it will still show up in <code>keyof</code> expressions:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = keyof NonFunctionalPeople;  <span class="hljs-comment">// type is "name" | "age" | "greet"</span><br></code></pre></td></tr></table></figure>

<p>Depending on the situation, this might be a disaster. For example, if you have a function to index a list based on a field, <code>greet</code> will be allowed because it&#39;s in <code>keyof T</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-keyword">let</span> people: NonFunctionalPeople[];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  vals: T[], field: keyof OmitProperties&lt;T, <span class="hljs-built_in">Function</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-keyword">const</span> index = indexByField(people, <span class="hljs-string">'greet'</span>);  <span class="hljs-comment">// OK, should be an error</span><br></code></pre></td></tr></table></figure>

<p>So what to do? We used conditional types here, but we didn&#39;t apply them to a union type, which is where they do their best work. To make a better  <code>OmitProperties</code>, we need to map from the domain of object types to the domain of union types.</p>
<!-- verifier:reset -->

<h3 id="Unionize-and-Objectify"><a href="#Unionize-and-Objectify" class="headerlink" title="Unionize and Objectify"></a>Unionize and Objectify</h3><p>I learned a trick for this from <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian Cernicova-Dragomir</a> on <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">Stack Overflow</a>. You map from an object type to a union type of <code>{k, v}</code> pairs. Let&#39;s call this transformation <code>Unionize</code>:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Unionize&lt;T <span class="hljs-keyword">extends</span> object&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> keyof T]: &#123;k: k; v: T[k]&#125;<br>&#125;[keyof T];<br><br><span class="hljs-keyword">type</span> PersonUnion = Unionize&lt;Person&gt;;<br><span class="hljs-comment">// type is &#123; k: "name"; v: string; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "greet"; v: () =&gt; string; &#125;</span><br></code></pre></td></tr></table></figure>

<p>We&#39;ve used a mapped type <code>[k in keyof T]</code> and an index operation <code>[keyof T]</code> to transform the object type into a union of types with <code>k</code> / <code>v</code> pairs. The key is a string literal type and the value is the value type.</p>
<p>You can put the object back together again using the inverse operation. Let&#39;s call that <code>Objectify</code>:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVPair = &#123;k: PropertyKey; v: unknown&#125;<br><span class="hljs-keyword">type</span> Objectify&lt;T <span class="hljs-keyword">extends</span> KVPair&gt; = &#123;<br>  [k <span class="hljs-keyword">in</span> T[<span class="hljs-string">'k'</span>]]: Extract&lt;T, &#123;k: k&#125;&gt;[<span class="hljs-string">'v'</span>]<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>This one is a little tricker. <code>PropertyKey</code> is an alias for anything that can be used as a property key in TypeScript: <code>string | number | symbol</code>. The <code>T[&#39;k&#39;]</code> extracts all the key types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> K = PersonUnion[<span class="hljs-string">'k'</span>];  <span class="hljs-comment">// type is "age" | "name" | "greet"</span><br></code></pre></td></tr></table></figure>

<p>Then we use <a href="https://fettblog.eu/typescript-built-in-generics/#extract" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://fettblog.eu/typescript-built-in-generics/#extract', event);"><code>Extract</code></a> to find the k/v pair for each key and pull out the corresponding value:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KV = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;;  <span class="hljs-comment">// type is &#123;k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> V = Extract&lt;PersonUnion, &#123;k: <span class="hljs-string">'age'</span>&#125;&gt;[<span class="hljs-string">'v'</span>];  <span class="hljs-comment">// type is number</span><br></code></pre></td></tr></table></figure>

<p>The result is that we can put our object type back together again:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ReformedPerson = Objectify&lt;PersonUnion&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//     age: number;</span><br><span class="hljs-comment">//     name: string;</span><br><span class="hljs-comment">//     greet: () =&gt; string;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>So we have a complete mapping between object types and unions of key/value pairs. Now we can put conditional types to work on their home turf! Let&#39;s see what this lets us do.</p>
<h3 id="OmitProperties-with-the-new-helpers"><a href="#OmitProperties-with-the-new-helpers" class="headerlink" title="OmitProperties with the new helpers"></a>OmitProperties with the new helpers</h3><p>First, <code>OmitProperties</code>. It&#39;s easy to filter a k/v pair based on the value type using a conditional:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? never : T;<br><br><span class="hljs-keyword">type</span> KV1 = OmitKV&lt;&#123;k: <span class="hljs-string">'age'</span>, v: <span class="hljs-built_in">number</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123; k: "age"; v: number; &#125;</span><br><span class="hljs-keyword">type</span> KV2 = OmitKV&lt;&#123;k: <span class="hljs-string">'greet'</span>, v: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">string</span>&#125;, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is never</span><br></code></pre></td></tr></table></figure>

<p>Now the fun part! Because <code>OmitKV</code> is a conditional type, it distributes over unions. And in a type union, <code>never</code> disappears:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> KVs = OmitKV&lt;PersonUnion, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123; k: "age"; v: number; &#125; |</span><br><span class="hljs-comment">//         &#123; k: "name"; v: string; &#125;</span><br></code></pre></td></tr></table></figure>

<p>By sandwiching <code>OmitKV</code> between <code>Unionize</code> and <code>Objectify</code>, we can take the long way around (as in the diagram at the start of the post) and get an <code>OmitProperties</code> implementation:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OmitProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Objectify&lt;OmitKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> T = OmitProperties&lt;Person, <span class="hljs-built_in">Function</span>&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   name: string;</span><br><span class="hljs-comment">//   age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <code>greet</code> property, which was a function, is really, truly gone! ðŸ¤©</p>
<p>You can implement the opposite operation, <code>PickProperties</code>, in a similar way:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKV&lt;T <span class="hljs-keyword">extends</span> KVPair, V&gt; = T <span class="hljs-keyword">extends</span> &#123;v: V&#125; ? T : never;<br><span class="hljs-keyword">type</span> PickProperties&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Objectify&lt;PickKV&lt;Unionize&lt;T&gt;, V&gt;&gt;;<br><br><span class="hljs-keyword">type</span> PersonStrings = PickProperties&lt;Person, <span class="hljs-built_in">string</span>&gt;;<br><span class="hljs-comment">// type is &#123; name: string &#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: keyof PickProperties&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br>indexByField(people, <span class="hljs-string">'name'</span>);  <span class="hljs-comment">// OK</span><br>indexByField(people, <span class="hljs-string">'greet'</span>);<br>                   <span class="hljs-comment">// ~~~~~ Argument of type '"greet"' is not assignable</span><br>                   <span class="hljs-comment">//       to parameter of type '"name"'. (2345)</span><br></code></pre></td></tr></table></figure>

<p>Of course, if you just want the keys then you don&#39;t need to go back through <code>Objectify</code>. Something simpler accomplishes the same thing:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> PickKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; =<br>  Extract&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexByField</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">  obj: T[],</span></span><br><span class="hljs-function"><span class="hljs-params">  field: PickKeys&lt;T, <span class="hljs-built_in">string</span>&gt;</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="Jsonify-with-Unionize-and-Objectify"><a href="#Jsonify-with-Unionize-and-Objectify" class="headerlink" title="Jsonify with Unionize and Objectify"></a>Jsonify with Unionize and Objectify</h3><p>What other problems can you solve with this technique?</p>
<p>Looking back at <a href="https://effectivetypescript.com/2020/04/09/jsonify/"><code>Jsonify</code></a>, we can make it filter out Function values:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (opposite of PickKeys, above)</span><br><span class="hljs-keyword">type</span> OmitKeys&lt;T <span class="hljs-keyword">extends</span> object, V&gt; = Exclude&lt;Unionize&lt;T&gt;, &#123;v: V&#125;&gt;[<span class="hljs-string">'k'</span>];<br><br><span class="hljs-keyword">type</span> Jsonify&lt;T&gt; = T <span class="hljs-keyword">extends</span> &#123;toJSON(): infer U&#125;<br>  ? U<br>  : T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">Array</span>&lt;infer U&gt;<br>  ? <span class="hljs-built_in">Array</span>&lt;Jsonify&lt;U&gt;&gt;<br>  : T <span class="hljs-keyword">extends</span> object<br>  ? &#123;<br>      [k <span class="hljs-keyword">in</span> OmitKeys&lt;T, <span class="hljs-built_in">Function</span>&gt;]: Jsonify&lt;T[k]&gt;;<br>    &#125;<br>  : T;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">jsonRoundTrip</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">Jsonify</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(x));<br>&#125;<br><br><span class="hljs-keyword">const</span> v = jsonRoundTrip(&#123;<br>  name: <span class="hljs-string">'Bobby'</span>,<br>  age: <span class="hljs-number">12</span>,<br>  greet() &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">'Hi!'</span>; &#125;,<br>&#125;);<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//    name: string;</span><br><span class="hljs-comment">//    age: number;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <code>greet</code> method is gone entirely, just as it should be. Amazing!</p>
<h3 id="Lodash-39-s-invert"><a href="#Lodash-39-s-invert" class="headerlink" title="Lodash&#39;s _.invert"></a>Lodash&#39;s <code>_.invert</code></h3><p>Yet another application (and the one that <a href="https://stackoverflow.com/a/56416192/388951" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://stackoverflow.com/a/56416192/388951', event);">introduced me to this technique</a>) is precisely typing <a href="https://lodash.com/docs/4.17.15#invert" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://lodash.com/docs/4.17.15#invert', event);">lodash&#39;s <code>_.invert()</code></a>, which swaps the keys and values in an object:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> longToShort = _.invert(shortToLong);  <span class="hljs-comment">// what's the type?</span><br></code></pre></td></tr></table></figure>

<p>As of this writing, the type you get using <code>@types/lodash</code> is just <a href="https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://github.com/DefinitelyTyped/DefinitelyTyped/blob/921607887591fbbe2a417b344ad98a1a45cd25d1/types/lodash/common/object.d.ts#L1990-L2002', event);"><code>_.Dictionary&lt;string&gt;</code></a>, which isn&#39;t wrong, but also isn&#39;t very precise. You can get a more precise result using <code>keyof</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Record&lt;<span class="hljs-built_in">string</span>, keyof T&gt;;<br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//    [x: string]: "p" | "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <code>shortToLong</code> constant is probably intended to be entirely immutable, so we can use a <a href="https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://blog.logrocket.com/const-assertions-are-the-killer-new-typescript-feature-b73451f35802/', event);">const assertion</a> to get a more precise type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> shortToLong = &#123;<br>  p: <span class="hljs-string">'pageNum'</span>,<br>  n: <span class="hljs-string">'numResults'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-comment">// type is &#123; readonly p: 'pageNum'; readonly n: 'numResults'; &#125;</span><br></code></pre></td></tr></table></figure>

<p>Now we should be able to get a <em>really</em> precise type for the inverse! It should be <code>{pageNum: &#39;p&#39;; numResults: &#39;n&#39;;}</code>. Let&#39;s see how <code>Unionize</code> and <code>Objectify</code> can help us get there.</p>
<p>First of all, swapping the <code>k</code> and <code>v</code> in a k/v pair is easy:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never;<br></code></pre></td></tr></table></figure>

<p>Here we&#39;ve used the <a href="https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types" target="_blank" rel="noopener" onclick="return trackOutboundLink('', 'https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-inference-in-conditional-types', event);"><code>infer</code> keyword</a> (a conditional types superpower) to pull out the key and value types from a k/v pair.</p>
<p>If you try to wrap this in <code>Unionize</code> and <code>Objectify</code>, you&#39;ll get a very long, cryptic error. I&#39;ll spare you the full message, but the root cause is that <code>Objectify</code> requires that <code>k</code> be a <code>PropertyKey</code> and there&#39;s no guarantee that <code>V</code> is assignable to that. If we bake in that constraint, then everything works:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> SwapKV&lt;T&gt; =<br>  T <span class="hljs-keyword">extends</span> &#123;k: infer K, v: infer V&#125;<br>  ? V <span class="hljs-keyword">extends</span> PropertyKey  <span class="hljs-comment">// &lt;-- additional PropertyKey constraint</span><br>  ? &#123;k: V; v: K; &#125;  <span class="hljs-comment">// &lt;-- note the swap!</span><br>  : never<br>  : never;<br><span class="hljs-keyword">type</span> Inverted&lt;T <span class="hljs-keyword">extends</span> object&gt; = Objectify&lt;SwapKV&lt;Unionize&lt;T&gt;&gt;&gt;;<br></code></pre></td></tr></table></figure>

<p>Now we get perfect types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> shortToLong&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     pageNum: "p";</span><br><span class="hljs-comment">//     numResults: "n";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>If you drop the <code>as const</code>, you&#39;ll get a less-precise type, just like before. It would be nice to restrict <code>Inverted</code> to only allow types with <code>PropertyKey</code> values, but I&#39;ll leave that as an exercise to the reader.</p>
<p>If you have duplicate values, you get a union of the values for the key type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> playerToTeam = &#123;<br>  a: <span class="hljs-string">'A'</span>,<br>  b: <span class="hljs-string">'A'</span>,<br>  c: <span class="hljs-string">'B'</span>,<br>&#125; <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><br><span class="hljs-keyword">type</span> T = Inverted&lt;<span class="hljs-keyword">typeof</span> playerToTeam&gt;;<br><span class="hljs-comment">// type T = &#123;</span><br><span class="hljs-comment">//     A: "a" | "b";</span><br><span class="hljs-comment">//     B: "c";</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>This seems sensible since TypeScript doesn&#39;t have a notion of the order of keys in an object or elements in a union. I recommend working out the sequence of operations yourself to see how this union (<code>&quot;a&quot; | &quot;b&quot;</code>) comes about.</p>
<!--
It would be nice if TypeScript displayed types as objects in this:
function invert<T extends object>(o: T): Inverted<T> {
  return _.invert(o);
}
const invMapping = invert(mapping);
// const invMapping: Objectify<{
//     k: "fooBar";
//     v: "foo_bar";
// } | {
//     k: "bazQuux";
//     v: "baz_quux";
// } | {
//     k: "fooBar";
//     v: "bar";
// }>

Titian's `{} &` trick seems to be of no use here.
-->

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Ever since I learned about them, I&#39;ve been finding more and more uses for <code>Unionize</code> and <code>Objectify</code>. You&#39;ve seen three of them in this post, but I&#39;m sure there are many others. They have a real knack for transforming difficult problems with object types into much simpler problems with union types. Next time you run into a problem with types, think about whether unionization can help!</p>
<p>To experiment with the code samples in this post, use <a href="https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://www.typescriptlang.org/play/#code/JYOwLgpgTgZghgYwgAgArQM4HsTIN4BQyyIcAthAFzIZhSgDmA3EcnA1SQK5kBG0LYgygQIYagAoAlMgC8APhp1GLAL4ECYAJ4AHFAFUQwHMABeEADwAVZBAAekEABMMyLLwBWEBGEWz8rADaANbIoMjBEFpYMMhWALrUeMHUwUzIAG7UViHx6qohUTFx8SyauijoUNgghsa4-nUm5hZVNfIsAPSdyNp6Ya54EdQARKQUI+lZSvQgzMiqyAA+BN3E6xtDKcgj7BCTmdQgPPxQ6YsraxubwzvComAH09JyirSz8+rl-QDSAGqoODAKByfDbVBQLB6KDaH5RKbULggYIgLAAdxA6j6KAA8p5vGBgDAtNZbA4IM5XP9AcC-AFiCEwrgcgByYIs+KJZAAUQcUEQYGsABowalVPJAiyMhyCKoytjkAAlCAwLBQChONo4UF4rw+IkkrW1Iw4DqrHoK5Wq9UQTWYbX+QhXdZ7I4nATm67jTjvFSejb3MSSGQKGZ+tZfBU4sjAMD-Un2RwuZDUoFQEV-Ok2RMU5N4aZ-RYAfhIEAy0GQ2XlFRTfwAjDqY3G-hZktQWXsWSLpsc+NBVCKAGJI-WmroWmvAQa3XYcJ5uvtnBbfFD-ABMjdj8bbyBZgbAXcOyBeod9cwHyGHIFHIDNawVU9L5agGgV-1c-mjW5bRqaICHI6EmOnpvn8H74DOezztwi7nMs-rXNcWyjN60Fnp8r41l+YAQlC0CEhAGAJuSlJuPiPgZnSuoEgaFjYfGf5mJYVjyJRZornEm44ZC0IEURRoAdeQG3uOvSToMCHetQ6GicQrowacomRjWqDAAgwTxtmJHJqmwKUaCWlJoMBbFpxRxlh6CqqepuG8cAhHEUZZF6mA+myKw1H6sSrRqRpLaMS0LFsdW-RGgAysoczgdZwS2fh9n8fa-5hnMd4Tv0j5DFJKUMMuHExXCWhEYZuauO4LluawvJ0AKFgBcxrH4CZEpshyZQwIB9RMk49gAEJaIO9kADZOI5pXOQS8gSKw5XZIE8RCqwMDDU41AFVExUiuh8gEDIQydAAVMgAB0p3IAdPRfD1CBDXAIjIENYjIHoUKPWtSXzSwoA9XY-WDRAI0SC9OiPSKLLeiyUjpMgaw4j8BDfX1A0rUDECvRAYP7pDgiIbjGxrAAfkTRPIAAglADA8BSYBuLECosiM+4jCyAwkFgNNwBgGDAAwpC8I9rB43jzobGAWDPXd5BiBWxT02MUvM8dx5rgAzAALAArFIGhrBIUI6Fg3OQLTaC+YVGAinAvBYOW2tRk25tjaR5UEm5PJ2DdXA9XVJpGIFjX5tQhYteypSYf0ABSNS0SxBlkk5eBixHYU4gActI1CgDAFb6OoxAlvorDZPH43k-yJJZznO352TUDlxYUcmN5+jyNXlacTmzvkWArAloQiGMuE9EbcKl6daaXKN0Y3k5ME8Rmhseft1Y7Xj7gHg1IqWBIk4Vj0Do1hTXY2RSNQU8x4o-fICIYBcFAuDJ2nx06HdGAQBIj+p8d6EGhIdhSFDWUGgEA4FoJkUEG8cBbx3nvYAOgJBX2yiyXq7heBaC7KweSdY1yLSECIMQLwhg3zvrgFkAAJYAABCFk5xFqqEAfecSAQRbZRkghNgHAFyKU9F8EBIAwEYAABZqjAFYLAAAZHAuVHSsB0O2F+HBU48AwcQEA7ZezKgwFwIaYAMAYMWJzZAfDaAhRQGFNEcAdCaT8KwEqpEdyVxBD8bsmcQDZxBIWXuyA-gl1InFGEWhCrEDWBYAAtKEtgTgnCxnqHAIaaAeL4UCVEIxoCaqgB7jXHcfwEQpjgjDHoYSImomNmAQRKAMAWJ0JQouT5oC1JABZM4HEACSIBnyQFGnY5MLsfBUW7rRcxliGK+yYofVupi4gtNBG0jptoLDYmKEIkRYjJGpVEgqKw0yZEiwloongowdCTHYTBTR2jdEoWORGYBaTnq3S0NAMRVgIDkFBFfOA7ZSYqOQLwT53yEDtl6votgrhjFgEmVYVAMz2n4XmYs2IIM4APKgE8l5ZA0piX6JCt5JzSajDgCMZYOxeBXJ6BsXqowECkuXEAA', event);">this playground link</a>.</p>
<p><em>A huge thanks to <a href="https://stackoverflow.com/users/125734/titian-cernicova-dragomir" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://stackoverflow.com/users/125734/titian-cernicova-dragomir', event);">Titian</a> for introducing me to this! He uses &quot;AllValues&quot; instead of &quot;Unionize&quot;. If you don&#39;t like the names, feel free to choose your own. You could go with &quot;ToPairs&quot; and &quot;FromPairs&quot; to match lodash, or &quot;ToUnion&quot; and &quot;ToObject&quot;. If you just want something like <code>OmitProperties</code>, take a look at ts-essential&#39;s <a href="https://github.com/krzkaczor/ts-essentials#omitproperties" target="_blank" rel="noopener" onclick="return trackOutboundLink('conclusion', 'https://github.com/krzkaczor/ts-essentials#omitproperties', event);"><code>OmitProperties</code></a>.</em></p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div id="disqus_thread"></div>
          <script>
            var disqus_config = function () {
              this.page.identifier = document.location.pathname;  // Replace PAGE_URL with your page's canonical URL variable
              this.page.url = 'https://effectivetypescript.com' + this.page.identifier;
              };
            (function() { // DON'T EDIT BELOW THIS LINE
              var d = document, s = d.createElement('script');
              s.src = 'https://effective-typescript.disqus.com/embed.js';
              s.setAttribute('data-timestamp', +new Date());
              (d.head || d.body).appendChild(s);
            })();
          </script>
        <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="http://disqus.com/?ref_noscript" onclick="return trackOutboundLink('conclusion', 'http://disqus.com/?ref_noscript', event);">comments powered by Disqus.</a></noscript>
        <a target="_blank" rel="noopener" href="http://disqus.com" class="dsq-brlink" onclick="return trackOutboundLink('conclusion', 'http://disqus.com', event);">comments powered by <span class="logo-disqus">Disqus</span></a>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/38s1oCK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('post learn more hover', 'https://amzn.to/38s1oCK', event);">Buy the Book</a>
        <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" class="btn btn-info btn-lg hidden-xs" onclick="return trackOutboundLink('post learn more hover', 'https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1', event);">Buy eBook</a>
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/38s1oCK" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/38s1oCK', event);">
            <img src="/images/cover.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScriptâ€™s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more Â»</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2021 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('conclusion', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
