<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>Use typed identity functions to guide type inference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: Use typed identity functions to guide type inference">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; Use typed identity functions to guide type inference">
    <meta name="twitter:description" content="TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of Effective TypeScript is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types.">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; Use typed identity functions to guide type inference">
    <meta property="og:description" content="TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of Effective TypeScript is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types.">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>Use typed identity functions to guide type inference</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2020-06-16T15:00:00.000Z" itemprop="datePublished">
              Tue 16 June 2020
            </time>
          </div>
          <div class="entry-content">
            <p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. (Chapter 3 of <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://amzn.to/3HIrQN6', event);"><em>Effective TypeScript</em></a> is devoted to this topic.) But when you use tuples or string literal types, this will sometimes go wrong. This post explores using identity functions with carefully constructed type signatures to guide inference towards alternative types. <span id="more"></span></p>
<p>Say you have a function to calculate the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pythagorean_theorem" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://en.wikipedia.org/wiki/Pythagorean_theorem', event);">distance between two points</a>:</p>
<!-- verifier:prepend-to-following -->
<!-- #point -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> Point = [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dist</span>(<span class="hljs-params">[x1, y1]: Point, [x2, y2]: Point</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.sqrt((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>If you define some points and try to call this function, you&#39;ll get an error:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);<br><span class="hljs-comment">//           ~~ Argument of type &#x27;number[]&#x27; is not assignable</span><br><span class="hljs-comment">//                to parameter of type &#x27;Point&#x27;.</span><br><span class="hljs-comment">//              Type &#x27;number[]&#x27; is missing the following properties</span><br><span class="hljs-comment">//                from type &#x27;[number, number]&#x27;: 0, 1 (2345)</span><br></code></pre></td></tr></table></figure>

<p>The issue is that TypeScript has inferred the types of <code>p1</code> and <code>p2</code> as <code>number[]</code>, whereas you would have preferred <code>Point</code>. These aren&#39;t compatible (there are many number arrays that aren&#39;t <code>Point</code>s) and hence the error.</p>
<p>There are a whole class of type errors like this that happen when the inferred type wasn&#39;t quite the one you had in mind. In this case the easiest solution is to either declare the type of each point:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1: Point = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>];<br><span class="hljs-keyword">const</span> p2: Point = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>or use a &quot;const assertion&quot; to avoid inferring the wider types:</p>
<!-- verifier:skip because I don't want to talk about readonly here -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> p1 = [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">const</span> p2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>In this case the inferred types are much narrower than <code>Point</code>, but they are assignable to <code>Point</code>, so this type checks.</p>
<p>But in this post I want to talk about a slightly different approach, which is to use identity functions that adjust the inferred type. Here&#39;s one way you could use an identity(ish) function to get a <code>Point</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> Point = (x: <span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>): <span class="hljs-function"><span class="hljs-params">Point</span> =&gt;</span> [x, y];<br><br><span class="hljs-keyword">const</span> p1 = Point(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">const</span> p2 = Point(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">let</span> d = dist(p1, p2);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>The <code>Point</code> function is a value, so it&#39;s fine that it has the same name as the <code>Point</code> type, which exists in a separate namespace (Item 8 in <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://amzn.to/3HIrQN6', event);"><em>Effective TypeScript</em></a> discusses how to know if a symbol is in type or value space). The &quot;<code>: Point</code>&quot; declares the return type of the function. This is preferable to <code>as Point</code>, which <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/41964087/in-typescript-is-there-a-reason-to-prefer-const-foo-type-or-const-foo" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://stackoverflow.com/questions/41964087/in-typescript-is-there-a-reason-to-prefer-const-foo-type-or-const-foo', event);">would not perform excess property checking</a>.</p>
<p>This certainly solves the problem and is sometimes more convenient than using declarations. Examples of this pattern in the wild include Material-UI&#39;s <a target="_blank" rel="noopener" href="https://material-ui.com/guides/typescript/#using-createstyles-to-defeat-type-widening" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://material-ui.com/guides/typescript/#using-createstyles-to-defeat-type-widening', event);"><code>createStyles</code></a> and React Native&#39;s <a target="_blank" rel="noopener" href="https://reactnative.dev/docs/style" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://reactnative.dev/docs/style', event);"><code>StyleSheet.create</code></a>.</p>
<p>In the case of a tuple, though, there&#39;s a neat trick (which I learned from Boris Cherny&#39;s <a target="_blank" rel="noopener" href="https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://www.amazon.com/Programming-TypeScript-Making-JavaScript-Applications/dp/1492037656', event);"><em>Programming TypeScript</em></a>) to solve this more generally. You can use a generic identity function to get TypeScript to infer a tuple type, rather than an array:</p>
<!-- verifier:prepend-subset-to-following:1-1 -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> tuple = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">T</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>[]&gt;</span>(...args: T): T =&gt; args;</span><br><br><span class="xml">const p1 = tuple(0, 0);</span><br><span class="xml">const p2 = tuple(3, 4);</span><br><span class="xml">let d = dist(p1, p2);  // ok</span><br></code></pre></td></tr></table></figure>

<p>If you mouse over <code>p1</code> or <code>p2</code> <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A16EA" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://www.typescriptlang.org/play/#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A16EA', event);">in the playground</a>, you&#39;ll see that its type has been inferred as <code>[number, number]</code>, just like we wanted.</p>
<p>This works with any sort of tuples, including those with mixed types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-regexp">/three/</span>]; <span class="hljs-comment">// type is (string | number | RegExp)[]</span><br><span class="hljs-keyword">const</span> tup = tuple(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-regexp">/three/</span>); <span class="hljs-comment">// type is [number, string, RegExp]</span><br></code></pre></td></tr></table></figure>

<p>The <code>tuple</code> function isn&#39;t one you&#39;d write in plain JavaScript (it&#39;s shorter to use an array literal), but in the TypeScript context it becomes an extremely useful way to change up the inferred type.</p>
<p>You can apply the same idea if you want to let TypeScript infer the keys of an object but still provide an explicit type for the values. For example:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals = &#123;<br>  ny: [-<span class="hljs-number">73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [-<span class="hljs-number">121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [-<span class="hljs-number">134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>If you try to calculate the distance between two capitals, you&#39;ll get the same error as before:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">dist(capitals.ny, capitals.ak);<br><span class="hljs-comment">//   ~~~~~~~~~~~ Argument of type &#x27;number[]&#x27; is not assignable</span><br><span class="hljs-comment">//                 to parameter of type &#x27;Point&#x27;</span><br></code></pre></td></tr></table></figure>

<p>(To calculate the actual distance you should use something like <a target="_blank" rel="noopener" href="https://turfjs.org/docs/#distance" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://turfjs.org/docs/#distance', event);"><code>turf.distance</code></a>.)</p>
<p>Mousing over <code>capitals</code>, you&#39;ll see its type is inferred as <code>&#123;ny: number[]; ca: number[]; ak: number[];&#125;</code>. You could wrap all the capital locations in <code>tuple</code> like before, but let&#39;s try writing a different identity function to force them all to be <code>Point</code>s:</p>
<!-- verifier:reset -->
<!-- verifier:prepend-id-to-following:point -->
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueType = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">V</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>&gt;</span>() =&gt;</span><br>  &lt;T extends Record&lt;PropertyKey, V&gt;&gt;(o: T) =&gt; o;<br><br>const capitals = withValueType&lt;Point&gt;()(&#123;<br>  ny: [-73.7562, 42.6526],<br>  ca: [-121.4944, 38.5816],<br>  ak: [-134.4197, 58.3019],<br>&#125;);<br><br>let d = dist(capitals.ny, capitals.ak);  // ok<br></code></pre></td></tr></table></figure>

<p>If you mouse over the type of <code>capitals</code> now, it&#39;s</p>
<!-- verifier:skip because this is hovertext, not TS -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> capitals: &#123;<br>    ny: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ca: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>    ak: [<span class="hljs-built_in">number</span>, <span class="hljs-built_in">number</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>and the types all work out!</p>
<p>So how does <code>withValueType</code> work? In order to infer the object&#39;s type as something different, we first need to capture it in a generic argument, just like we did with <code>tuple</code>. This is <code>T</code>, and we want TypeScript to infer it. We also want to explicitly write the value type <code>V</code> (<code>Point</code> in this case). Unfortunately you can&#39;t have a function with one explicit generic parameter and one inferred parameter. TypeScript will either infer all the generic parameters to a function or none of them, <a target="_blank" rel="noopener" href="https://github.com/Microsoft/TypeScript/issues/14400" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://github.com/Microsoft/TypeScript/issues/14400', event);">not a mix</a>.</p>
<p>There is a standard workaround for this problem: split the function into two, one with an explicit generic parameter and one with an inferred parameter. Instead of an identity function, we now have a function that <em>returns</em> an identity function. (Note the extra <code>()</code> after <code>withValueType</code>!)</p>
<p>It&#39;s important to note that this is quite different than using an <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://www.typescriptlang.org/docs/handbook/interfaces.html#indexable-types', event);">index type</a> or <code>Record</code>, which also fixes the type error:</p>
<!-- verifier:prepend-to-following -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// (Don&#x27;t do this, see below!)</span><br><span class="hljs-keyword">const</span> capitalsRec: Record&lt;<span class="hljs-built_in">string</span>, Point&gt; = &#123;<br>  ny: [-<span class="hljs-number">73.7562</span>, <span class="hljs-number">42.6526</span>],<br>  ca: [-<span class="hljs-number">121.4944</span>, <span class="hljs-number">38.5816</span>],<br>  ak: [-<span class="hljs-number">134.4197</span>, <span class="hljs-number">58.3019</span>],<br>&#125;;<br><br>d = dist(capitalsRec.ny, capitalsRec.ak);  <span class="hljs-comment">// ok</span><br></code></pre></td></tr></table></figure>

<p>The difference is that accessing an invalid key produces an error when you let TypeScript infer the keys, but not when you use an index type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">capitalsRec.in;  <span class="hljs-comment">// allowed</span><br>capitals.in;<br>      <span class="hljs-comment">// ~~ Property &#x27;in&#x27; does not exist on type ...</span><br></code></pre></td></tr></table></figure>

<p>The inferred type of <code>capitals</code> is more like <code>Record&lt;&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;, Point&gt;</code> than <code>Record&lt;string, Point&gt;</code>. But because the keys were inferred, you didn&#39;t have to write <code>&#39;ny&#39;|&#39;ca&#39;|&#39;ak&#39;</code> explicitly.</p>
<p>As a final example, you may find that you want to define an object that has some (but not all) of the fields of another object.</p>
<p>For example:</p>
<!-- verifier:reset -->
<!-- verifier:prepend-subset-to-following:1-7 -->
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> CSSColor = <span class="hljs-string">&#x27;aliceblue&#x27;</span> | <span class="hljs-string">&#x27;antiquewhite&#x27;</span> | <span class="hljs-string">&#x27;aqua&#x27;</span> | <span class="hljs-string">&#x27;black&#x27;</span> <span class="hljs-comment">// | ...;</span><br><span class="hljs-keyword">interface</span> DisplayValue &#123;<br>  value: <span class="hljs-built_in">number</span>;<br>  units: <span class="hljs-built_in">string</span>;<br>  color: CSSColor;<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span> | <span class="hljs-string">&#x27;bold&#x27;</span> | <span class="hljs-string">&#x27;italic&#x27;</span> | <span class="hljs-string">&#x27;bolditalic&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">const</span> defaults = &#123;<br>  color: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// Type ... is not assignable to type &#x27;DisplayValue&#x27;.</span><br>   <span class="hljs-comment">//   Types of property &#x27;color&#x27; are incompatible.</span><br>   <span class="hljs-comment">//     Type &#x27;string&#x27; is not assignable to type &#x27;CSSColor&#x27;.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25_259_974_097_204</span>,<br>  units: <span class="hljs-string">&#x27;inches&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>What went wrong? Despite the error on <code>distanceToJupiter</code>, the problem is with <code>defaults</code>. Its type is inferred as <code>&#123; color: string; style: string; &#125;</code>, rather than the narrower value types required for a <code>DisplayValue</code>.</p>
<p>You might try to solve the problem by using <code>Partial</code> in the declaration of <code>defaults</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> defaults: Partial&lt;DisplayValue&gt; = &#123;<br>  color: <span class="hljs-string">&#x27;black&#x27;</span>,<br>  style: <span class="hljs-string">&#x27;regular&#x27;</span>,<br>&#125;;<br><br><span class="hljs-keyword">const</span> distanceToJupiter: DisplayValue = &#123;<br>   <span class="hljs-comment">// ~~~~~~~~~~~~~~~~~</span><br>   <span class="hljs-comment">// ... Type &#x27;undefined&#x27; is not assignable to type &#x27;CSSColor&#x27;.</span><br>  ...defaults,<br>  value: <span class="hljs-number">25_259_974_097_204</span>,<br>  units: <span class="hljs-string">&#x27;inches&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>Now the issue is that you&#39;ve lost the specificity of the keys in <code>defaults.</code> The <code>Partial&lt;DisplayValue&gt;</code> type marks <em>all</em> the properties as optional, including <code>color</code> and <code>style</code> which you&#39;ve definitely specified. Hence the error about <code>undefined</code>. (You can see this error on the <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=21&pc=1#code/C4TwDgpgBAwgynGB7ANkgTlAvFA5AQxQEsBjCAIxQFcJcoAfPfAO2CIEcaB3ACyOFoMmnfHUa5K+EgGs6AejlCAdCoDcAKCKsI6AGZToAESIBnMCnwgAaoRpQA3uqhQAbrYgAuKMyoBbcjoazlTM-CZeJsDoWgDmQVAkqBhe8IhJ6PGRICieeOgQMVQW6GJ45KgAJqW4-ISk1eUoFbXEJLgaAL7q6onMkVAVEPpFwOFQAAr46GyEADzGZhbW7gB82A5OCeleEhYyuAA0m1k5O-mFxYfqHRo9SH3AA6bALGQAKkgAUlRg-DpeC3Mlhs1GgOEczigCigAD84fCEYi4ZsoYpnG9wNBcCFBrotBAqlBTN4kI98CYTEQYsx8JRoMAkFBQJA8KlkGgSkooAAKABMAGZebyAJSbFRKXH4EYmI7ONygry8gCsAH1lQBOFXqgDsABYVQAGHVqg262VQEJhHZaEg8CAmK43dRAA" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://www.typescriptlang.org/play/?ssl=1&ssc=1&pln=21&pc=1#code/C4TwDgpgBAwgynGB7ANkgTlAvFA5AQxQEsBjCAIxQFcJcoAfPfAO2CIEcaB3ACyOFoMmnfHUa5K+EgGs6AejlCAdCoDcAKCKsI6AGZToAESIBnMCnwgAaoRpQA3uqhQAbrYgAuKMyoBbcjoazlTM-CZeJsDoWgDmQVAkqBhe8IhJ6PGRICieeOgQMVQW6GJ45KgAJqW4-ISk1eUoFbXEJLgaAL7q6onMkVAVEPpFwOFQAAr46GyEADzGZhbW7gB82A5OCeleEhYyuAA0m1k5O-mFxYfqHRo9SH3AA6bALGQAKkgAUlRg-DpeC3Mlhs1GgOEczigCigAD84fCEYi4ZsoYpnG9wNBcCFBrotBAqlBTN4kI98CYTEQYsx8JRoMAkFBQJA8KlkGgSkooAAKABMAGZebyAJSbFRKXH4EYmI7ONygry8gCsAH1lQBOFXqgDsABYVQAGHVqg262VQEJhHZaEg8CAmK43dRAA', event);">playground</a>.)</p>
<p>You can&#39;t solve this using <code>withValueType</code> since the values for <code>color</code> and <code>style</code> have different types. Instead, you can craft a slightly different generic identity function. I call this <code>withValueTypesFrom</code>, since you&#39;re taking the value types from some other type (if you have a better name, please suggest it!):</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> withValueTypesFrom = <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">V</span> <span class="hljs-attr">extends</span> <span class="hljs-attr">unknown</span>&gt;</span>() =&gt;</span><br>    &lt;K extends keyof V&gt;(x: Pick&lt;V, K&gt;): Pick&lt;V, K&gt; =&gt; x;<br><br>const defaults = withValueTypesFrom&lt;DisplayValue&gt;()(&#123;<br>  color: &#x27;black&#x27;,<br>  style: &#x27;regular&#x27;,<br>&#125;);  // Type is Pick&lt;DisplayValue, &quot;color&quot; | &quot;style&quot;&gt;<br><br>const distanceToJupiter: DisplayValue = &#123;<br>  ...defaults,<br>  value: 25_259_974_097_204,<br>  units: &#x27;inches&#x27;,<br>&#125;;  // ok<br></code></pre></td></tr></table></figure>

<p>It&#39;s worth repeating that none of the values have changed here, just the types. This has all the right properties: if you specify an invalid color in <code>defaults</code>, you&#39;ll get an error. If you misspell <code>color</code> as <code>colour</code>, you&#39;ll get an error. And if you leave out <code>value</code> or <code>units</code> in <code>distanceToJupiter</code>, you&#39;ll also get an error.</p>
<p>TypeScript tends to do a very good job of inferring types when you leave off explicit annotations. But when you use tuples or string literal types, this will sometimes go wrong. When this happens, type declarations or const assertions are typically the answer. But if you want to adjust inference in more general or complex ways, typed identity functions give you the flexibility to do so.</p>
<p>Do you have other examples of functions that help with inference? Chime in in the comments! You can find the full code from this example on the <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play/?ssl=52&ssc=7&pln=52&pc=20#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A10pl7qh+sRlphJFAAOTAFpwQnkPaOMwQPZ0X6HUAA05CcHEAA+gmIyAGbIAShABhUdB07tlcssXusCcTSeTflSIDTdn9GSc6sCqJdOdzyPzBaJbqLUC0EI4AGq2PI4CAlY7LIpm8qVaq1epIJqtJDdPRoSalJ1VGp1fmZYg8IowYhwSAeEAAaQgIHIZs63TgIx9kzgs0x2VYtjApstdQwJvNluttsgEcUwG9QkMxiQIHkmF8AHY3k52wBWABsaignxUTj7PZUfeopCMUHzrd84hU4icnwAnJ9PuQ3gAOJw97fiSfT4y2Brz8RvT4r8Sr9vkfdON4bG9T+gpZLpGEYOHCfOF4DFk4zbkH+RZ5PwTinh+fwmCYAB+CGIUhcFQAAgoM+DVKgcCMP80CEqyHSEoCdTNNi-D8AgAxILYBAFPQMGwUxzGwcAcBQGA-S2Hg5gkFAOF4US8DaISGLzLOyyNhQLZYB2Xa9gOXwjmOE6vsYc6yYuy5rhuW67vuh5qVMZ6aZe163veu5Pi+04pDm4mgQB4EhvIIZwGGRTakgAzkMJKCTBgUnNvOnbdv2g7DqO45HjOGltlpK7rpuUA7nuB4xSeJnxWZnw3neUAPtZq6vnZGIFmB-Ahk4yAMI5gE1TOsF-AhsBRjGoBEsgxE8HAECkXAqAVAI2HcKqUC9E46RjQAwgAyrN01wHk7nLISloIKwEB0daxFskStgoAgrjWi0DimhAu37cdtiXWt114P0yAXVAe2EnRtisA0xF-HtE0MNoJCMB90AACICPktggBaVrQFJABuFYQPIrIMMYLCmsMUBeQMqOzkt7nyHNC348QuOCCABTyISZgDDgeT9LdBBLTwt1gRtjPM2zrCEqk6R-LmqDIIwJAwBtDT2o6FSBq6jTNG03oTFA-pSy6dQwP0HCWg6qZCOmUCjIr2ZGlAZYOND1r8FWfUAGJRngEsBqrboevLQiZo1Stxo7QZQA0iYCSmXjyKLn0OuQcadGMsBi2HUAR4roj2VivAQEDdPACWJummbiOW8c-C23AeBFGD-AQ1DiP1lJmTLcQVPvZ95IzuTlNEjTdMM7ZH7Gz+B2bSUcAAFKrOdddQKX5fm4UBgzhNPCp7Y6f8MeUAIzD8gqD2AD6m+rlvt6fFvGy3jvGybjO6MZ1TyCsA4fVN6VQA" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://www.typescriptlang.org/play/?ssl=52&ssc=7&pln=52&pc=20#code/C4TwDgpgBACg9gSwHbCgXigbSQVwLYBGEATgDRS6EkC6A3AFABmOSAxsAnElACYIDOwABSYAHgEZyIcdQBcsRCnJiATFJVyFyYAEooAb3pRjUYhGA5i3ALIBDYAAsAdPwCOxYUNEqoAWigSegBUQVA+ANRQQiA+-tLBoSo6DAC+9PSsXIJQFmAANtAYADwAKlAQosAQSDz8UCwA1khwAO5ImNQAfEJOvbbEAOb88iU6I+idUP1DDBlZqGDi6Dk4+RBCAAzkG8nGAPR7OeDQAliURGQU+BfUc0jZYD4YuQVCAMzkACy7UAdHkFBTthriRyOcaPQCqgeMs+IIhItyI8fn84A10pl7qh+sRlphJFAAOTAFpwQnkPaOMwQPZ0X6HUAA05CcHEAA+gmIyAGbIAShABhUdB07tlcssXusCcTSeTflSIDTdn9GSc6sCqJdOdzyPzBaJbqLUC0EI4AGq2PI4CAlY7LIpm8qVaq1epIJqtJDdPRoSalJ1VGp1fmZYg8IowYhwSAeEAAaQgIHIZs63TgIx9kzgs0x2VYtjApstdQwJvNluttsgEcUwG9QkMxiQIHkmF8AHY3k52wBWABsaignxUTj7PZUfeopCMUHzrd84hU4icnwAnJ9PuQ3gAOJw97fiSfT4y2Brz8RvT4r8Sr9vkfdON4bG9T+gpZLpGEYOHCfOF4DFk4zbkH+RZ5PwTinh+fwmCYAB+CGIUhcFQAAgoM+DVKgcCMP80CEqyHSEoCdTNNi-D8AgAxILYBAFPQMGwUxzGwcAcBQGA-S2Hg5gkFAOF4US8DaISGLzLOyyNhQLZYB2Xa9gOXwjmOE6vsYc6yYuy5rhuW67vuh5qVMZ6aZe163veu5Pi+04pDm4mgQB4EhvIIZwGGRTakgAzkMJKCTBgUnNvOnbdv2g7DqO45HjOGltlpK7rpuUA7nuB4xSeJnxWZnw3neUAPtZq6vnZGIFmB-Ahk4yAMI5gE1TOsF-AhsBRjGoBEsgxE8HAECkXAqAVAI2HcKqUC9E46RjQAwgAyrN01wHk7nLISloIKwEB0daxFskStgoAgrjWi0DimhAu37cdtiXWt114P0yAXVAe2EnRtisA0xF-HtE0MNoJCMB90AACICPktggBaVrQFJABuFYQPIrIMMYLCmsMUBeQMqOzkt7nyHNC348QuOCCABTyISZgDDgeT9LdBBLTwt1gRtjPM2zrCEqk6R-LmqDIIwJAwBtDT2o6FSBq6jTNG03oTFA-pSy6dQwP0HCWg6qZCOmUCjIr2ZGlAZYOND1r8FWfUAGJRngEsBqrboevLQiZo1Stxo7QZQA0iYCSmXjyKLn0OuQcadGMsBi2HUAR4roj2VivAQEDdPACWJummbiOW8c-C23AeBFGD-AQ1DiP1lJmTLcQVPvZ95IzuTlNEjTdMM7ZH7Gz+B2bSUcAAFKrOdddQKX5fm4UBgzhNPCp7Y6f8MeUAIzD8gqD2AD6m+rlvt6fFvGy3jvGybjO6MZ1TyCsA4fVN6VQA', event);">TypeScript playground</a>. <em>Some of the examples in this post come from an older post with a very different focus that I wrote for the <a target="_blank" rel="noopener" href="https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://blog.logrocket.com/how-typescript-breaks-referential-transparency-7a82c0345f2c/', event);">LogRocket blog</a>.</em></p>

          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="💬 blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('buy2e', 'https://amzn.to/3UjPrsK', event);">Buy 2nd Edition</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScript’s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more »</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('use typed identity functions to guide type inference', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
