<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    
    <title>TypeScript Splits the Atom!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Khula:wght@600&family=Open+Sans:ital,wght@0,300;0,400;0,600;1,300;1,400;1,600&display=swap" rel="stylesheet">
    <link href="/css/customize.css" rel="stylesheet">
    <link href="/css/highlight.vs.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="/images/icon.png">
    <meta name="description" content="Effective TypeScript: TypeScript Splits the Atom!">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:creator" content="@danvdk">
    <meta name="twitter:domain" content="effectivetypescript.com">
    <meta name="twitter:title" content="Effective TypeScript &rsaquo; TypeScript Splits the Atom!">
    <meta name="twitter:description" content="

TypeScript&amp;#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming TypeScript 4.1 release includes a particularly exciting new addition to the type system: template literal types.
Template literal types solve a long-standing gap in TypeScript&amp;#39;s type system and, as I&amp;#39;ll argue at the end of the post, they solve it in a particularly TypeScripty way.
To understand template literal types, let&amp;#39;s start with a seemingly simple question: what can&amp;#39;t you type?">
    <meta name="twitter:img:src" content="https://effectivetypescript.com/images/cover-2e.jpg">

    <meta property="og:title" content="Effective TypeScript &rsaquo; TypeScript Splits the Atom!">
    <meta property="og:description" content="

TypeScript&amp;#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming TypeScript 4.1 release includes a particularly exciting new addition to the type system: template literal types.
Template literal types solve a long-standing gap in TypeScript&amp;#39;s type system and, as I&amp;#39;ll argue at the end of the post, they solve it in a particularly TypeScripty way.
To understand template literal types, let&amp;#39;s start with a seemingly simple question: what can&amp;#39;t you type?">
    <meta property="og:image" content="https://effectivetypescript.com/images/cover-2e.jpg">
    <meta property="og:url" content="https://effectivetypescript.com/">

    <link href="https://effectivetypescript.com/atom.xml" type="application/atom+xml" rel="alternate" title="Effective TypeScript Atom Feed">
  <meta name="generator" content="Hexo 5.4.0"></head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1NXE8EL9YT"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1NXE8EL9YT');
  var trackOutboundLink = function(category, url, e) {
    if (!window.google_tag_manager) {
      console.log('blocked!');
      return true;  // probably blocked
    }

    // No need to use event_callback if the link is opening in a new tab.
    var newTab = e && (e.metaKey || (e.currentTarget && e.currentTarget.target === '_blank'));
    gtag('event', 'click', {
        'event_category': category,
        'event_label': url,
        'transport_type': 'beacon',
        'event_callback': !newTab ? function() {
          document.location = url;
        } : undefined
    });

    return newTab;
  }
</script>

<body class="post">
  <div class="header">
  <div class="container">
      <div class="row">
          <div class="col-md-12">
              <h1 class="site-title">
                  <a href="/">
                      Effective TypeScript
                  </a>
              </h1>
          </div>
      </div>
  </div>
</div>

  <section id="content" class="article content">

  <div class="title-bar">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h2>TypeScript Splits the Atom!</h2>
        </div>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <div class="text-muted published-container">
            <time class="published" datetime="2020-11-05T05:00:00.000Z" itemprop="datePublished">
              Thu 05 November 2020
            </time>
          </div>
          <div class="entry-content">
            <img src="https://effectivetypescript.com/images/split-atom.png" width="324" height="298" alt="Splitting a string type" style="max-height: 100%; float: right">

<p>TypeScript&#39;s type system has grown steadily more powerful over the past five years, allowing you to precisely type more and more patterns in JavaScript. The upcoming <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/40124" onclick="return trackOutboundLink('typescript splits the atom', 'https://github.com/microsoft/TypeScript/issues/40124', event);">TypeScript 4.1 release</a> includes a particularly exciting new <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/pull/40336" onclick="return trackOutboundLink('typescript splits the atom', 'https://github.com/microsoft/TypeScript/pull/40336', event);">addition</a> to the type system: <em>template literal types</em>.</p>
<p>Template literal types solve a <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/12754" onclick="return trackOutboundLink('typescript splits the atom', 'https://github.com/microsoft/TypeScript/issues/12754', event);">long-standing gap</a> in TypeScript&#39;s type system and, as I&#39;ll argue at the end of the post, they solve it in a particularly <em>TypeScripty</em> way.</p>
<p>To understand template literal types, let&#39;s start with a seemingly simple question: what can&#39;t you type?</p>
<span id="more"></span>

<h2 id="The-limits-of-type-safety-in-TypeScript"><a href="#The-limits-of-type-safety-in-TypeScript" class="headerlink" title="The limits of type safety in TypeScript"></a>The limits of type safety in TypeScript</h2><p>My standard example of a pattern you <em>couldn&#39;t</em> type has always been the <code>camelCase</code> function, which maps something like <code>&quot;foo_bar&quot;</code> â†’ <code>&quot;fooBar&quot;</code>. It&#39;s easy to implement in JavaScript using a regular expression:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> term.replace(<span class="hljs-regexp">/_([a-z])/g</span>, <span class="hljs-function"><span class="hljs-params">m</span> =&gt;</span> m[<span class="hljs-number">1</span>].toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>This function is trivial to <em>simply</em> type:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">declare</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">camelCase</span>(<span class="hljs-params">term: <span class="hljs-built_in">string</span></span>): <span class="hljs-title">string</span></span>;<br></code></pre></td></tr></table></figure>

<p>So that&#39;s not quite what I&#39;m getting at. Ideally you&#39;d like to be able to use this to convert objects with <code>snake_cased</code> properties (like you&#39;d get from a database) into ones with <code>camelCased</code> properties (like you typically use in JS/TS). In other words, what should the return type of this function be to make the following code type check (or not) as you&#39;d expect?</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> out: <span class="hljs-built_in">any</span> = &#123;&#125;;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [k, v] <span class="hljs-keyword">of</span> <span class="hljs-built_in">Object</span>.entries(obj)) &#123;<br>    out[camelCase(k)] = v;<br>  &#125;<br>  <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;<span class="hljs-attr">foo_bar</span>: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// camel&#x27;s value at runtime is &#123;fooBar: 12&#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type of val is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;  <span class="hljs-comment">// should be a type error</span><br></code></pre></td></tr></table></figure>

<p>Prior to TypeScript 4.1 (now a release candidate) this just wasn&#39;t possible. The reason was that string literal types like <code>&quot;foo_bar&quot;</code> were &quot;atomic&quot; in the sense that you couldn&#39;t observe any structure inside of them. They were indivisible. But clearly there <em>is</em> structure in strings. Just look at <a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Instance_methods" onclick="return trackOutboundLink('the limits of type safety in typescript', 'https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Instance_methods', event);">all the methods</a> on <code>String.prototype</code>.</p>
<p>Enter: TypeScript 4.1!</p>
<h2 id="TypeScript-splits-the-atom"><a href="#TypeScript-splits-the-atom" class="headerlink" title="TypeScript splits the atom"></a>TypeScript splits the atom</h2><p>TypeScript 4.1 introduce a few features that make it possible to precisely type the <code>objectToCamel</code> function:</p>
<ol>
<li><em>Template literal types</em> This is the key advance. Template literal types allow you to find structure inside string literal types and create infinite, strict subsets of <code>string</code> (think &quot;strings starting with <code>on</code>&quot;).</li>
<li><em>Key Remapping in Mapped Types</em> While it was possible to change the keys in an object before using tricks like <a href="https://effectivetypescript.com/2020/05/12/unionize-objectify/">Unionize and Objectify</a>, this new feature makes it much more straightforward.</li>
</ol>
<p>Let&#39;s use these two features to implement <code>objectToCamel</code>.</p>
<p>First, let&#39;s look at template literal types. They look like ES template literals:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> OnString = <span class="hljs-string">`on<span class="hljs-subst">$&#123;<span class="hljs-built_in">string</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> onClick: OnString = <span class="hljs-string">&#x27;onClick&#x27;</span>;<br><span class="hljs-keyword">const</span> handleClick: OnString = <span class="hljs-string">&#x27;handleClick&#x27;</span>;<br>   <span class="hljs-comment">// ~~~~~~~~~~~ Type &#x27;&quot;handleClick&quot;&#x27; is not assignable to type &#x27;`on$&#123;string&#125;`&#x27;.</span><br></code></pre></td></tr></table></figure>

<p>This lets you create a type for &quot;strings starting with <code>on</code>.&quot; Before TypeScript 4.1, you either had <code>string</code> or an enumerated union of string literal types (<code>&quot;a&quot; | &quot;b&quot; | &quot;c&quot;</code>). Now you can define structured subsets of <code>string</code>.</p>
<p>Here are a few other patterns:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> IdNum = <span class="hljs-string">`id<span class="hljs-subst">$&#123;<span class="hljs-built_in">number</span>&#125;</span>`</span>;<br><span class="hljs-keyword">const</span> id1: IdNum = <span class="hljs-string">&#x27;id123&#x27;</span>;  <span class="hljs-comment">// ok</span><br><span class="hljs-keyword">const</span> id2: IdNum = <span class="hljs-string">&#x27;idABC&#x27;</span>;<br>   <span class="hljs-comment">// ~~~ Type &#x27;idABC&#x27; is not assignable to IdNum</span><br><br><span class="hljs-keyword">type</span> Digit = <span class="hljs-string">&#x27;0&#x27;</span> | <span class="hljs-string">&#x27;1&#x27;</span> | <span class="hljs-string">&#x27;2&#x27;</span> | <span class="hljs-string">&#x27;3&#x27;</span> | <span class="hljs-string">&#x27;4&#x27;</span> |<br>             <span class="hljs-string">&#x27;5&#x27;</span> | <span class="hljs-string">&#x27;6&#x27;</span> | <span class="hljs-string">&#x27;7&#x27;</span> | <span class="hljs-string">&#x27;8&#x27;</span> | <span class="hljs-string">&#x27;9&#x27;</span>;<br><span class="hljs-keyword">type</span> ThreeDigitNum = <span class="hljs-string">`<span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span><span class="hljs-subst">$&#123;Digit&#125;</span>`</span>;<br></code></pre></td></tr></table></figure>

<p>What makes this really powerful is that you can use the <a target="_blank" rel="noopener" href="https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/" onclick="return trackOutboundLink('typescript splits the atom', 'https://artsy.github.io/blog/2018/11/21/conditional-types-in-typescript/', event);"><code>infer</code> keyword</a> in a template literal type to do pattern matching:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel1&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;Tail&gt;&#125;</span>`</span><br>    : S;<br><br><span class="hljs-keyword">type</span> T = ToCamel1&lt;<span class="hljs-string">&#x27;foo_bar&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar&quot; (!!!)</span><br></code></pre></td></tr></table></figure>

<p>The conditional matches string literal types of the form <code>&quot;head_tail&quot;</code>. The &quot;<code>_</code>&quot; acts as a delimiter to split the string. Because <a target="_blank" rel="noopener" href="https://mariusschulz.com/blog/conditional-types-in-typescript#distributive-conditional-types" onclick="return trackOutboundLink('typescript splits the atom', 'https://mariusschulz.com/blog/conditional-types-in-typescript#distributive-conditional-types', event);">conditional types distribute over unions</a>, this also works for union types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> TU = ToCamel1&lt;<span class="hljs-string">&#x27;first_name&#x27;</span> | <span class="hljs-string">&#x27;last_name&#x27;</span>&gt;;<br><span class="hljs-comment">// type is &quot;firstName&quot; | &quot;lastName&quot;</span><br></code></pre></td></tr></table></figure>

<p>There&#39;s a big issue, though. What if there&#39;s two <code>_</code>s in the string literal type?</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> T2 = ToCamel1&lt;<span class="hljs-string">&#x27;foo_bar_baz&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar_baz&quot;</span><br></code></pre></td></tr></table></figure>

<p>We can&#39;t stop after the first &quot;<code>_</code>&quot;, we need to keep going. We can do this by making the type recursive:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ToCamel&lt;S <span class="hljs-keyword">extends</span> <span class="hljs-built_in">string</span>&gt; =<br>    S <span class="hljs-keyword">extends</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;infer Head&#125;</span>_<span class="hljs-subst">$&#123;infer Tail&#125;</span>`</span><br>    ? <span class="hljs-string">`<span class="hljs-subst">$&#123;Head&#125;</span><span class="hljs-subst">$&#123;Capitalize&lt;ToCamel&lt;Tail&gt;&gt;&#125;</span>`</span><br>    : S;<br><span class="hljs-keyword">type</span> T0 = ToCamel&lt;<span class="hljs-string">&#x27;foo&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;foo&quot;</span><br><span class="hljs-keyword">type</span> T1 = ToCamel&lt;<span class="hljs-string">&#x27;foo_bar&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBar&quot;</span><br><span class="hljs-keyword">type</span> T2 = ToCamel&lt;<span class="hljs-string">&#x27;foo_bar_baz&#x27;</span>&gt;;  <span class="hljs-comment">// type is &quot;fooBarBaz&quot;</span><br></code></pre></td></tr></table></figure>

<p>The recursive bit is where we call <code>ToCamel&lt;Tail&gt;</code>.</p>
<p>Pretty neat! Now let&#39;s put it all together.</p>
<h2 id="A-typed-objectToCamel"><a href="#A-typed-objectToCamel" class="headerlink" title="A typed objectToCamel"></a>A typed objectToCamel</h2><p>Recall that a <a target="_blank" rel="noopener" href="https://medium.com/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8" onclick="return trackOutboundLink('a typed objecttocamel', 'https://medium.com/@danvdk/a-typed-pluck-exploring-typescript-2-1s-mapped-types-c15f72bf4ca8', event);">mapped type</a> in TypeScript looks and works something like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Vector &#123;<br>  x: <span class="hljs-built_in">number</span>;<br>  y: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Promisify&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T]: <span class="hljs-built_in">Promise</span>&lt;T[K]&gt;  <span class="hljs-comment">// &lt;-- the mapping</span><br>&#125;;<br><span class="hljs-keyword">type</span> VectorPromise = Promisify&lt;Vector&gt;;<br><span class="hljs-comment">// type is &#123; x: Promise&lt;number&gt;; y: Promise&lt;number&gt;; &#125;</span><br></code></pre></td></tr></table></figure>

<p>The <code>keyof T</code> here produces a union of string literal types (<code>&quot;x&quot; | &quot;y&quot;</code>) and the mapped type produces an object type from this given a way to produce the values (the <code>Promise&lt;T[K]&gt;</code>). But the keys are set by the union. You can&#39;t change them.</p>
<p>With Key Remapping, you can add an <code>as</code> clause to the key in a mapped type to change things around. This works particularly well with template literal types:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">interface</span> Student &#123;<br>  name: <span class="hljs-built_in">string</span>;<br>  age: <span class="hljs-built_in">number</span>;<br>&#125;<br><span class="hljs-keyword">type</span> Evented&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;K &amp; <span class="hljs-built_in">string</span>&#125;</span>Changed`</span>]: <span class="hljs-function">(<span class="hljs-params">val: T[K]</span>) =&gt;</span> <span class="hljs-built_in">void</span>;<br>&#125;<br><span class="hljs-keyword">type</span> StudentEvents = Evented&lt;Student&gt;;<br><span class="hljs-comment">// type is &#123;</span><br><span class="hljs-comment">//   nameChanged: (val: string) =&gt; void;</span><br><span class="hljs-comment">//   ageChanged: (val: number) =&gt; void;</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure>

<p>(The <code>&amp; string</code> is there for technical reasons that I don&#39;t want to get into.)</p>
<p>Using this, we can plug in our <code>ToCamel</code> generic to put it all together:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">type</span> ObjectToCamel&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-built_in">object</span>&gt; = &#123;<br>  [K <span class="hljs-keyword">in</span> keyof T <span class="hljs-keyword">as</span> ToCamel&lt;K&gt;]: T[K]<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectToCamel</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">object</span>&gt;(<span class="hljs-params">obj: T</span>): <span class="hljs-title">ObjectToCamel</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>  <span class="hljs-comment">// ... as before ...</span><br>&#125;<br><br><span class="hljs-keyword">const</span> snake = &#123;<span class="hljs-attr">foo_bar</span>: <span class="hljs-number">12</span>&#125;; <span class="hljs-comment">// type is &#123;foo_bar: number&#125;</span><br><span class="hljs-keyword">const</span> camel = objectToCamel(snake);<br><span class="hljs-comment">// type is &#123; fooBar: number &#125;</span><br><span class="hljs-keyword">const</span> val = camel.fooBar;  <span class="hljs-comment">// type is number</span><br><span class="hljs-keyword">const</span> val2 = camel.foo_bar;<br>                <span class="hljs-comment">// ~~~~~~~ Property &#x27;foo_bar&#x27; does not exist on type</span><br>                <span class="hljs-comment">//         &#x27;&#123; fooBar: number; &#125;&#x27;. Did you mean &#x27;fooBar&#x27;?</span><br></code></pre></td></tr></table></figure>

<p>Here&#39;s a <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/play?ts=4.2.0-dev.20201109#code/C4TwDgpgBAKg9gYQIYFsIBsA8BlKEAewEAdgCYDOU5wATgJbEDmAfFALwBQU3UuBRZSgAMAJAG8GAMwg0oACQhJSAXwD64qTNhI66ZUK48A-FFFiFS5eORg6wJOjoAvCJnjI0WGDvTNm+w24ALl4Abg5QSFgABnZYRFQMTABySTg4ZOZQ7gB6HKhI6DpKACI0uBKI8GgYAEY490SsVPTVACMkGkzsqDyC6qhiqDL0gCFOysLYACYGhM8U8vbO5adu3PypoZG4cZpxp0qOSQBXYgBjYDo4YihzpuRyVxg8QhIKKloGFgAKIhoUCEYABKIHzJIwVhiQw0CDAE40W7-FAAOlhYHQSHOEB+OVUPwA2kgALROAC6wJyjAANFAUOxWCgCbUySjgHAAKpgSA0R444HAqBISiNBaQ8LKDhVKIAeTaACsIJdRRDXgIPnAFUrgKw2FBodwCQBpQa3ADWEBAcEksCFIvBWBNADJPvQmMwyUDjWSOMpwsczpdrrdNYrlQ63Gr3pRQ9rmD9Q0DQVA5WHgCqvFDDOcbtQoHATsAQkhiCA4mI-YY0rIfjniHmCWbaQA3Mn5m2p7UokhfCDkBMKgX6wL5wsE+6ePk-M3Att65vhbiS7iw+GI0fACVSut5sDC+7octLDo0EK1aZ+3qbAZDMTHzohYgnFBtGSSnfAO5NOKx8MeDA-Hu5AHsC4R9FslBiFA5R7I+z6vrI765p+zYOHEE4YCiMGdD04E3pQT4vjIHAflAqHoLMeoYegWGtCei48IxTE8H0AB+7EcaxUAAAo0HAPKgFALRwMsXRQKQcB9lAxBwJ+BDFJ+Nz9JAI7McxfRqUJUHYae0nwTI2TKMkKJQAAInQpBQFaJx0ootzCXsyRGBwQA" onclick="return trackOutboundLink('a typed objecttocamel', 'https://www.typescriptlang.org/play?ts=4.2.0-dev.20201109#code/C4TwDgpgBAKg9gYQIYFsIBsA8BlKEAewEAdgCYDOU5wATgJbEDmAfFALwBQU3UuBRZSgAMAJAG8GAMwg0oACQhJSAXwD64qTNhI66ZUK48A-FFFiFS5eORg6wJOjoAvCJnjI0WGDvTNm+w24ALl4Abg5QSFgABnZYRFQMTABySTg4ZOZQ7gB6HKhI6DpKACI0uBKI8GgYAEY490SsVPTVACMkGkzsqDyC6qhiqDL0gCFOysLYACYGhM8U8vbO5adu3PypoZG4cZpxp0qOSQBXYgBjYDo4YihzpuRyVxg8QhIKKloGFgAKIhoUCEYABKIHzJIwVhiQw0CDAE40W7-FAAOlhYHQSHOEB+OVUPwA2kgALROAC6wJyjAANFAUOxWCgCbUySjgHAAKpgSA0R444HAqBISiNBaQ8LKDhVKIAeTaACsIJdRRDXgIPnAFUrgKw2FBodwCQBpQa3ADWEBAcEksCFIvBWBNADJPvQmMwyUDjWSOMpwsczpdrrdNYrlQ63Gr3pRQ9rmD9Q0DQVA5WHgCqvFDDOcbtQoHATsAQkhiCA4mI-YY0rIfjniHmCWbaQA3Mn5m2p7UokhfCDkBMKgX6wL5wsE+6ePk-M3Att65vhbiS7iw+GI0fACVSut5sDC+7octLDo0EK1aZ+3qbAZDMTHzohYgnFBtGSSnfAO5NOKx8MeDA-Hu5AHsC4R9FslBiFA5R7I+z6vrI765p+zYOHEE4YCiMGdD04E3pQT4vjIHAflAqHoLMeoYegWGtCei48IxTE8H0AB+7EcaxUAAAo0HAPKgFALRwMsXRQKQcB9lAxBwJ+BDFJ+Nz9JAI7McxfRqUJUHYae0nwTI2TKMkKJQAAInQpBQFaJx0ootzCXsyRGBwQA', event);">complete playground</a>.</p>
<h2 id="What-can-should-you-do-with-template-literal-types"><a href="#What-can-should-you-do-with-template-literal-types" class="headerlink" title="What can should you do with template literal types?"></a>What <del>can</del> should you do with template literal types?</h2><p>After template literal types landed, the TypeScript Twittersphere went crazy. I shared a use case around <a target="_blank" rel="noopener" href="https://expressjs.com/en/guide/routing.html" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://expressjs.com/en/guide/routing.html', event);">express</a>, which quickly became the most popular tweet I&#39;ve ever posted:</p>
<blockquote class="twitter-tweet"><p lang="en" dir="ltr">Another use of <a target="_blank" rel="noopener" href="https://twitter.com/typescript?ref_src=twsrc%5Etfw" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/typescript?ref_src=twsrc%5Etfw', event);">@TypeScript</a> 4.1&#39;s template literal types: extracting the URL parameters from an express route. Pretty amazing you can do this in the type system! <a target="_blank" rel="noopener" href="https://t.co/gfZQy70whg" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://t.co/gfZQy70whg', event);">https://t.co/gfZQy70whg</a> <a target="_blank" rel="noopener" href="https://t.co/aEyfMwjjqX" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://t.co/aEyfMwjjqX', event);">pic.twitter.com/aEyfMwjjqX</a></p>&mdash; Dan Vanderkam (@danvdk) <a target="_blank" rel="noopener" href="https://twitter.com/danvdk/status/1301707026507198464?ref_src=twsrc%5Etfw" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/danvdk/status/1301707026507198464?ref_src=twsrc%5Etfw', event);">September 4, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

<p>A <a target="_blank" rel="noopener" href="https://twitter.com/buildsghost/status/1301976526603206657" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://twitter.com/buildsghost/status/1301976526603206657', event);">JSON parser</a> made the rounds and then someone <a target="_blank" rel="noopener" href="https://github.com/codemix/ts-sql" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/codemix/ts-sql', event);">implemented a full SQL engine</a> in the type system. Hacker news <a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=24615185" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://news.ycombinator.com/item?id=24615185', event);">was impressed</a>.</p>
<p>As with any new tool, it will take some time for the community to figure out the best ways to use it. Here are a few ideas. We&#39;ll see how they pan out!</p>
<ul>
<li><p>Dotted access: <strong>easy win</strong></p>
<p>Lodash allows you to write <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/43395675/388951" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://stackoverflow.com/a/43395675/388951', event);">&quot;iteratee&quot; expressions</a> like <code>xs.map(&#39;a.b.c&#39;)</code>, which is roughly the same as <code>xs.map(x =&gt; x.a.b.c)</code>. Template literal types will make it possible for this sort of API to be typed.</p>
<p>I&#39;ve never been a big fan of this style. I&#39;d prefer to write <code>x =&gt; x.a.b.c</code>. But perhaps some of this is just bias from not being able to type these properly in the past. Using string literals for enums, for example, is frowned upon in Java as unsafe, <a target="_blank" rel="noopener" href="https://cocoacasts.com/the-danger-of-string-literals-and-stringly-typed-code" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://cocoacasts.com/the-danger-of-string-literals-and-stringly-typed-code', event);">stringly typed</a>, code. But it turns out to be fine in TypeScript because the type system is rich enough to capture it. So we&#39;ll see!</p>
</li>
<li><p>Parsing routes: <strong>huge win!</strong></p>
<p>See my <code>ExtractRouteParams</code> tweet above. Parsing <code>&#123;userId: string&#125;</code> out of <code>/users/:userId</code> will be a big win for express users.</p>
<p>Going the other direction is also compelling. In a server I use at work, we issue API calls via something like <code>get(&#39;/users/:userId&#39;, &#123;userId: &#39;id&#39;&#125;)</code>. We have types defined for the parameters for each route. But now we can just let TypeScript infer them to ensure that nothing will ever get out of sync.</p>
<p>Similar considerations apply to routes with <a target="_blank" rel="noopener" href="https://reactrouter.com/web/example/url-params" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://reactrouter.com/web/example/url-params', event);">react-router</a>.</p>
</li>
<li><p>Better types for <code>querySelector</code> / <code>querySelectorAll</code>: <strong>nice win</strong></p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/blob/b5b0437a86661c8d7bc76c5860c07305df17899c/lib/lib.dom.d.ts#L11341-L11349" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/microsoft/TypeScript/blob/b5b0437a86661c8d7bc76c5860c07305df17899c/lib/lib.dom.d.ts#L11341-L11349', event);">DOM typings</a> are clever enough to infer a subtype of <code>Element</code> here:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input&#x27;</span>);<br><span class="hljs-comment">// Type is HTMLInputElement | null</span><br></code></pre></td></tr></table></figure>

<p>But once you add anything more complex to the selector, you lose this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> input = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;input.my-class&#x27;</span>);<br><span class="hljs-comment">// Type is Element | null</span><br></code></pre></td></tr></table></figure>

<p>With template literal types, it will be possible to fix this. I wouldn&#39;t be surprised if it becomes common practice to replace calls to <code>getElementById</code> with equivalent calls to <code>querySelector</code>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> el1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;foo&#x27;</span>);<br><span class="hljs-comment">// type is Element | null</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div#foo&#x27;</span>);<br><span class="hljs-comment">// type is HTMLDivElement | null</span><br></code></pre></td></tr></table></figure>

<p>This will no doubt require me to rewrite Item 55 of <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://amzn.to/3HIrQN6', event);"><em>Effective TypeScript</em></a> (&quot;Understand the DOM hierarchy&quot;). Oh well!</p>
</li>
<li><p>Parsing options in <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/commander" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://www.npmjs.com/package/commander', event);">Commander</a> or <a target="_blank" rel="noopener" href="https://github.com/docopt/docopt.coffee" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/docopt/docopt.coffee', event);">docopt</a>: <strong>a small win</strong></p>
<p>With <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/commander" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://www.npmjs.com/package/commander', event);">Commander</a>, you define your command line tool&#39;s arguments using something like this:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts">program<br>  .option(<span class="hljs-string">&#x27;-d, --debug&#x27;</span>, <span class="hljs-string">&#x27;output extra debugging&#x27;</span>)<br>  .option(<span class="hljs-string">&#x27;-s, --small&#x27;</span>, <span class="hljs-string">&#x27;small pizza size&#x27;</span>)<br>program.parse(process.argv);<br><span class="hljs-built_in">console</span>.log(program.debug, program.small);<br></code></pre></td></tr></table></figure>

<p>Setting aside the mutation style, which is hard to model in TypeScript, template literal types should make it possible to extract the parameter names from the calls to <code>.option</code>.</p>
</li>
<li><p>Parsing SQL or GraphQL: <strong>I could go either way!</strong></p>
<p>The <a target="_blank" rel="noopener" href="https://github.com/codemix/ts-sql" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/codemix/ts-sql', event);">ts-sql</a> demo <a target="_blank" rel="noopener" href="https://news.ycombinator.com/item?id=24615185" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://news.ycombinator.com/item?id=24615185', event);">raised some eyebrows</a>, but it also made a real point about the power of template literal types. Given a TypeScript version of your database schema (which can be generated using <a target="_blank" rel="noopener" href="https://github.com/PSYT/schemats" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/PSYT/schemats', event);">schemats</a> or <a target="_blank" rel="noopener" href="https://github.com/danvk/schemats" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://github.com/danvk/schemats', event);">pg-to-ts</a>), it should be possible to infer result types for a SQL query:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123;Schema&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./dbschema&#x27;</span>;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStudentsByAge</span>(<span class="hljs-params">db: Pool, age: <span class="hljs-built_in">number</span></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> db.query&lt;Schema&gt;(<span class="hljs-string">`</span><br><span class="hljs-string">  SELECT first_name, last_name FROM students</span><br><span class="hljs-string">  WHERE age = $1;</span><br><span class="hljs-string">  `</span>, [age]);  <span class="hljs-comment">// checks that type of age is number</span><br>  <span class="hljs-keyword">return</span> result.rows;<br>  <span class="hljs-comment">// type is &#123;first_name: string, last_name: string&#125;[]</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>This seems potentially amazing, but also perhaps brittle. You&#39;d have to work in the subset of SQL that your types understood: presumably you wouldn&#39;t want to implement all of <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/PL/pgSQL" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://en.wikipedia.org/wiki/PL/pgSQL', event);">PL/pgSQL</a> in the type system. But I could imagine getting a large class of queries, including joins, to work.</p>
<p>So I&#39;m on the fence on this one! Similar considerations apply to GraphQL queries, which would be a bit easier to join with a schema in the type system than raw SQL.</p>
</li>
</ul>
<p>Template literal types open up many new doors for TypeScript library authors and should improve the overall experience of using TypeScript for everyone by capturing more JavaScript patterns in the type system.</p>
<p>I&#39;d like to conclude by pointing out that this is a very <em>TypeScripty</em> solution to this problem. TypeScript is full of &quot;puns&quot; between value and type syntax. Depending on the context, <code>&quot;foo&quot;</code> could either be the literal value <code>&quot;foo&quot;</code> or a type consisting of the single value <code>&quot;foo&quot;</code>. (I explore this in Item 8 of <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://amzn.to/3HIrQN6', event);"><em>Effective TypeScript</em></a>, &quot;Know How to Tell Whether a Symbol Is in the Type Space or Value Space&quot;). Another famous example is <a target="_blank" rel="noopener" href="https://basarat.gitbook.io/typescript/type-system/index-signatures" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://basarat.gitbook.io/typescript/type-system/index-signatures', event);">index types</a>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">const</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">12</span>&#125;;<br><span class="hljs-keyword">const</span> value = obj[<span class="hljs-string">&#x27;x&#x27;</span>];  <span class="hljs-comment">// JS index operator, value at runtime is 12.</span><br><span class="hljs-keyword">type</span> T = (<span class="hljs-keyword">typeof</span> obj)[<span class="hljs-string">&#x27;x&#x27;</span>];  <span class="hljs-comment">// TS index operator, type is number.</span><br></code></pre></td></tr></table></figure>

<p>Template literal types continue this pattern by repurposing a runtime JavaScript syntax (template strings) into something that makes sense in the type system (template literal types). The <code>concat</code> function really hammers this home:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><code class="hljs ts"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">concat</span>&lt;<span class="hljs-title">A</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>, <span class="hljs-title">B</span> <span class="hljs-title">extends</span> <span class="hljs-title">string</span>&gt;(<span class="hljs-params">a: A, b: B</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span><span class="hljs-subst">$&#123;b&#125;</span>`</span> <span class="hljs-keyword">as</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;A&#125;</span><span class="hljs-subst">$&#123;B&#125;</span>`</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>On the return line, <code>`$&#123;a&#125;$&#123;b&#125;`</code> is the runtime JavaScript template literal and <code>`$&#123;A&#125;$&#123;B&#125;`</code> is the TypeScript type. It&#39;s not an accident that they look identical!</p>
<p>I never would have thought to do it this way, but kudos to Anders and the TypeScript team for coming up with such an on-brand solution!</p>
<p><em>Image credit: modified version of <a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Nuclear_fission_chain_reaction.svg" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://commons.wikimedia.org/wiki/File:Nuclear_fission_chain_reaction.svg', event);">File:Nuclear fission chain reaction.svg</a> from Wiki Commons</em></p>
<!--
Good use cases for template literal types:

- Parsing express routes (my tweet)
  - Also react-router routes
- Type-safe lodash accessors ('a.b.c')
- Better type inference for querySelector
- Parsing options in Commander

Ones I'm less sure of:
- Parsing SQL to infer result types

reach deep into domains

This is a very TypeScript-y solution to the problem.

link to the awesome list somewhere

-->


          </div>
        </div>
      </div>
    </div>
  </div>

  <div class="follow-or-subscribe">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          Like this post? Consider subscribing to
          <a href="/mail/" onclick="return trackOutboundLink('subscribe newsletter', '/mail/', event);">my newsletter</a>,
          the <a href="/atom.xml" onclick="return trackOutboundLink('follow RSS', '/atom.xml', event);">RSS feed</a>,
          or <a target="_blank" rel="noopener" href="https://twitter.com/danvdk" onclick="return trackOutboundLink('follow on twitter', 'https://twitter.com/danvdk', event);">following me</a>
          on Twitter.
        </div>
      </div>
    </div>
  </div>

  <div class="comments">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <script src="https://utteranc.es/client.js" repo="danvk/effective-typescript" issue-term="title" label="ðŸ’¬ blog comments" theme="github-light" crossorigin="anonymous" async>
          </script>
        </div>
      </div>
    </div>
  </div>

  <div class="promotion">
    <div class="row">
      <div class="col-sm-12 text-center">
        <a target="_blank" rel="noopener" href="https://amzn.to/3UjPrsK" class="btn btn-info btn-lg primary" onclick="return trackOutboundLink('buy2e', 'https://amzn.to/3UjPrsK', event);">Buy 2nd Edition</a>
        <!--
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" data-tag="post learn more hover" class="btn btn-info btn-lg primary">Buy the Book</a>
          <a target="_blank" rel="noopener" href="https://www.ebooks.com/en-us/209820951/effective-typescript/dan-vanderkam/?_c=1" data-tag="post learn more hover" class="btn btn-info btn-lg hidden-xs">Buy eBook</a>
          https://amzn.to/3UjPrsK
        -->
        <a href="/mail/" class="btn btn-info btn-lg" onclick="return trackOutboundLink('post learn more hover', '/mail/', event);">Subscribe</a>
      </div>
    </div>
  </div>

  <div class="page-content">
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <a target="_blank" rel="noopener" href="https://amzn.to/3HIrQN6" onclick="return trackOutboundLink('post learn more cover image', 'https://amzn.to/3HIrQN6', event);">
            <img src="/images/cover-2e.jpg" class="learn-more-photo" alt="Effective TypeScript Book Cover">
          </a>
          <p><strong><em>Effective TypeScript</em></strong> shows you not just <em>how</em> to use TypeScript but how to use it <em>well</em>. The book&#39;s 62 items help you build mental models of how TypeScript and its ecosystem work, make you aware of pitfalls and traps to avoid, and guide you toward using TypeScriptâ€™s many capabilities in the most effective ways possible. Regardless of your level of TypeScript experience, you can learn something from this book.</p>
<p>After reading <em>Effective TypeScript</em>, your relationship with the type system will be the most productive it&#39;s ever been! <a href="/">Learn more Â»</a></p>

        </div>
      </div>
    </div>
  </div>

</section>

  <footer id="contentinfo" class="footer">
  <div class="container">
    <address id="about" class="vcard body">
      &copy; 2019 - 2024 <a class="url fn" target="_blank" rel="noopener" href="https://danvk.org" onclick="trackOutboundLink('footer', 'https://danvk.org'); return false;">Dan Vanderkam</a>
      <div class="footer-attribution">Powered by <a href="https://hexo.io/" target="_blank" onclick="return trackOutboundLink('what can should you do with template literal types', 'https://hexo.io/', event);">Hexo</a></div>
    </address>
  </div>
</footer>
</body>
</html>
